{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Dex.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$();\n\nimport React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { MintLayout } from \"@solana/spl-token\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { Market, OpenOrders, Orderbook as OrderbookSide } from \"@project-serum/serum\";\nimport { DEX_PID, USDC_MINT, USDT_MINT, SOL_MINT, WRAPPED_SOL_MINT, WORM_USDC_MINT, WORM_USDT_MINT, WORM_USDC_MARKET, WORM_USDT_MARKET, WORM_MARKET_BASE } from \"../utils/pubkeys\";\nimport { useTokenMap, useTokenListContext } from \"./TokenList\";\nimport { fetchSolletInfo, requestWormholeSwapMarketIfNeeded } from \"./Sollet\";\nimport { setMintCache } from \"./Token\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BASE_TAKER_FEE_BPS = 0.0022;\nexport const FEE_MULTIPLIER = 1 - BASE_TAKER_FEE_BPS;\n\nconst _DexContext = /*#__PURE__*/React.createContext(null);\n\nexport function DexContextProvider(props) {\n  _s();\n\n  const [ooAccounts, setOoAccounts] = useState(new Map());\n  const swapClient = props.swapClient; // Removes the given open orders from the context.\n\n  const closeOpenOrders = async openOrder => {\n    var _newOoAccounts$get;\n\n    const newOoAccounts = new Map(ooAccounts);\n    const openOrders = (_newOoAccounts$get = newOoAccounts.get(openOrder.market.toString())) === null || _newOoAccounts$get === void 0 ? void 0 : _newOoAccounts$get.filter(oo => !oo.address.equals(openOrder.address));\n\n    if (openOrders && openOrders.length > 0) {\n      newOoAccounts.set(openOrder.market.toString(), openOrders);\n    } else {\n      newOoAccounts.delete(openOrder.market.toString());\n    }\n\n    setOoAccounts(newOoAccounts);\n  }; // Three operations:\n  //\n  // 1. Fetch all open orders accounts for the connected wallet.\n  // 2. Batch fetch all market accounts for those open orders.\n  // 3. Batch fetch all mints associated with the markets.\n\n\n  useEffect(() => {\n    // if (!swapClient.program.provider.wallet.publicKey) {\n    //   setOoAccounts(new Map());\n    //   return;\n    // }\n    OpenOrders.findForOwner(swapClient.program.provider.connection, swapClient.program.provider.wallet.publicKey, DEX_PID).then(async openOrders => {\n      const newOoAccounts = new Map();\n      let markets = new Set();\n      openOrders.forEach(oo => {\n        markets.add(oo.market.toString());\n\n        if (newOoAccounts.get(oo.market.toString())) {\n          newOoAccounts.get(oo.market.toString()).push(oo);\n        } else {\n          newOoAccounts.set(oo.market.toString(), [oo]);\n        }\n      });\n\n      if (markets.size > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\"Too many markets. Please file an issue to update this\");\n      }\n\n      const multipleMarkets = await anchor.utils.rpc.getMultipleAccounts(swapClient.program.provider.connection, Array.from(markets.values()).map(m => new PublicKey(m)));\n      const marketClients = multipleMarkets.map(programAccount => {\n        return {\n          publicKey: programAccount === null || programAccount === void 0 ? void 0 : programAccount.publicKey,\n          account: new Market(Market.getLayout(DEX_PID).decode(programAccount === null || programAccount === void 0 ? void 0 : programAccount.account.data), -1, // Set below so that we can batch fetch mints.\n          -1, // Set below so that we can batch fetch mints.\n          swapClient.program.provider.opts, DEX_PID)\n        };\n      });\n      setOoAccounts(newOoAccounts); // Batch fetch all the mints, since we know we'll need them at some\n      // point.\n\n      const mintPubkeys = Array.from(new Set(marketClients.map(m => [m.account.baseMintAddress.toString(), m.account.quoteMintAddress.toString()]).flat()).values()).map(pk => new PublicKey(pk));\n\n      if (mintPubkeys.length > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\"Too many mints. Please file an issue to update this\");\n      }\n\n      const mints = await anchor.utils.rpc.getMultipleAccounts(swapClient.program.provider.connection, mintPubkeys);\n      const mintInfos = mints.map(mint => {\n        const mintInfo = MintLayout.decode(mint.account.data);\n        setMintCache(mint.publicKey, mintInfo);\n        return {\n          publicKey: mint.publicKey,\n          mintInfo\n        };\n      });\n      marketClients.forEach(m => {\n        const baseMintInfo = mintInfos.filter(mint => mint.publicKey.equals(m.account.baseMintAddress))[0];\n        const quoteMintInfo = mintInfos.filter(mint => mint.publicKey.equals(m.account.quoteMintAddress))[0];\n        assert.ok(baseMintInfo && quoteMintInfo); // @ts-ignore\n\n        m.account._baseSplTokenDecimals = baseMintInfo.mintInfo.decimals; // @ts-ignore\n\n        m.account._quoteSplTokenDecimals = quoteMintInfo.mintInfo.decimals;\n\n        _MARKET_CACHE.set(m.publicKey.toString(), new Promise(resolve => resolve(m.account)));\n      });\n    });\n  }, [// swapClient.program.provider.connection,\n    // swapClient.program.provider.wallet.publicKey,\n    // swapClient.program.provider.opts,\n  ]);\n  return /*#__PURE__*/_jsxDEV(_DexContext.Provider, {\n    value: {\n      openOrders: ooAccounts,\n      closeOpenOrders,\n      swapClient\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 163,\n    columnNumber: 5\n  }, this);\n}\n\n_s(DexContextProvider, \"jKMzPNtAQcGvDch42Ho2ndUPmyM=\");\n\n_c = DexContextProvider;\nexport function useDexContext() {\n  _s2();\n\n  const ctx = useContext(_DexContext);\n\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n\n  return ctx;\n}\n\n_s2(useDexContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\n\nexport function useOpenOrders() {\n  _s3();\n\n  const ctx = useDexContext();\n  return ctx.openOrders;\n} // Lazy load a given market.\n\n_s3(useOpenOrders, \"94WEhUdSpWdU4mS5j1qMu1aGxic=\", false, function () {\n  return [useDexContext];\n});\n\nexport function useMarket(market) {\n  _s4();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const asyncMarket = useAsync(async () => {\n    if (!market) {\n      return undefined;\n    }\n\n    if (_MARKET_CACHE.get(market.toString())) {\n      return _MARKET_CACHE.get(market.toString());\n    }\n\n    const marketClient = new Promise(async resolve => {\n      // TODO: if we already have the mints, then pass them through to the\n      //       market client here to save a network request.\n      const marketClient = await Market.load(swapClient.program.provider.connection, market, swapClient.program.provider.opts, DEX_PID);\n      resolve(marketClient);\n    });\n\n    _MARKET_CACHE.set(market.toString(), marketClient);\n\n    return marketClient;\n  }, [swapClient.program.provider.connection, market]);\n\n  if (asyncMarket.result) {\n    return asyncMarket.result;\n  }\n\n  return undefined;\n} // Lazy load the orderbook for a given market.\n\n_s4(useMarket, \"iJvA2rSv2MbqjQhLCzMZLk6dgMs=\", false, function () {\n  return [useDexContext, useAsync];\n});\n\nexport function useOrderbook(market) {\n  _s5();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const marketClient = useMarket(market);\n  const [refresh, setRefresh] = useState(0);\n  const asyncOrderbook = useAsync(async () => {\n    if (!market || !marketClient) {\n      return undefined;\n    }\n\n    if (_ORDERBOOK_CACHE.get(market.toString())) {\n      return _ORDERBOOK_CACHE.get(market.toString());\n    }\n\n    const orderbook = new Promise(async resolve => {\n      const [bids, asks] = await Promise.all([marketClient.loadBids(swapClient.program.provider.connection), marketClient.loadAsks(swapClient.program.provider.connection)]);\n      resolve({\n        bids,\n        asks\n      });\n    });\n\n    _ORDERBOOK_CACHE.set(market.toString(), orderbook);\n\n    return orderbook;\n  }, [refresh, swapClient.program.provider.connection, market, marketClient]); // Stream in bids updates.\n\n  useEffect(() => {\n    let listener;\n\n    if (marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, async info => {\n        const bids = OrderbookSide.decode(marketClient, info.data);\n        const orderbook = await _ORDERBOOK_CACHE.get(marketClient.address.toString());\n        const oldBestBid = orderbook === null || orderbook === void 0 ? void 0 : orderbook.bids.items(true).next().value;\n        const newBestBid = bids.items(true).next().value;\n\n        if (orderbook && oldBestBid && newBestBid && oldBestBid.price !== newBestBid.price) {\n          orderbook.bids = bids;\n          setRefresh(r => r + 1);\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [marketClient, marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, swapClient.program.provider.connection]); // Stream in asks updates.\n\n  useEffect(() => {\n    let listener;\n\n    if (marketClient === null || marketClient === void 0 ? void 0 : marketClient.asksAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(marketClient === null || marketClient === void 0 ? void 0 : marketClient.asksAddress, async info => {\n        const asks = OrderbookSide.decode(marketClient, info.data);\n        const orderbook = await _ORDERBOOK_CACHE.get(marketClient.address.toString());\n        const oldBestOffer = orderbook === null || orderbook === void 0 ? void 0 : orderbook.asks.items(false).next().value;\n        const newBestOffer = asks.items(false).next().value;\n\n        if (orderbook && oldBestOffer && newBestOffer && oldBestOffer.price !== newBestOffer.price) {\n          orderbook.asks = asks;\n          setRefresh(r => r + 1);\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [marketClient, marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, swapClient.program.provider.connection]);\n\n  if (asyncOrderbook.result) {\n    return asyncOrderbook.result;\n  }\n\n  return undefined;\n}\n\n_s5(useOrderbook, \"AFX7y/PBFBRUK7rRNrMmPjovavY=\", false, function () {\n  return [useDexContext, useMarket, useAsync];\n});\n\nexport function useMarketName(market) {\n  _s6();\n\n  var _tokenMap$get, _tokenMap$get2;\n\n  const tokenMap = useTokenMap();\n  const marketClient = useMarket(market);\n\n  if (!marketClient) {\n    return null;\n  }\n\n  const baseTicker = marketClient ? (_tokenMap$get = tokenMap.get(marketClient === null || marketClient === void 0 ? void 0 : marketClient.baseMintAddress.toString())) === null || _tokenMap$get === void 0 ? void 0 : _tokenMap$get.symbol : \"-\";\n  const quoteTicker = marketClient ? (_tokenMap$get2 = tokenMap.get(marketClient === null || marketClient === void 0 ? void 0 : marketClient.quoteMintAddress.toString())) === null || _tokenMap$get2 === void 0 ? void 0 : _tokenMap$get2.symbol : \"-\";\n  const name = `${baseTicker} / ${quoteTicker}`;\n  return name;\n} // Fair price for a given market, as defined by the mid.\n\n_s6(useMarketName, \"lyPzKNtPwMkdl3Mzppsg/jQfbKc=\", false, function () {\n  return [useTokenMap, useMarket];\n});\n\nexport function useBbo(market) {\n  _s7();\n\n  const orderbook = useOrderbook(market);\n\n  if (orderbook === undefined) {\n    return undefined;\n  }\n\n  const bestBid = orderbook.bids.items(true).next().value;\n  const bestOffer = orderbook.asks.items(false).next().value;\n\n  if (!bestBid && !bestOffer) {\n    return {};\n  }\n\n  if (!bestBid) {\n    return {\n      bestOffer: bestOffer.price\n    };\n  }\n\n  if (!bestOffer) {\n    return {\n      bestBid: bestBid.price\n    };\n  }\n\n  const mid = (bestBid.price + bestOffer.price) / 2.0;\n  return {\n    bestBid: bestBid.price,\n    bestOffer: bestOffer.price,\n    mid\n  };\n} // Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\n\n_s7(useBbo, \"Jruu7KTvlHgz8wl6nClH4is55vs=\", false, function () {\n  return [useOrderbook];\n});\n\nexport function useFairRoute(fromMint, toMint) {\n  _s8();\n\n  const route = useRoute(fromMint, toMint);\n  const fromBbo = useBbo(route ? route[0] : undefined);\n  const fromMarket = useMarket(route ? route[0] : undefined);\n  const toBbo = useBbo(route ? route[1] : undefined);\n\n  if (route === null) {\n    return undefined;\n  }\n\n  if (route.length === 1 && fromBbo !== undefined) {\n    if (fromMarket === undefined) {\n      return undefined;\n    }\n\n    if ((fromMarket === null || fromMarket === void 0 ? void 0 : fromMarket.baseMintAddress.equals(fromMint)) || (fromMarket === null || fromMarket === void 0 ? void 0 : fromMarket.baseMintAddress.equals(WRAPPED_SOL_MINT)) && fromMint.equals(SOL_MINT)) {\n      return fromBbo.bestBid && 1.0 / fromBbo.bestBid;\n    } else {\n      return fromBbo.bestOffer && fromBbo.bestOffer;\n    }\n  }\n\n  if (fromBbo === undefined || fromBbo.bestBid === undefined || toBbo === undefined || toBbo.bestOffer === undefined) {\n    return undefined;\n  }\n\n  return toBbo.bestOffer / fromBbo.bestBid;\n}\n\n_s8(useFairRoute, \"eFSbQ5TJT+4F6LrF7pQ1HraMOho=\", false, function () {\n  return [useRoute, useBbo, useMarket, useBbo];\n});\n\nexport function useRoute(fromMint, toMint) {\n  _s9();\n\n  const route = useRouteVerbose(fromMint, toMint);\n\n  if (route === null) {\n    return null;\n  }\n\n  return route.markets;\n} // Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\n\n_s9(useRoute, \"ZF5u5G2LvCfS4my7H9bdifWPr50=\", false, function () {\n  return [useRouteVerbose];\n});\n\nexport function useRouteVerbose(fromMint, toMint) {\n  _s10();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const {\n    wormholeMap,\n    solletMap\n  } = useTokenListContext();\n  const asyncRoute = useAsync(async () => {\n    const swapMarket = await wormholeSwapMarket(swapClient.program.provider.connection, fromMint, toMint, wormholeMap, solletMap);\n\n    if (swapMarket !== null) {\n      const [wormholeMarket, kind] = swapMarket;\n      return {\n        markets: [wormholeMarket],\n        kind\n      };\n    }\n\n    const markets = swapClient.route(fromMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : fromMint, toMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : toMint);\n\n    if (markets === null) {\n      return null;\n    }\n\n    const kind = \"usdx\";\n    return {\n      markets,\n      kind\n    };\n  }, [fromMint, toMint, swapClient]);\n\n  if (asyncRoute.result) {\n    return asyncRoute.result;\n  }\n\n  return null;\n}\n\n_s10(useRouteVerbose, \"c/2lDLujGcE40LXK4dsyQkBudcY=\", false, function () {\n  return [useDexContext, useTokenListContext, useAsync];\n});\n\n// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nconst WORMHOLE_NATIVE_MAP = new Map([[wormKey(WORM_USDC_MINT, USDC_MINT), WORM_USDC_MARKET], [wormKey(WORM_USDT_MINT, USDT_MINT), WORM_USDT_MARKET]]);\n\nfunction wormKey(fromMint, toMint) {\n  const [first, second] = fromMint < toMint ? [fromMint, toMint] : [toMint, fromMint];\n  return first.toString() + second.toString();\n}\n\nasync function wormholeSwapMarket(conn, fromMint, toMint, wormholeMap, solletMap) {\n  let market = wormholeNativeMarket(fromMint, toMint);\n\n  if (market !== null) {\n    return [market, \"wormhole-native\"];\n  }\n\n  market = await wormholeSolletMarket(conn, fromMint, toMint, wormholeMap, solletMap);\n\n  if (market === null) {\n    return null;\n  }\n\n  return [market, \"wormhole-sollet\"];\n}\n\nfunction wormholeNativeMarket(fromMint, toMint) {\n  var _WORMHOLE_NATIVE_MAP$;\n\n  return (_WORMHOLE_NATIVE_MAP$ = WORMHOLE_NATIVE_MAP.get(wormKey(fromMint, toMint))) !== null && _WORMHOLE_NATIVE_MAP$ !== void 0 ? _WORMHOLE_NATIVE_MAP$ : null;\n} // Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\n\n\nasync function wormholeSolletMarket(conn, fromMint, toMint, wormholeMap, solletMap) {\n  const fromWormhole = wormholeMap.get(fromMint.toString());\n  const isFromWormhole = fromWormhole !== undefined;\n  const toWormhole = wormholeMap.get(toMint.toString());\n  const isToWormhole = toWormhole !== undefined;\n  const fromSollet = solletMap.get(fromMint.toString());\n  const isFromSollet = fromSollet !== undefined;\n  const toSollet = solletMap.get(toMint.toString());\n  const isToSollet = toSollet !== undefined;\n\n  if ((isFromWormhole || isToWormhole) && isFromWormhole !== isToWormhole) {\n    if ((isFromSollet || isToSollet) && isFromSollet !== isToSollet) {\n      var _extensions;\n\n      const base = isFromSollet ? fromMint : toMint;\n      const [quote, wormholeInfo] = isFromWormhole ? [fromMint, fromWormhole] : [toMint, toWormhole];\n      const solletInfo = await fetchSolletInfo(base);\n\n      if (solletInfo.erc20Contract !== ((_extensions = wormholeInfo.extensions) === null || _extensions === void 0 ? void 0 : _extensions.address)) {\n        return null;\n      }\n\n      const market = await deriveWormholeMarket(base, quote);\n\n      if (market === null) {\n        return null;\n      }\n\n      const marketExists = await requestWormholeSwapMarketIfNeeded(conn, base, quote, market, solletInfo);\n\n      if (!marketExists) {\n        return null;\n      }\n\n      return market;\n    }\n  }\n\n  return null;\n} // Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\n\n\nasync function deriveWormholeMarket(baseMint, quoteMint, version = 0) {\n  if (version > 99) {\n    console.log(\"Swap market version cannot be greater than 99\");\n    return null;\n  }\n\n  if (version < 0) {\n    console.log(\"Version cannot be less than zero\");\n    return null;\n  }\n\n  const padToTwo = n => n <= 99 ? `0${n}`.slice(-2) : n;\n\n  const seed = baseMint.toString().slice(0, 15) + quoteMint.toString().slice(0, 15) + padToTwo(version);\n  return await PublicKey.createWithSeed(WORM_MARKET_BASE, seed, DEX_PID);\n}\n\nconst _ORDERBOOK_CACHE = new Map();\n\nconst _MARKET_CACHE = new Map();\n\nvar _c;\n\n$RefreshReg$(_c, \"DexContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Dex.tsx"],"names":["React","useContext","useState","useEffect","assert","useAsync","MintLayout","PublicKey","anchor","Market","OpenOrders","Orderbook","OrderbookSide","DEX_PID","USDC_MINT","USDT_MINT","SOL_MINT","WRAPPED_SOL_MINT","WORM_USDC_MINT","WORM_USDT_MINT","WORM_USDC_MARKET","WORM_USDT_MARKET","WORM_MARKET_BASE","useTokenMap","useTokenListContext","fetchSolletInfo","requestWormholeSwapMarketIfNeeded","setMintCache","BASE_TAKER_FEE_BPS","FEE_MULTIPLIER","_DexContext","createContext","DexContextProvider","props","ooAccounts","setOoAccounts","Map","swapClient","closeOpenOrders","openOrder","newOoAccounts","openOrders","get","market","toString","filter","oo","address","equals","length","set","delete","findForOwner","program","provider","connection","wallet","publicKey","then","markets","Set","forEach","add","push","size","Error","multipleMarkets","utils","rpc","getMultipleAccounts","Array","from","values","map","m","marketClients","programAccount","account","getLayout","decode","data","opts","mintPubkeys","baseMintAddress","quoteMintAddress","flat","pk","mints","mintInfos","mint","mintInfo","baseMintInfo","quoteMintInfo","ok","_baseSplTokenDecimals","decimals","_quoteSplTokenDecimals","_MARKET_CACHE","Promise","resolve","children","useDexContext","ctx","useOpenOrders","useMarket","asyncMarket","undefined","marketClient","load","result","useOrderbook","refresh","setRefresh","asyncOrderbook","_ORDERBOOK_CACHE","orderbook","bids","asks","all","loadBids","loadAsks","listener","bidsAddress","onAccountChange","info","oldBestBid","items","next","value","newBestBid","price","r","removeAccountChangeListener","asksAddress","oldBestOffer","newBestOffer","useMarketName","tokenMap","baseTicker","symbol","quoteTicker","name","useBbo","bestBid","bestOffer","mid","useFairRoute","fromMint","toMint","route","useRoute","fromBbo","fromMarket","toBbo","useRouteVerbose","wormholeMap","solletMap","asyncRoute","swapMarket","wormholeSwapMarket","wormholeMarket","kind","WORMHOLE_NATIVE_MAP","wormKey","first","second","conn","wormholeNativeMarket","wormholeSolletMarket","fromWormhole","isFromWormhole","toWormhole","isToWormhole","fromSollet","isFromSollet","toSollet","isToSollet","base","quote","wormholeInfo","solletInfo","erc20Contract","extensions","deriveWormholeMarket","marketExists","baseMint","quoteMint","version","console","log","padToTwo","n","slice","seed","createWithSeed"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { MintLayout } from \"@solana/spl-token\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { Swap as SwapClient } from \"@project-serum/swap\";\nimport {\n  Market,\n  OpenOrders,\n  Orderbook as OrderbookSide,\n} from \"@project-serum/serum\";\nimport {\n  DEX_PID,\n  USDC_MINT,\n  USDT_MINT,\n  SOL_MINT,\n  WRAPPED_SOL_MINT,\n  WORM_USDC_MINT,\n  WORM_USDT_MINT,\n  WORM_USDC_MARKET,\n  WORM_USDT_MARKET,\n  WORM_MARKET_BASE,\n} from \"../utils/pubkeys\";\nimport { useTokenMap, useTokenListContext } from \"./TokenList\";\nimport { fetchSolletInfo, requestWormholeSwapMarketIfNeeded } from \"./Sollet\";\nimport { setMintCache } from \"./Token\";\n\nconst BASE_TAKER_FEE_BPS = 0.0022;\nexport const FEE_MULTIPLIER = 1 - BASE_TAKER_FEE_BPS;\n\ntype DexContext = {\n  // Maps market address to open orders accounts.\n  openOrders: Map<string, Array<OpenOrders>>;\n  closeOpenOrders: (openOrder: OpenOrders) => void;\n  swapClient: SwapClient;\n};\nconst _DexContext = React.createContext<DexContext | null>(null);\n\nexport function DexContextProvider(props: any) {\n  const [ooAccounts, setOoAccounts] = useState<Map<string, Array<OpenOrders>>>(\n    new Map()\n  );\n  const swapClient = props.swapClient;\n\n  // Removes the given open orders from the context.\n  const closeOpenOrders = async (openOrder: OpenOrders) => {\n    const newOoAccounts = new Map(ooAccounts);\n    const openOrders = newOoAccounts\n      .get(openOrder.market.toString())\n      ?.filter((oo: OpenOrders) => !oo.address.equals(openOrder.address));\n    if (openOrders && openOrders.length > 0) {\n      newOoAccounts.set(openOrder.market.toString(), openOrders);\n    } else {\n      newOoAccounts.delete(openOrder.market.toString());\n    }\n    setOoAccounts(newOoAccounts);\n  };\n\n  // Three operations:\n  //\n  // 1. Fetch all open orders accounts for the connected wallet.\n  // 2. Batch fetch all market accounts for those open orders.\n  // 3. Batch fetch all mints associated with the markets.\n  useEffect(() => {\n    // if (!swapClient.program.provider.wallet.publicKey) {\n    //   setOoAccounts(new Map());\n    //   return;\n    // }\n    OpenOrders.findForOwner(\n      swapClient.program.provider.connection,\n      swapClient.program.provider.wallet.publicKey,\n      DEX_PID\n    ).then(async (openOrders) => {\n      const newOoAccounts = new Map();\n      let markets = new Set<string>();\n      openOrders.forEach((oo) => {\n        markets.add(oo.market.toString());\n        if (newOoAccounts.get(oo.market.toString())) {\n          newOoAccounts.get(oo.market.toString()).push(oo);\n        } else {\n          newOoAccounts.set(oo.market.toString(), [oo]);\n        }\n      });\n      if (markets.size > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\n          \"Too many markets. Please file an issue to update this\"\n        );\n      }\n      const multipleMarkets = await anchor.utils.rpc.getMultipleAccounts(\n        swapClient.program.provider.connection,\n        Array.from(markets.values()).map((m) => new PublicKey(m))\n      );\n      const marketClients = multipleMarkets.map((programAccount) => {\n        return {\n          publicKey: programAccount?.publicKey,\n          account: new Market(\n            Market.getLayout(DEX_PID).decode(programAccount?.account.data),\n            -1, // Set below so that we can batch fetch mints.\n            -1, // Set below so that we can batch fetch mints.\n            swapClient.program.provider.opts,\n            DEX_PID\n          ),\n        };\n      });\n\n      setOoAccounts(newOoAccounts);\n\n      // Batch fetch all the mints, since we know we'll need them at some\n      // point.\n      const mintPubkeys = Array.from(\n        new Set<string>(\n          marketClients\n            .map((m) => [\n              m.account.baseMintAddress.toString(),\n              m.account.quoteMintAddress.toString(),\n            ])\n            .flat()\n        ).values()\n      ).map((pk) => new PublicKey(pk));\n\n      if (mintPubkeys.length > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\"Too many mints. Please file an issue to update this\");\n      }\n\n      const mints = await anchor.utils.rpc.getMultipleAccounts(\n        swapClient.program.provider.connection,\n        mintPubkeys\n      );\n      const mintInfos = mints.map((mint) => {\n        const mintInfo = MintLayout.decode(mint!.account.data);\n        setMintCache(mint!.publicKey, mintInfo);\n        return { publicKey: mint!.publicKey, mintInfo };\n      });\n\n      marketClients.forEach((m) => {\n        const baseMintInfo = mintInfos.filter((mint) =>\n          mint.publicKey.equals(m.account.baseMintAddress)\n        )[0];\n        const quoteMintInfo = mintInfos.filter((mint) =>\n          mint.publicKey.equals(m.account.quoteMintAddress)\n        )[0];\n        assert.ok(baseMintInfo && quoteMintInfo);\n        // @ts-ignore\n        m.account._baseSplTokenDecimals = baseMintInfo.mintInfo.decimals;\n        // @ts-ignore\n        m.account._quoteSplTokenDecimals = quoteMintInfo.mintInfo.decimals;\n        _MARKET_CACHE.set(\n          m.publicKey!.toString(),\n          new Promise<Market>((resolve) => resolve(m.account))\n        );\n      });\n    });\n  }, [\n    // swapClient.program.provider.connection,\n    // swapClient.program.provider.wallet.publicKey,\n    // swapClient.program.provider.opts,\n  ]);\n  return (\n    <_DexContext.Provider\n      value={{\n        openOrders: ooAccounts,\n        closeOpenOrders,\n        swapClient,\n      }}\n    >\n      {props.children}\n    </_DexContext.Provider>\n  );\n}\n\nexport function useDexContext(): DexContext {\n  const ctx = useContext(_DexContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useOpenOrders(): Map<string, Array<OpenOrders>> {\n  const ctx = useDexContext();\n  return ctx.openOrders;\n}\n\n// Lazy load a given market.\nexport function useMarket(market?: PublicKey): Market | undefined {\n  const { swapClient } = useDexContext();\n\n  const asyncMarket = useAsync(async () => {\n    if (!market) {\n      return undefined;\n    }\n    if (_MARKET_CACHE.get(market.toString())) {\n      return _MARKET_CACHE.get(market.toString());\n    }\n\n    const marketClient = new Promise<Market>(async (resolve) => {\n      // TODO: if we already have the mints, then pass them through to the\n      //       market client here to save a network request.\n      const marketClient = await Market.load(\n        swapClient.program.provider.connection,\n        market,\n        swapClient.program.provider.opts,\n        DEX_PID\n      );\n      resolve(marketClient);\n    });\n\n    _MARKET_CACHE.set(market.toString(), marketClient);\n    return marketClient;\n  }, [swapClient.program.provider.connection, market]);\n\n  if (asyncMarket.result) {\n    return asyncMarket.result;\n  }\n\n  return undefined;\n}\n\n// Lazy load the orderbook for a given market.\nexport function useOrderbook(market?: PublicKey): Orderbook | undefined {\n  const { swapClient } = useDexContext();\n  const marketClient = useMarket(market);\n  const [refresh, setRefresh] = useState(0);\n\n  const asyncOrderbook = useAsync(async () => {\n    if (!market || !marketClient) {\n      return undefined;\n    }\n    if (_ORDERBOOK_CACHE.get(market.toString())) {\n      return _ORDERBOOK_CACHE.get(market.toString());\n    }\n\n    const orderbook = new Promise<Orderbook>(async (resolve) => {\n      const [bids, asks] = await Promise.all([\n        marketClient.loadBids(swapClient.program.provider.connection),\n        marketClient.loadAsks(swapClient.program.provider.connection),\n      ]);\n\n      resolve({\n        bids,\n        asks,\n      });\n    });\n\n    _ORDERBOOK_CACHE.set(market.toString(), orderbook);\n\n    return orderbook;\n  }, [refresh, swapClient.program.provider.connection, market, marketClient]);\n\n  // Stream in bids updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.bidsAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.bidsAddress,\n        async (info) => {\n          const bids = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestBid = orderbook?.bids.items(true).next().value;\n          const newBestBid = bids.items(true).next().value;\n          if (\n            orderbook &&\n            oldBestBid &&\n            newBestBid &&\n            oldBestBid.price !== newBestBid.price\n          ) {\n            orderbook.bids = bids;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  // Stream in asks updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.asksAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.asksAddress,\n        async (info) => {\n          const asks = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestOffer = orderbook?.asks.items(false).next().value;\n          const newBestOffer = asks.items(false).next().value;\n          if (\n            orderbook &&\n            oldBestOffer &&\n            newBestOffer &&\n            oldBestOffer.price !== newBestOffer.price\n          ) {\n            orderbook.asks = asks;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  if (asyncOrderbook.result) {\n    return asyncOrderbook.result;\n  }\n\n  return undefined;\n}\n\nexport function useMarketName(market: PublicKey): string | null {\n  const tokenMap = useTokenMap();\n  const marketClient = useMarket(market);\n  if (!marketClient) {\n    return null;\n  }\n  const baseTicker = marketClient\n    ? tokenMap.get(marketClient?.baseMintAddress.toString())?.symbol\n    : \"-\";\n  const quoteTicker = marketClient\n    ? tokenMap.get(marketClient?.quoteMintAddress.toString())?.symbol\n    : \"-\";\n  const name = `${baseTicker} / ${quoteTicker}`;\n  return name;\n}\n\n// Fair price for a given market, as defined by the mid.\nexport function useBbo(market?: PublicKey): Bbo | undefined {\n  const orderbook = useOrderbook(market);\n  if (orderbook === undefined) {\n    return undefined;\n  }\n  const bestBid = orderbook.bids.items(true).next().value;\n  const bestOffer = orderbook.asks.items(false).next().value;\n  if (!bestBid && !bestOffer) {\n    return {};\n  }\n  if (!bestBid) {\n    return { bestOffer: bestOffer.price };\n  }\n  if (!bestOffer) {\n    return { bestBid: bestBid.price };\n  }\n  const mid = (bestBid.price + bestOffer.price) / 2.0;\n  return { bestBid: bestBid.price, bestOffer: bestOffer.price, mid };\n}\n\n// Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\nexport function useFairRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): number | undefined {\n  const route = useRoute(fromMint, toMint);\n  const fromBbo = useBbo(route ? route[0] : undefined);\n  const fromMarket = useMarket(route ? route[0] : undefined);\n  const toBbo = useBbo(route ? route[1] : undefined);\n\n  if (route === null) {\n    return undefined;\n  }\n\n  if (route.length === 1 && fromBbo !== undefined) {\n    if (fromMarket === undefined) {\n      return undefined;\n    }\n    if (\n      fromMarket?.baseMintAddress.equals(fromMint) ||\n      (fromMarket?.baseMintAddress.equals(WRAPPED_SOL_MINT) &&\n        fromMint.equals(SOL_MINT))\n    ) {\n      return fromBbo.bestBid && 1.0 / fromBbo.bestBid;\n    } else {\n      return fromBbo.bestOffer && fromBbo.bestOffer;\n    }\n  }\n  if (\n    fromBbo === undefined ||\n    fromBbo.bestBid === undefined ||\n    toBbo === undefined ||\n    toBbo.bestOffer === undefined\n  ) {\n    return undefined;\n  }\n  return toBbo.bestOffer / fromBbo.bestBid;\n}\n\nexport function useRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): Array<PublicKey> | null {\n  const route = useRouteVerbose(fromMint, toMint);\n  if (route === null) {\n    return null;\n  }\n  return route.markets;\n}\n\n// Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\nexport function useRouteVerbose(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): { markets: Array<PublicKey>; kind: RouteKind } | null {\n  const { swapClient } = useDexContext();\n  const { wormholeMap, solletMap } = useTokenListContext();\n  const asyncRoute = useAsync(async () => {\n    const swapMarket = await wormholeSwapMarket(\n      swapClient.program.provider.connection,\n      fromMint,\n      toMint,\n      wormholeMap,\n      solletMap\n    );\n    if (swapMarket !== null) {\n      const [wormholeMarket, kind] = swapMarket;\n      return { markets: [wormholeMarket], kind };\n    }\n    const markets = swapClient.route(\n      fromMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : fromMint,\n      toMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : toMint\n    );\n    if (markets === null) {\n      return null;\n    }\n    const kind: RouteKind = \"usdx\";\n    return { markets, kind };\n  }, [fromMint, toMint, swapClient]);\n\n  if (asyncRoute.result) {\n    return asyncRoute.result;\n  }\n  return null;\n}\n\ntype Orderbook = {\n  bids: OrderbookSide;\n  asks: OrderbookSide;\n};\n\n// Wormhole utils.\n\ntype RouteKind = \"wormhole-native\" | \"wormhole-sollet\" | \"usdx\";\n\n// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nconst WORMHOLE_NATIVE_MAP = new Map<string, PublicKey>([\n  [wormKey(WORM_USDC_MINT, USDC_MINT), WORM_USDC_MARKET],\n  [wormKey(WORM_USDT_MINT, USDT_MINT), WORM_USDT_MARKET],\n]);\n\nfunction wormKey(fromMint: PublicKey, toMint: PublicKey): string {\n  const [first, second] =\n    fromMint < toMint ? [fromMint, toMint] : [toMint, fromMint];\n  return first.toString() + second.toString();\n}\n\nasync function wormholeSwapMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<[PublicKey, RouteKind] | null> {\n  let market = wormholeNativeMarket(fromMint, toMint);\n  if (market !== null) {\n    return [market, \"wormhole-native\"];\n  }\n  market = await wormholeSolletMarket(\n    conn,\n    fromMint,\n    toMint,\n    wormholeMap,\n    solletMap\n  );\n  if (market === null) {\n    return null;\n  }\n  return [market, \"wormhole-sollet\"];\n}\n\nfunction wormholeNativeMarket(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): PublicKey | null {\n  return WORMHOLE_NATIVE_MAP.get(wormKey(fromMint, toMint)) ?? null;\n}\n\n// Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\nasync function wormholeSolletMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<PublicKey | null> {\n  const fromWormhole = wormholeMap.get(fromMint.toString());\n  const isFromWormhole = fromWormhole !== undefined;\n\n  const toWormhole = wormholeMap.get(toMint.toString());\n  const isToWormhole = toWormhole !== undefined;\n\n  const fromSollet = solletMap.get(fromMint.toString());\n  const isFromSollet = fromSollet !== undefined;\n\n  const toSollet = solletMap.get(toMint.toString());\n  const isToSollet = toSollet !== undefined;\n\n  if ((isFromWormhole || isToWormhole) && isFromWormhole !== isToWormhole) {\n    if ((isFromSollet || isToSollet) && isFromSollet !== isToSollet) {\n      const base = isFromSollet ? fromMint : toMint;\n      const [quote, wormholeInfo] = isFromWormhole\n        ? [fromMint, fromWormhole]\n        : [toMint, toWormhole];\n\n      const solletInfo = await fetchSolletInfo(base);\n\n      if (solletInfo.erc20Contract !== wormholeInfo!.extensions?.address) {\n        return null;\n      }\n\n      const market = await deriveWormholeMarket(base, quote);\n      if (market === null) {\n        return null;\n      }\n\n      const marketExists = await requestWormholeSwapMarketIfNeeded(\n        conn,\n        base,\n        quote,\n        market,\n        solletInfo\n      );\n      if (!marketExists) {\n        return null;\n      }\n\n      return market;\n    }\n  }\n  return null;\n}\n\n// Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\nasync function deriveWormholeMarket(\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  version = 0\n): Promise<PublicKey | null> {\n  if (version > 99) {\n    console.log(\"Swap market version cannot be greater than 99\");\n    return null;\n  }\n  if (version < 0) {\n    console.log(\"Version cannot be less than zero\");\n    return null;\n  }\n\n  const padToTwo = (n: number) => (n <= 99 ? `0${n}`.slice(-2) : n);\n  const seed =\n    baseMint.toString().slice(0, 15) +\n    quoteMint.toString().slice(0, 15) +\n    padToTwo(version);\n  return await PublicKey.createWithSeed(WORM_MARKET_BASE, seed, DEX_PID);\n}\n\ntype Bbo = {\n  bestBid?: number;\n  bestOffer?: number;\n  mid?: number;\n};\n\nconst _ORDERBOOK_CACHE = new Map<string, Promise<Orderbook>>();\nconst _MARKET_CACHE = new Map<string, Promise<Market>>();\n"]},"metadata":{},"sourceType":"module"}