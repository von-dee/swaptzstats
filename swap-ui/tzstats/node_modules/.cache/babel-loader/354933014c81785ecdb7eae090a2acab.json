{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Swap = void 0;\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar spl_token_1 = require(\"@solana/spl-token\");\n\nvar anchor_1 = require(\"@project-serum/anchor\");\n\nvar serum_1 = require(\"@project-serum/serum\");\n\nvar idl_1 = require(\"./idl\");\n\nvar utils_1 = require(\"./utils\");\n\nvar swap_markets_1 = __importDefault(require(\"./swap-markets\")); // Close account feature flag.\n//\n// TODO: enable once the DEX supports closing open orders accounts.\n\n\nvar CLOSE_ENABLED = false;\n/**\n *\n * # Swap\n *\n * A module to swap tokens across markets the Serum DEX, providing a thin\n * wrapper around an [Anchor](https://github.com/project-serum/anchor) client\n * for the purpose of providing a simplified `swap` API.\n *\n * ## Swap Program Basics\n *\n * One should have a basic understanding of the on-chain\n * [Swap](https://github.com/project-serum/swap) program before using the\n * client. Two core APIs are exposed.\n *\n * * [swap](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L36) -\n *   swaps two tokens on a single A/B market. This is just an IOC trade at the\n *   BBO that instantly settles.\n * * [swapTransitive](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L107) -\n *   swaps two tokens across **two** A/x, B/x markets in the same manner as\n *   `swap`.\n *\n * For both APIs, if the number of tokens received from the trade is less than\n * the client provided `minExchangeRate`, the transaction aborts.\n *\n * Note that if this client package is insufficient, one can always use the\n * Anchor generated client directly, exposing an API mapping one-to-one to\n * these program instructions. See the\n * [`tests/`](https://github.com/project-serum/swap/blob/master/tests/swap.js)\n * for examples of using the Anchor generated swap client.\n *\n * ## Serum Orderbook Program Basics\n *\n * Additionally, because the Swap program is an on-chain frontend for the Serum\n * DEX, one should also be aware of the basic accounts needed for trading on\n * the Serum DEX.\n *\n * Namely, a wallet must have an \"open orders\" account for each market the\n * wallet trades on. The \"open orders\" account is akin to how a wallet\n *  must have an SPL token account to own tokens, except instead of holding\n * tokens, the wallet can make trades on the orderbook.\n *\n * ### Creating Open Orders Accounts\n *\n * When the wallet doesn't have an open orders account already created,\n * the swap client provides two choices. Automatically create the required\n * accounts by preloading the instructions in the [[swap]] transaction.\n *\n * Note that if the user is swapping between two non-USD(x) tokens, e.g., wBTC\n * for wETH, then the user needs *two* open orders accounts on both wBTC/USD(x)\n * and wETH/USD(x) markets. In the event both of these open orders accounts are\n * created for the rfirst time, then the transaction is broken up into two\n * (and `Provider.sendAll` is used) to prevent hitting transaction size limits.\n */\n\nvar Swap = /*#__PURE__*/function () {\n  /**\n   * @param provider  The wallet and network context to use for the client.\n   * @param tokenList The token list providing market addresses for each mint.\n   */\n  function Swap(provider, tokenList) {\n    _classCallCheck(this, Swap);\n\n    this._program = new anchor_1.Program(idl_1.IDL, utils_1.SWAP_PID, provider);\n    this._swapMarkets = new swap_markets_1.default(provider, tokenList);\n  }\n  /**\n   * Anchor generated client for the swap program.\n   */\n\n\n  _createClass(Swap, [{\n    key: \"program\",\n    get: function get() {\n      return this._program;\n    }\n    /**\n     * Token list registry for fetching USD(x) markets for each mint.\n     */\n\n  }, {\n    key: \"swapMarkets\",\n    get: function get() {\n      return this._swapMarkets;\n    }\n    /**\n     * Returns a list of markets to trade across to swap `fromMint` to `toMint`.\n     */\n\n  }, {\n    key: \"route\",\n    value: function route(fromMint, toMint) {\n      return this.swapMarkets.route(fromMint, toMint);\n    }\n    /**\n     * Executes a swap against the Serum DEX.\n     */\n\n  }, {\n    key: \"swap\",\n    value: function () {\n      var _swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(params) {\n        var pk, txs;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pk = this.program.provider.wallet.publicKey;\n\n                if (!(!pk || web3_js_1.PublicKey.default.equals(pk))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('Wallet not found');\n\n              case 3:\n                _context.next = 5;\n                return this.swapTxs(params);\n\n              case 5:\n                txs = _context.sent;\n\n                if (params.additionalTransactions) {\n                  txs = txs.concat(params.additionalTransactions);\n                }\n\n                return _context.abrupt(\"return\", this.program.provider.sendAll(txs, params.options));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function swap(_x) {\n        return _swap.apply(this, arguments);\n      }\n\n      return swap;\n    }()\n    /**\n     * Returns transactions for swapping on the Serum DEX.\n     */\n\n  }, {\n    key: \"swapTxs\",\n    value: function () {\n      var _swapTxs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params) {\n        var fromMint, toMint, quoteWallet, fromWallet, toWallet, quoteMint, fromMarket, toMarket, amount, minExchangeRate, referral, close, fromOpenOrders, toOpenOrders, coinWallet, pcWallet, baseMint, _quoteMint, side;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                fromMint = params.fromMint, toMint = params.toMint, quoteWallet = params.quoteWallet, fromWallet = params.fromWallet, toWallet = params.toWallet, quoteMint = params.quoteMint, fromMarket = params.fromMarket, toMarket = params.toMarket, amount = params.amount, minExchangeRate = params.minExchangeRate, referral = params.referral, close = params.close, fromOpenOrders = params.fromOpenOrders, toOpenOrders = params.toOpenOrders; // If swapping to/from a USD(x) token, then swap directly on the market.\n\n                if (!isUsdx(fromMint)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                coinWallet = toWallet;\n                pcWallet = fromWallet;\n                baseMint = toMint;\n                _quoteMint = fromMint;\n                side = Side.Bid; // Special case USDT/USDC market since the coin is always USDT and\n                // the pc is always USDC.\n\n                if (toMint.equals(utils_1.USDC_PUBKEY)) {\n                  coinWallet = fromWallet;\n                  pcWallet = toWallet;\n                  baseMint = fromMint;\n                  _quoteMint = toMint;\n                  side = Side.Ask;\n                } else if (toMint.equals(utils_1.USDT_PUBKEY)) {\n                  coinWallet = toWallet;\n                  pcWallet = fromWallet;\n                  baseMint = toMint;\n                  _quoteMint = _quoteMint;\n                  side = Side.Bid;\n                }\n\n                _context2.next = 10;\n                return this.swapDirectTxs({\n                  coinWallet: coinWallet,\n                  pcWallet: pcWallet,\n                  baseMint: baseMint,\n                  quoteMint: _quoteMint,\n                  side: side,\n                  amount: amount,\n                  minExchangeRate: minExchangeRate,\n                  referral: referral,\n                  close: close,\n                  fromMarket: fromMarket,\n                  fromOpenOrders: fromOpenOrders\n                });\n\n              case 10:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 13:\n                if (!isUsdx(toMint)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                _context2.next = 16;\n                return this.swapDirectTxs({\n                  coinWallet: fromWallet,\n                  pcWallet: toWallet,\n                  baseMint: fromMint,\n                  quoteMint: toMint,\n                  side: Side.Ask,\n                  amount: amount,\n                  minExchangeRate: minExchangeRate,\n                  referral: referral,\n                  close: close,\n                  fromMarket: fromMarket,\n                  fromOpenOrders: fromOpenOrders\n                });\n\n              case 16:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 17:\n                if (!(fromMarket !== undefined && toMarket === undefined)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                _context2.next = 20;\n                return this.swapDirectTxs({\n                  coinWallet: fromWallet,\n                  pcWallet: toWallet,\n                  baseMint: fromMint,\n                  quoteMint: toMint,\n                  side: fromMint.equals(fromMarket.baseMintAddress) ? Side.Ask : Side.Bid,\n                  amount: amount,\n                  minExchangeRate: minExchangeRate,\n                  referral: referral,\n                  close: close,\n                  fromMarket: fromMarket,\n                  fromOpenOrders: fromOpenOrders\n                });\n\n              case 20:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 21:\n                if (quoteMint) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                throw new Error('quoteMint must be provided for a transitive swap');\n\n              case 23:\n                if (toMarket) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw new Error('toMarket must be provided for transitive swaps');\n\n              case 25:\n                _context2.next = 27;\n                return this.swapTransitiveTxs({\n                  fromMint: fromMint,\n                  toMint: toMint,\n                  pcMint: quoteMint,\n                  fromWallet: fromWallet,\n                  toWallet: toWallet,\n                  pcWallet: quoteWallet,\n                  amount: amount,\n                  minExchangeRate: minExchangeRate,\n                  referral: referral,\n                  close: close,\n                  fromMarket: fromMarket,\n                  toMarket: toMarket,\n                  fromOpenOrders: fromOpenOrders,\n                  toOpenOrders: toOpenOrders\n                });\n\n              case 27:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function swapTxs(_x2) {\n        return _swapTxs.apply(this, arguments);\n      }\n\n      return swapTxs;\n    }()\n  }, {\n    key: \"swapDirectTxs\",\n    value: function () {\n      var _swapDirectTxs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref) {\n        var coinWallet, pcWallet, baseMint, quoteMint, side, amount, minExchangeRate, referral, close, fromMarket, fromOpenOrders, _yield$utils_1$getVau, _yield$utils_1$getVau2, vaultSigner, openOrders, needsOpenOrders, tx, signers, oo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                coinWallet = _ref.coinWallet, pcWallet = _ref.pcWallet, baseMint = _ref.baseMint, quoteMint = _ref.quoteMint, side = _ref.side, amount = _ref.amount, minExchangeRate = _ref.minExchangeRate, referral = _ref.referral, close = _ref.close, fromMarket = _ref.fromMarket, fromOpenOrders = _ref.fromOpenOrders;\n                _context3.next = 3;\n                return utils_1.getVaultOwnerAndNonce(fromMarket.address);\n\n              case 3:\n                _yield$utils_1$getVau = _context3.sent;\n                _yield$utils_1$getVau2 = _slicedToArray(_yield$utils_1$getVau, 1);\n                vaultSigner = _yield$utils_1$getVau2[0];\n                openOrders = fromOpenOrders;\n                needsOpenOrders = openOrders === undefined;\n                tx = new web3_js_1.Transaction();\n                signers = []; // If either wallet isn't given, then create the associated token account.\n\n                if (coinWallet) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                _context3.next = 13;\n                return utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, this.program.provider.wallet.publicKey);\n\n              case 13:\n                coinWallet = _context3.sent;\n                tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, coinWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n\n              case 15:\n                if (pcWallet) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.next = 18;\n                return utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, this.program.provider.wallet.publicKey);\n\n              case 18:\n                pcWallet = _context3.sent;\n                tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n\n              case 20:\n                if (!needsOpenOrders) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                oo = web3_js_1.Keypair.generate();\n                signers.push(oo);\n                openOrders = oo.publicKey;\n                _context3.t0 = tx;\n                _context3.next = 27;\n                return serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID);\n\n              case 27:\n                _context3.t1 = _context3.sent;\n\n                _context3.t0.add.call(_context3.t0, _context3.t1);\n\n              case 29:\n                tx.add(this.program.instruction.swap(side, amount, minExchangeRate, {\n                  accounts: {\n                    market: {\n                      market: fromMarket.address,\n                      // @ts-ignore\n                      requestQueue: fromMarket._decoded.requestQueue,\n                      // @ts-ignore\n                      eventQueue: fromMarket._decoded.eventQueue,\n                      bids: fromMarket.bidsAddress,\n                      asks: fromMarket.asksAddress,\n                      // @ts-ignore\n                      coinVault: fromMarket._decoded.baseVault,\n                      // @ts-ignore\n                      pcVault: fromMarket._decoded.quoteVault,\n                      vaultSigner: vaultSigner,\n                      openOrders: openOrders,\n                      orderPayerTokenAccount: side.bid ? pcWallet : coinWallet,\n                      coinWallet: coinWallet\n                    },\n                    pcWallet: pcWallet,\n                    authority: this.program.provider.wallet.publicKey,\n                    dexProgram: utils_1.DEX_PID,\n                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                    rent: spl_token_1.TOKEN_PROGRAM_ID\n                  },\n                  remainingAccounts: referral && [{\n                    pubkey: referral,\n                    isWritable: true,\n                    isSigner: false\n                  }]\n                })); // If an account was opened for this swap, then close it in the same\n                // transaction.\n\n                if (CLOSE_ENABLED && close && needsOpenOrders) {\n                  tx.add(this.program.instruction.closeAccount({\n                    accounts: {\n                      openOrders: openOrders,\n                      authority: this.program.provider.wallet.publicKey,\n                      destination: this.program.provider.wallet.publicKey,\n                      market: fromMarket.address,\n                      dexProgram: utils_1.DEX_PID\n                    }\n                  }));\n                }\n\n                return _context3.abrupt(\"return\", [{\n                  tx: tx,\n                  signers: signers\n                }]);\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function swapDirectTxs(_x3) {\n        return _swapDirectTxs.apply(this, arguments);\n      }\n\n      return swapDirectTxs;\n    }()\n  }, {\n    key: \"swapTransitiveTxs\",\n    value: function () {\n      var _swapTransitiveTxs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref2) {\n        var fromMint, toMint, pcMint, fromWallet, toWallet, pcWallet, amount, minExchangeRate, referral, close, fromMarket, toMarket, fromOpenOrders, toOpenOrders, fromNeedsOpenOrders, toNeedsOpenOrders, openOrdersTransaction, openOrdersSigners, swapTransaction, swapSigners, closeTransaction, closeSigners, _yield$utils_1$getVau3, _yield$utils_1$getVau4, fromVaultSigner, _yield$utils_1$getVau5, _yield$utils_1$getVau6, toVaultSigner, ooFrom, ooTo, oo, _oo, txs;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                fromMint = _ref2.fromMint, toMint = _ref2.toMint, pcMint = _ref2.pcMint, fromWallet = _ref2.fromWallet, toWallet = _ref2.toWallet, pcWallet = _ref2.pcWallet, amount = _ref2.amount, minExchangeRate = _ref2.minExchangeRate, referral = _ref2.referral, close = _ref2.close, fromMarket = _ref2.fromMarket, toMarket = _ref2.toMarket, fromOpenOrders = _ref2.fromOpenOrders, toOpenOrders = _ref2.toOpenOrders;\n                // If the open orders are undefined, assume they don't exist.\n                fromNeedsOpenOrders = fromOpenOrders === undefined;\n                toNeedsOpenOrders = toOpenOrders === undefined; // In the event the transaction would be over the transaction size limit,\n                // we break up the transaction into multiple and use `Provider.sendAll`\n                // as a workaround, providing a single user flow for the swap action.\n                //\n                // Alternatively, one could breakup the different actions here into explicit\n                // user flows. I.e., three separate flows for creating open orders\n                // counts, swapping, and closing open orders accounts. If choosing to do\n                // this, it's recommended to use the anchor generated client directly,\n                // instead of the client here.\n\n                openOrdersTransaction = undefined;\n                openOrdersSigners = [];\n                swapTransaction = new web3_js_1.Transaction();\n                swapSigners = [];\n                closeTransaction = undefined;\n                closeSigners = []; // Calculate the vault signers for each market.\n\n                _context4.next = 11;\n                return utils_1.getVaultOwnerAndNonce(fromMarket.address);\n\n              case 11:\n                _yield$utils_1$getVau3 = _context4.sent;\n                _yield$utils_1$getVau4 = _slicedToArray(_yield$utils_1$getVau3, 1);\n                fromVaultSigner = _yield$utils_1$getVau4[0];\n                _context4.next = 16;\n                return utils_1.getVaultOwnerAndNonce(toMarket.address);\n\n              case 16:\n                _yield$utils_1$getVau5 = _context4.sent;\n                _yield$utils_1$getVau6 = _slicedToArray(_yield$utils_1$getVau5, 1);\n                toVaultSigner = _yield$utils_1$getVau6[0];\n\n                if (fromWallet) {\n                  _context4.next = 24;\n                  break;\n                }\n\n                _context4.next = 22;\n                return utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, this.program.provider.wallet.publicKey);\n\n              case 22:\n                fromWallet = _context4.sent;\n                swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, fromWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n\n              case 24:\n                if (toWallet) {\n                  _context4.next = 29;\n                  break;\n                }\n\n                _context4.next = 27;\n                return utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, this.program.provider.wallet.publicKey);\n\n              case 27:\n                toWallet = _context4.sent;\n                swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, toWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n\n              case 29:\n                if (pcWallet) {\n                  _context4.next = 34;\n                  break;\n                }\n\n                _context4.next = 32;\n                return utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, this.program.provider.wallet.publicKey);\n\n              case 32:\n                pcWallet = _context4.sent;\n                swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n\n              case 34:\n                if (!(fromNeedsOpenOrders && toNeedsOpenOrders)) {\n                  _context4.next = 56;\n                  break;\n                }\n\n                openOrdersTransaction = new web3_js_1.Transaction();\n                ooFrom = web3_js_1.Keypair.generate();\n                openOrdersSigners.push(ooFrom);\n                _context4.t0 = openOrdersTransaction;\n                _context4.next = 41;\n                return serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, ooFrom.publicKey, utils_1.DEX_PID);\n\n              case 41:\n                _context4.t1 = _context4.sent;\n\n                _context4.t0.add.call(_context4.t0, _context4.t1);\n\n                fromOpenOrders = ooFrom.publicKey;\n                ooTo = web3_js_1.Keypair.generate();\n                openOrdersSigners.push(ooTo);\n                _context4.t2 = openOrdersTransaction;\n                _context4.next = 49;\n                return serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, ooTo.publicKey, utils_1.DEX_PID);\n\n              case 49:\n                _context4.t3 = _context4.sent;\n\n                _context4.t2.add.call(_context4.t2, _context4.t3);\n\n                toOpenOrders = ooTo.publicKey;\n                openOrdersTransaction.add(this.program.instruction.initAccount({\n                  accounts: {\n                    openOrders: ooFrom.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY\n                  }\n                }));\n                openOrdersTransaction.add(this.program.instruction.initAccount({\n                  accounts: {\n                    openOrders: ooTo.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: toMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY\n                  }\n                }));\n                _context4.next = 76;\n                break;\n\n              case 56:\n                if (!fromNeedsOpenOrders) {\n                  _context4.next = 67;\n                  break;\n                }\n\n                oo = web3_js_1.Keypair.generate();\n                swapSigners.push(oo);\n                _context4.t4 = swapTransaction;\n                _context4.next = 62;\n                return serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID);\n\n              case 62:\n                _context4.t5 = _context4.sent;\n\n                _context4.t4.add.call(_context4.t4, _context4.t5);\n\n                fromOpenOrders = oo.publicKey;\n                _context4.next = 76;\n                break;\n\n              case 67:\n                if (!toNeedsOpenOrders) {\n                  _context4.next = 76;\n                  break;\n                }\n\n                _oo = web3_js_1.Keypair.generate();\n                swapSigners.push(_oo);\n                _context4.t6 = swapTransaction;\n                _context4.next = 73;\n                return serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, _oo.publicKey, utils_1.DEX_PID);\n\n              case 73:\n                _context4.t7 = _context4.sent;\n\n                _context4.t6.add.call(_context4.t6, _context4.t7);\n\n                toOpenOrders = _oo.publicKey;\n\n              case 76:\n                swapTransaction.add(this.program.instruction.swapTransitive(amount, minExchangeRate, {\n                  accounts: {\n                    from: {\n                      market: fromMarket.address,\n                      // @ts-ignore\n                      requestQueue: fromMarket._decoded.requestQueue,\n                      // @ts-ignore\n                      eventQueue: fromMarket._decoded.eventQueue,\n                      bids: fromMarket.bidsAddress,\n                      asks: fromMarket.asksAddress,\n                      // @ts-ignore\n                      coinVault: fromMarket._decoded.baseVault,\n                      // @ts-ignore\n                      pcVault: fromMarket._decoded.quoteVault,\n                      vaultSigner: fromVaultSigner,\n                      openOrders: fromOpenOrders,\n                      orderPayerTokenAccount: fromWallet,\n                      coinWallet: fromWallet\n                    },\n                    to: {\n                      market: toMarket.address,\n                      // @ts-ignore\n                      requestQueue: toMarket._decoded.requestQueue,\n                      // @ts-ignore\n                      eventQueue: toMarket._decoded.eventQueue,\n                      bids: toMarket.bidsAddress,\n                      asks: toMarket.asksAddress,\n                      // @ts-ignore\n                      coinVault: toMarket._decoded.baseVault,\n                      // @ts-ignore\n                      pcVault: toMarket._decoded.quoteVault,\n                      vaultSigner: toVaultSigner,\n                      openOrders: toOpenOrders,\n                      orderPayerTokenAccount: pcWallet,\n                      coinWallet: toWallet\n                    },\n                    pcWallet: pcWallet,\n                    authority: this.program.provider.wallet.publicKey,\n                    dexProgram: utils_1.DEX_PID,\n                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                    rent: spl_token_1.TOKEN_PROGRAM_ID\n                  },\n                  remainingAccounts: referral && [{\n                    pubkey: referral,\n                    isWritable: true,\n                    isSigner: false\n                  }]\n                }));\n\n                if (CLOSE_ENABLED && close && fromNeedsOpenOrders) {\n                  closeTransaction = new web3_js_1.Transaction();\n                  closeTransaction.add(this.program.instruction.closeAccount({\n                    accounts: {\n                      openOrders: fromOpenOrders,\n                      authority: this.program.provider.wallet.publicKey,\n                      destination: this.program.provider.wallet.publicKey,\n                      market: fromMarket.address,\n                      dexProgram: utils_1.DEX_PID\n                    }\n                  }));\n                }\n\n                if (CLOSE_ENABLED && close && toNeedsOpenOrders) {\n                  if (!closeTransaction) {\n                    closeTransaction = new web3_js_1.Transaction();\n                  }\n\n                  closeTransaction.add(this.program.instruction.closeAccount({\n                    accounts: {\n                      openOrders: toOpenOrders,\n                      authority: this.program.provider.wallet.publicKey,\n                      destination: this.program.provider.wallet.publicKey,\n                      market: toMarket.address,\n                      dexProgram: utils_1.DEX_PID\n                    }\n                  }));\n                }\n\n                txs = [];\n\n                if (openOrdersTransaction !== undefined) {\n                  txs.push({\n                    tx: openOrdersTransaction,\n                    signers: openOrdersSigners\n                  });\n                }\n\n                txs.push({\n                  tx: swapTransaction,\n                  signers: swapSigners\n                });\n\n                if (closeTransaction !== undefined) {\n                  txs.push({\n                    tx: closeTransaction,\n                    signers: closeSigners\n                  });\n                }\n\n                return _context4.abrupt(\"return\", txs);\n\n              case 84:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function swapTransitiveTxs(_x4) {\n        return _swapTransitiveTxs.apply(this, arguments);\n      }\n\n      return swapTransitiveTxs;\n    }()\n  }]);\n\n  return Swap;\n}();\n\nexports.Swap = Swap;\n\nfunction isUsdx(mint) {\n  return mint.equals(utils_1.USDC_PUBKEY) || mint.equals(utils_1.USDT_PUBKEY);\n}\n\nvar Side = {\n  Bid: {\n    bid: {}\n  },\n  Ask: {\n    ask: {}\n  }\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Swap = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst anchor_1 = require(\"@project-serum/anchor\");\nconst serum_1 = require(\"@project-serum/serum\");\nconst idl_1 = require(\"./idl\");\nconst utils_1 = require(\"./utils\");\nconst swap_markets_1 = __importDefault(require(\"./swap-markets\"));\n// Close account feature flag.\n//\n// TODO: enable once the DEX supports closing open orders accounts.\nconst CLOSE_ENABLED = false;\n/**\n *\n * # Swap\n *\n * A module to swap tokens across markets the Serum DEX, providing a thin\n * wrapper around an [Anchor](https://github.com/project-serum/anchor) client\n * for the purpose of providing a simplified `swap` API.\n *\n * ## Swap Program Basics\n *\n * One should have a basic understanding of the on-chain\n * [Swap](https://github.com/project-serum/swap) program before using the\n * client. Two core APIs are exposed.\n *\n * * [swap](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L36) -\n *   swaps two tokens on a single A/B market. This is just an IOC trade at the\n *   BBO that instantly settles.\n * * [swapTransitive](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L107) -\n *   swaps two tokens across **two** A/x, B/x markets in the same manner as\n *   `swap`.\n *\n * For both APIs, if the number of tokens received from the trade is less than\n * the client provided `minExchangeRate`, the transaction aborts.\n *\n * Note that if this client package is insufficient, one can always use the\n * Anchor generated client directly, exposing an API mapping one-to-one to\n * these program instructions. See the\n * [`tests/`](https://github.com/project-serum/swap/blob/master/tests/swap.js)\n * for examples of using the Anchor generated swap client.\n *\n * ## Serum Orderbook Program Basics\n *\n * Additionally, because the Swap program is an on-chain frontend for the Serum\n * DEX, one should also be aware of the basic accounts needed for trading on\n * the Serum DEX.\n *\n * Namely, a wallet must have an \"open orders\" account for each market the\n * wallet trades on. The \"open orders\" account is akin to how a wallet\n *  must have an SPL token account to own tokens, except instead of holding\n * tokens, the wallet can make trades on the orderbook.\n *\n * ### Creating Open Orders Accounts\n *\n * When the wallet doesn't have an open orders account already created,\n * the swap client provides two choices. Automatically create the required\n * accounts by preloading the instructions in the [[swap]] transaction.\n *\n * Note that if the user is swapping between two non-USD(x) tokens, e.g., wBTC\n * for wETH, then the user needs *two* open orders accounts on both wBTC/USD(x)\n * and wETH/USD(x) markets. In the event both of these open orders accounts are\n * created for the rfirst time, then the transaction is broken up into two\n * (and `Provider.sendAll` is used) to prevent hitting transaction size limits.\n */\nclass Swap {\n    /**\n     * @param provider  The wallet and network context to use for the client.\n     * @param tokenList The token list providing market addresses for each mint.\n     */\n    constructor(provider, tokenList) {\n        this._program = new anchor_1.Program(idl_1.IDL, utils_1.SWAP_PID, provider);\n        this._swapMarkets = new swap_markets_1.default(provider, tokenList);\n    }\n    /**\n     * Anchor generated client for the swap program.\n     */\n    get program() {\n        return this._program;\n    }\n    /**\n     * Token list registry for fetching USD(x) markets for each mint.\n     */\n    get swapMarkets() {\n        return this._swapMarkets;\n    }\n    /**\n     * Returns a list of markets to trade across to swap `fromMint` to `toMint`.\n     */\n    route(fromMint, toMint) {\n        return this.swapMarkets.route(fromMint, toMint);\n    }\n    /**\n     * Executes a swap against the Serum DEX.\n     */\n    async swap(params) {\n        const pk = this.program.provider.wallet.publicKey;\n        if (!pk || web3_js_1.PublicKey.default.equals(pk)) {\n            throw new Error('Wallet not found');\n        }\n        let txs = await this.swapTxs(params);\n        if (params.additionalTransactions) {\n            txs = txs.concat(params.additionalTransactions);\n        }\n        return this.program.provider.sendAll(txs, params.options);\n    }\n    /**\n     * Returns transactions for swapping on the Serum DEX.\n     */\n    async swapTxs(params) {\n        let { fromMint, toMint, quoteWallet, fromWallet, toWallet, quoteMint, fromMarket, toMarket, amount, minExchangeRate, referral, close, fromOpenOrders, toOpenOrders, } = params;\n        // If swapping to/from a USD(x) token, then swap directly on the market.\n        if (isUsdx(fromMint)) {\n            let coinWallet = toWallet;\n            let pcWallet = fromWallet;\n            let baseMint = toMint;\n            let quoteMint = fromMint;\n            let side = Side.Bid;\n            // Special case USDT/USDC market since the coin is always USDT and\n            // the pc is always USDC.\n            if (toMint.equals(utils_1.USDC_PUBKEY)) {\n                coinWallet = fromWallet;\n                pcWallet = toWallet;\n                baseMint = fromMint;\n                quoteMint = toMint;\n                side = Side.Ask;\n            }\n            else if (toMint.equals(utils_1.USDT_PUBKEY)) {\n                coinWallet = toWallet;\n                pcWallet = fromWallet;\n                baseMint = toMint;\n                quoteMint = quoteMint;\n                side = Side.Bid;\n            }\n            return await this.swapDirectTxs({\n                coinWallet,\n                pcWallet,\n                baseMint,\n                quoteMint,\n                side,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        else if (isUsdx(toMint)) {\n            return await this.swapDirectTxs({\n                coinWallet: fromWallet,\n                pcWallet: toWallet,\n                baseMint: fromMint,\n                quoteMint: toMint,\n                side: Side.Ask,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        // Direct swap market explicitly given.\n        if (fromMarket !== undefined && toMarket === undefined) {\n            return await this.swapDirectTxs({\n                coinWallet: fromWallet,\n                pcWallet: toWallet,\n                baseMint: fromMint,\n                quoteMint: toMint,\n                side: fromMint.equals(fromMarket.baseMintAddress) ? Side.Ask : Side.Bid,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        // Neither wallet is a USD stable coin. So perform a transitive swap.\n        if (!quoteMint) {\n            throw new Error('quoteMint must be provided for a transitive swap');\n        }\n        if (!toMarket) {\n            throw new Error('toMarket must be provided for transitive swaps');\n        }\n        return await this.swapTransitiveTxs({\n            fromMint,\n            toMint,\n            pcMint: quoteMint,\n            fromWallet,\n            toWallet,\n            pcWallet: quoteWallet,\n            amount,\n            minExchangeRate,\n            referral,\n            close,\n            fromMarket,\n            toMarket,\n            fromOpenOrders,\n            toOpenOrders,\n        });\n    }\n    async swapDirectTxs({ coinWallet, pcWallet, baseMint, quoteMint, side, amount, minExchangeRate, referral, close, fromMarket, fromOpenOrders, }) {\n        const [vaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n        let openOrders = fromOpenOrders;\n        const needsOpenOrders = openOrders === undefined;\n        const tx = new web3_js_1.Transaction();\n        const signers = [];\n        // If either wallet isn't given, then create the associated token account.\n        if (!coinWallet) {\n            coinWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, this.program.provider.wallet.publicKey);\n            tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, coinWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!pcWallet) {\n            pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, this.program.provider.wallet.publicKey);\n            tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        // Create the open orders account, if needed.\n        if (needsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            signers.push(oo);\n            openOrders = oo.publicKey;\n            tx.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n        }\n        tx.add(this.program.instruction.swap(side, amount, minExchangeRate, {\n            accounts: {\n                market: {\n                    market: fromMarket.address,\n                    // @ts-ignore\n                    requestQueue: fromMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: fromMarket._decoded.eventQueue,\n                    bids: fromMarket.bidsAddress,\n                    asks: fromMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: fromMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: fromMarket._decoded.quoteVault,\n                    vaultSigner,\n                    openOrders,\n                    orderPayerTokenAccount: side.bid ? pcWallet : coinWallet,\n                    coinWallet: coinWallet,\n                },\n                pcWallet,\n                authority: this.program.provider.wallet.publicKey,\n                dexProgram: utils_1.DEX_PID,\n                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                rent: spl_token_1.TOKEN_PROGRAM_ID,\n            },\n            remainingAccounts: referral && [\n                { pubkey: referral, isWritable: true, isSigner: false },\n            ],\n        }));\n        // If an account was opened for this swap, then close it in the same\n        // transaction.\n        if (CLOSE_ENABLED && close && needsOpenOrders) {\n            tx.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        return [{ tx, signers }];\n    }\n    async swapTransitiveTxs({ fromMint, toMint, pcMint, fromWallet, toWallet, pcWallet, amount, minExchangeRate, referral, close, fromMarket, toMarket, fromOpenOrders, toOpenOrders, }) {\n        // If the open orders are undefined, assume they don't exist.\n        const fromNeedsOpenOrders = fromOpenOrders === undefined;\n        const toNeedsOpenOrders = toOpenOrders === undefined;\n        // In the event the transaction would be over the transaction size limit,\n        // we break up the transaction into multiple and use `Provider.sendAll`\n        // as a workaround, providing a single user flow for the swap action.\n        //\n        // Alternatively, one could breakup the different actions here into explicit\n        // user flows. I.e., three separate flows for creating open orders\n        // counts, swapping, and closing open orders accounts. If choosing to do\n        // this, it's recommended to use the anchor generated client directly,\n        // instead of the client here.\n        let openOrdersTransaction = undefined;\n        const openOrdersSigners = [];\n        const swapTransaction = new web3_js_1.Transaction();\n        const swapSigners = [];\n        let closeTransaction = undefined;\n        const closeSigners = [];\n        // Calculate the vault signers for each market.\n        const [fromVaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n        const [toVaultSigner] = await utils_1.getVaultOwnerAndNonce(toMarket.address);\n        // If token accounts aren't given, create them.\n        if (!fromWallet) {\n            fromWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, fromWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!toWallet) {\n            toWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, toWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!pcWallet) {\n            pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        // Add instructions to create open orders, if needed.\n        //\n        // If creating open orders accounts on *both* from and to markets, then\n        // split out the create open orders instructions into their own transaction.\n        if (fromNeedsOpenOrders && toNeedsOpenOrders) {\n            openOrdersTransaction = new web3_js_1.Transaction();\n            const ooFrom = web3_js_1.Keypair.generate();\n            openOrdersSigners.push(ooFrom);\n            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, ooFrom.publicKey, utils_1.DEX_PID));\n            fromOpenOrders = ooFrom.publicKey;\n            const ooTo = web3_js_1.Keypair.generate();\n            openOrdersSigners.push(ooTo);\n            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, ooTo.publicKey, utils_1.DEX_PID));\n            toOpenOrders = ooTo.publicKey;\n            openOrdersTransaction.add(this.program.instruction.initAccount({\n                accounts: {\n                    openOrders: ooFrom.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,\n                },\n            }));\n            openOrdersTransaction.add(this.program.instruction.initAccount({\n                accounts: {\n                    openOrders: ooTo.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: toMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,\n                },\n            }));\n        }\n        else if (fromNeedsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            swapSigners.push(oo);\n            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n            fromOpenOrders = oo.publicKey;\n        }\n        else if (toNeedsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            swapSigners.push(oo);\n            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n            toOpenOrders = oo.publicKey;\n        }\n        swapTransaction.add(this.program.instruction.swapTransitive(amount, minExchangeRate, {\n            accounts: {\n                from: {\n                    market: fromMarket.address,\n                    // @ts-ignore\n                    requestQueue: fromMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: fromMarket._decoded.eventQueue,\n                    bids: fromMarket.bidsAddress,\n                    asks: fromMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: fromMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: fromMarket._decoded.quoteVault,\n                    vaultSigner: fromVaultSigner,\n                    openOrders: fromOpenOrders,\n                    orderPayerTokenAccount: fromWallet,\n                    coinWallet: fromWallet,\n                },\n                to: {\n                    market: toMarket.address,\n                    // @ts-ignore\n                    requestQueue: toMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: toMarket._decoded.eventQueue,\n                    bids: toMarket.bidsAddress,\n                    asks: toMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: toMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: toMarket._decoded.quoteVault,\n                    vaultSigner: toVaultSigner,\n                    openOrders: toOpenOrders,\n                    orderPayerTokenAccount: pcWallet,\n                    coinWallet: toWallet,\n                },\n                pcWallet,\n                authority: this.program.provider.wallet.publicKey,\n                dexProgram: utils_1.DEX_PID,\n                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                rent: spl_token_1.TOKEN_PROGRAM_ID,\n            },\n            remainingAccounts: referral && [\n                { pubkey: referral, isWritable: true, isSigner: false },\n            ],\n        }));\n        if (CLOSE_ENABLED && close && fromNeedsOpenOrders) {\n            closeTransaction = new web3_js_1.Transaction();\n            closeTransaction.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders: fromOpenOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        if (CLOSE_ENABLED && close && toNeedsOpenOrders) {\n            if (!closeTransaction) {\n                closeTransaction = new web3_js_1.Transaction();\n            }\n            closeTransaction.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders: toOpenOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: toMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        const txs = [];\n        if (openOrdersTransaction !== undefined) {\n            txs.push({ tx: openOrdersTransaction, signers: openOrdersSigners });\n        }\n        txs.push({ tx: swapTransaction, signers: swapSigners });\n        if (closeTransaction !== undefined) {\n            txs.push({ tx: closeTransaction, signers: closeSigners });\n        }\n        return txs;\n    }\n}\nexports.Swap = Swap;\nfunction isUsdx(mint) {\n    return mint.equals(utils_1.USDC_PUBKEY) || mint.equals(utils_1.USDT_PUBKEY);\n}\nconst Side = {\n    Bid: { bid: {} },\n    Ask: { ask: {} },\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}