{"ast":null,"code":"import _objectSpread from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _classCallCheck from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _inherits from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import _wrapNativeSuper from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";import _regeneratorRuntime from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{useAsync}from\"react-async-hook\";import{PublicKey}from\"@solana/web3.js\";// Token info tracked by the sollet bridge.\nexport function useSolletInfo(mint){return useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",fetchSolletInfo(mint));case 1:case\"end\":return _context.stop();}}},_callee);})),[mint]);}// Fetches the token info from the sollet bridge.\nexport function fetchSolletInfo(_x){return _fetchSolletInfo.apply(this,arguments);}// Requests the creation of a sollet wormhole swap market, if it doesn't\n// already exist. Note: this triggers a creation notification. Creation\n// doesn't happen immediately, but at some unspecified point in the future\n// since market makers need to setup on the swap market and provide liquidity.\n//\n// Returns true if the market exists already. False otherwise.\nfunction _fetchSolletInfo(){_fetchSolletInfo=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(mint){var info,infoRaw;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:info=_SOLLET_INFO_CACHE.get(mint.toString());if(!(info!==undefined)){_context2.next=3;break;}return _context2.abrupt(\"return\",info);case 3:_context2.next=5;return swapApiRequest(\"GET\",\"coins/sol/\".concat(mint.toString()));case 5:infoRaw=_context2.sent;info=_objectSpread(_objectSpread({},infoRaw),{},{splMint:new PublicKey(infoRaw.splMint)});_SOLLET_INFO_CACHE.set(mint.toString(),info);return _context2.abrupt(\"return\",info);case 9:case\"end\":return _context2.stop();}}},_callee2);}));return _fetchSolletInfo.apply(this,arguments);}export function requestWormholeSwapMarketIfNeeded(_x2,_x3,_x4,_x5,_x6){return _requestWormholeSwapMarketIfNeeded.apply(this,arguments);}function _requestWormholeSwapMarketIfNeeded(){_requestWormholeSwapMarketIfNeeded=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection,solletMint,wormholeMint,swapMarket,solletInfo){var cached,acc,resource;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:cached=_SWAP_MARKET_EXISTS_CACHE.get(swapMarket.toString());if(!(cached!==undefined)){_context3.next=3;break;}return _context3.abrupt(\"return\",cached);case 3:_context3.next=5;return connection.getAccountInfo(swapMarket);case 5:acc=_context3.sent;if(!(acc===null)){_context3.next=13;break;}_SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(),false);resource=\"wormhole/pool/\".concat(solletInfo.ticker,\"/\").concat(swapMarket.toString(),\"/\").concat(solletMint.toString(),\"/\").concat(wormholeMint.toString());swapApiRequest(\"POST\",resource).catch(console.error);return _context3.abrupt(\"return\",false);case 13:_SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(),true);return _context3.abrupt(\"return\",true);case 15:case\"end\":return _context3.stop();}}},_callee3);}));return _requestWormholeSwapMarketIfNeeded.apply(this,arguments);}export function swapApiRequest(_x7,_x8,_x9){return _swapApiRequest.apply(this,arguments);}function _swapApiRequest(){_swapApiRequest=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(method,path,body){var headers,params,resp;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:headers={};params={headers:headers,method:method};if(method===\"GET\"){params.cache=\"no-cache\";}else if(body){headers[\"Content-Type\"]=\"application/json\";params.body=JSON.stringify(body);}_context4.next=5;return fetch(\"https://swap.sollet.io/api/\".concat(path),params);case 5:resp=_context4.sent;_context4.next=8;return handleSwapApiResponse(resp);case 8:return _context4.abrupt(\"return\",_context4.sent);case 9:case\"end\":return _context4.stop();}}},_callee4);}));return _swapApiRequest.apply(this,arguments);}function handleSwapApiResponse(_x10){return _handleSwapApiResponse.apply(this,arguments);}function _handleSwapApiResponse(){_handleSwapApiResponse=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(resp){var json;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return resp.json();case 2:json=_context5.sent;if(json.success){_context5.next=5;break;}throw new SwapApiError(json.error,resp.status);case 5:return _context5.abrupt(\"return\",json.result);case 6:case\"end\":return _context5.stop();}}},_callee5);}));return _handleSwapApiResponse.apply(this,arguments);}export var SwapApiError=/*#__PURE__*/function(_Error){_inherits(SwapApiError,_Error);var _super=_createSuper(SwapApiError);function SwapApiError(msg,status){var _this;_classCallCheck(this,SwapApiError);_this=_super.call(this,msg);_this.name=void 0;_this.status=void 0;_this.name=\"SwapApiError\";_this.status=status;return _this;}return SwapApiError;}(/*#__PURE__*/_wrapNativeSuper(Error));var _SOLLET_INFO_CACHE=new Map();var _SWAP_MARKET_EXISTS_CACHE=new Map();","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Sollet.tsx"],"names":["useAsync","PublicKey","useSolletInfo","mint","fetchSolletInfo","info","_SOLLET_INFO_CACHE","get","toString","undefined","swapApiRequest","infoRaw","splMint","set","requestWormholeSwapMarketIfNeeded","connection","solletMint","wormholeMint","swapMarket","solletInfo","cached","_SWAP_MARKET_EXISTS_CACHE","getAccountInfo","acc","resource","ticker","catch","console","error","method","path","body","headers","params","cache","JSON","stringify","fetch","resp","handleSwapApiResponse","json","success","SwapApiError","status","result","msg","name","Error","Map"],"mappings":"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","sourcesContent":["import { useAsync, UseAsyncReturn } from \"react-async-hook\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Token info tracked by the sollet bridge.\ntype SolletInfo = {\n  blockchain: string;\n  erc20Contract: string;\n  name: string;\n  splMint: PublicKey;\n  ticker: string;\n};\n\nexport function useSolletInfo(mint: PublicKey): UseAsyncReturn<SolletInfo> {\n  return useAsync(async () => {\n    return fetchSolletInfo(mint);\n  }, [mint]);\n}\n\n// Fetches the token info from the sollet bridge.\nexport async function fetchSolletInfo(mint: PublicKey): Promise<SolletInfo> {\n  let info = _SOLLET_INFO_CACHE.get(mint.toString());\n  if (info !== undefined) {\n    return info;\n  }\n\n  const infoRaw = await swapApiRequest(\"GET\", `coins/sol/${mint.toString()}`);\n  info = { ...infoRaw, splMint: new PublicKey(infoRaw.splMint) };\n  _SOLLET_INFO_CACHE.set(mint.toString(), info!);\n\n  return info!;\n}\n\n// Requests the creation of a sollet wormhole swap market, if it doesn't\n// already exist. Note: this triggers a creation notification. Creation\n// doesn't happen immediately, but at some unspecified point in the future\n// since market makers need to setup on the swap market and provide liquidity.\n//\n// Returns true if the market exists already. False otherwise.\nexport async function requestWormholeSwapMarketIfNeeded(\n  connection: Connection,\n  solletMint: PublicKey,\n  wormholeMint: PublicKey,\n  swapMarket: PublicKey,\n  solletInfo: SolletInfo\n): Promise<boolean> {\n  const cached = _SWAP_MARKET_EXISTS_CACHE.get(swapMarket.toString());\n  if (cached !== undefined) {\n    return cached;\n  }\n  const acc = await connection.getAccountInfo(swapMarket);\n  if (acc === null) {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), false);\n    const resource = `wormhole/pool/${\n      solletInfo.ticker\n    }/${swapMarket.toString()}/${solletMint.toString()}/${wormholeMint.toString()}`;\n    swapApiRequest(\"POST\", resource).catch(console.error);\n    return false;\n  } else {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), true);\n    return true;\n  }\n}\n\nexport async function swapApiRequest(\n  method: string,\n  path: string,\n  body?: Object\n) {\n  let headers: any = {};\n  let params: any = { headers, method };\n  if (method === \"GET\") {\n    params.cache = \"no-cache\";\n  } else if (body) {\n    headers[\"Content-Type\"] = \"application/json\";\n    params.body = JSON.stringify(body);\n  }\n  let resp = await fetch(`https://swap.sollet.io/api/${path}`, params);\n  return await handleSwapApiResponse(resp);\n}\n\nasync function handleSwapApiResponse(resp: Response) {\n  let json = await resp.json();\n  if (!json.success) {\n    throw new SwapApiError(json.error, resp.status);\n  }\n  return json.result;\n}\n\nexport class SwapApiError extends Error {\n  readonly name: string;\n  readonly status: number;\n  constructor(msg: string, status: number) {\n    super(msg);\n    this.name = \"SwapApiError\";\n    this.status = status;\n  }\n}\n\nconst _SOLLET_INFO_CACHE = new Map<string, SolletInfo>();\nconst _SWAP_MARKET_EXISTS_CACHE = new Map<string, boolean>();\n"]},"metadata":{},"sourceType":"module"}