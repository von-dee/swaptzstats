{"ast":null,"code":"import _regeneratorRuntime from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import*as assert from\"assert\";import React,{useContext,useState,useEffect}from\"react\";import{useAsync}from\"react-async-hook\";import{Token,ASSOCIATED_TOKEN_PROGRAM_ID,TOKEN_PROGRAM_ID}from\"@solana/spl-token\";import{USDC_MINT,USDT_MINT,TEZ_MINT,QUP_MINT}from\"../utils/pubkeys\";import{useFairRoute,useRouteVerbose,useDexContext,FEE_MULTIPLIER}from\"./Dex\";import{useTokenListContext,SPL_REGISTRY_SOLLET_TAG,SPL_REGISTRY_WORM_TAG}from\"./TokenList\";import{useOwnedTokenAccount}from\"../context/Token\";import{jsx as _jsx}from\"react/jsx-runtime\";var DEFAULT_SLIPPAGE_PERCENT=0.5;var _SwapContext=/*#__PURE__*/React.createContext(null);export function SwapContextProvider(props){var _props$fromMint,_props$toMint,_props$fromAmount,_props$toAmount;var _useState=useState((_props$fromMint=props.fromMint)!==null&&_props$fromMint!==void 0?_props$fromMint:TEZ_MINT),_useState2=_slicedToArray(_useState,2),fromMint=_useState2[0],setFromMint=_useState2[1];var _useState3=useState((_props$toMint=props.toMint)!==null&&_props$toMint!==void 0?_props$toMint:QUP_MINT),_useState4=_slicedToArray(_useState3,2),toMint=_useState4[0],setToMint=_useState4[1];var _useState5=useState((_props$fromAmount=props.fromAmount)!==null&&_props$fromAmount!==void 0?_props$fromAmount:0),_useState6=_slicedToArray(_useState5,2),fromAmount=_useState6[0],_setFromAmount=_useState6[1];var _useState7=useState((_props$toAmount=props.toAmount)!==null&&_props$toAmount!==void 0?_props$toAmount:0),_useState8=_slicedToArray(_useState7,2),toAmount=_useState8[0],_setToAmount=_useState8[1];var _useState9=useState(false),_useState10=_slicedToArray(_useState9,2),isClosingNewAccounts=_useState10[0],setIsClosingNewAccounts=_useState10[1];var _useState11=useState(false),_useState12=_slicedToArray(_useState11,2),isStrict=_useState12[0],setIsStrict=_useState12[1];var _useState13=useState(DEFAULT_SLIPPAGE_PERCENT),_useState14=_slicedToArray(_useState13,2),slippage=_useState14[0],setSlippage=_useState14[1];var _useState15=useState(null),_useState16=_slicedToArray(_useState15,2),fairOverride=_useState16[0],setFairOverride=_useState16[1];var fair=_useSwapFair(fromMint,toMint,fairOverride);var referral=props.referral;assert.ok(slippage>=0);useEffect(function(){if(!fair){return;}setFromAmount(fromAmount);},[fair]);var swapToFromMints=function swapToFromMints(){var oldFrom=fromMint;var oldTo=toMint;var oldToAmount=toAmount;_setFromAmount(oldToAmount);setFromMint(oldTo);setToMint(oldFrom);};var setFromAmount=function setFromAmount(amount){if(fair===undefined){_setFromAmount(0);_setToAmount(0);return;}_setFromAmount(amount);_setToAmount(FEE_MULTIPLIER*(amount/fair));};var setToAmount=function setToAmount(amount){if(fair===undefined){_setFromAmount(0);_setToAmount(0);return;}_setToAmount(amount);_setFromAmount(amount*fair/FEE_MULTIPLIER);};return/*#__PURE__*/_jsx(_SwapContext.Provider,{value:{fromMint:fromMint,setFromMint:setFromMint,toMint:toMint,setToMint:setToMint,fromAmount:fromAmount,setFromAmount:setFromAmount,toAmount:toAmount,setToAmount:setToAmount,swapToFromMints:swapToFromMints,slippage:slippage,setSlippage:setSlippage,fairOverride:fairOverride,setFairOverride:setFairOverride,isClosingNewAccounts:isClosingNewAccounts,isStrict:isStrict,setIsStrict:setIsStrict,setIsClosingNewAccounts:setIsClosingNewAccounts,referral:referral},children:props.children});}export function useSwapContext(){var ctx=useContext(_SwapContext);if(ctx===null){throw new Error(\"Context not available\");}return ctx;}export function useSwapFair(){var _useSwapContext=useSwapContext(),fairOverride=_useSwapContext.fairOverride,fromMint=_useSwapContext.fromMint,toMint=_useSwapContext.toMint;return _useSwapFair(fromMint,toMint,fairOverride);}function _useSwapFair(fromMint,toMint,fairOverride){var fairRoute=useFairRoute(fromMint,toMint);var fair=fairOverride===null?fairRoute:fairOverride;return fair;}// Returns true if the user can swap with the current context.\nexport function useCanSwap(){var _wormholeMap$get,_wormholeMap$get$tags,_solletMap$get,_solletMap$get$tags;var _useSwapContext2=useSwapContext(),fromMint=_useSwapContext2.fromMint,toMint=_useSwapContext2.toMint,fromAmount=_useSwapContext2.fromAmount,toAmount=_useSwapContext2.toAmount;var _useDexContext=useDexContext(),swapClient=_useDexContext.swapClient;var _useTokenListContext=useTokenListContext(),wormholeMap=_useTokenListContext.wormholeMap,solletMap=_useTokenListContext.solletMap;var fromWallet=useOwnedTokenAccount(fromMint);var fair=useSwapFair();var route=useRouteVerbose(fromMint,toMint);if(route===null){return false;}return(// From wallet exists.\nfromWallet!==undefined&&fromWallet!==null&&// Fair price is defined.\nfair!==undefined&&fair>0&&// Mints are distinct.\nfromMint.equals(toMint)===false&&// Wallet is connected.\nswapClient.program.provider.wallet.publicKey!==null&&// Trade amounts greater than zero.\nfromAmount>0&&toAmount>0&&// Trade route exists.\nroute!==null&&(route.kind!==\"wormhole-native\"||((_wormholeMap$get=wormholeMap.get(fromMint.toString()))===null||_wormholeMap$get===void 0?void 0:(_wormholeMap$get$tags=_wormholeMap$get.tags)===null||_wormholeMap$get$tags===void 0?void 0:_wormholeMap$get$tags.includes(SPL_REGISTRY_WORM_TAG))!==undefined)&&(route.kind!==\"wormhole-sollet\"||((_solletMap$get=solletMap.get(fromMint.toString()))===null||_solletMap$get===void 0?void 0:(_solletMap$get$tags=_solletMap$get.tags)===null||_solletMap$get$tags===void 0?void 0:_solletMap$get$tags.includes(SPL_REGISTRY_SOLLET_TAG))!==undefined));}export function useReferral(fromMarket){var _useSwapContext3=useSwapContext(),referral=_useSwapContext3.referral;var asyncReferral=useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(referral){_context.next=2;break;}return _context.abrupt(\"return\",undefined);case 2:if(fromMarket){_context.next=4;break;}return _context.abrupt(\"return\",undefined);case 4:if(!(!fromMarket.quoteMintAddress.equals(USDC_MINT)&&!fromMarket.quoteMintAddress.equals(USDT_MINT))){_context.next=6;break;}return _context.abrupt(\"return\",undefined);case 6:return _context.abrupt(\"return\",Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID,TOKEN_PROGRAM_ID,fromMarket.quoteMintAddress,referral));case 7:case\"end\":return _context.stop();}}},_callee);})),[fromMarket]);if(!asyncReferral.result){return undefined;}return asyncReferral.result;}","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Swap.tsx"],"names":["assert","React","useContext","useState","useEffect","useAsync","Token","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","USDC_MINT","USDT_MINT","TEZ_MINT","QUP_MINT","useFairRoute","useRouteVerbose","useDexContext","FEE_MULTIPLIER","useTokenListContext","SPL_REGISTRY_SOLLET_TAG","SPL_REGISTRY_WORM_TAG","useOwnedTokenAccount","DEFAULT_SLIPPAGE_PERCENT","_SwapContext","createContext","SwapContextProvider","props","fromMint","setFromMint","toMint","setToMint","fromAmount","_setFromAmount","toAmount","_setToAmount","isClosingNewAccounts","setIsClosingNewAccounts","isStrict","setIsStrict","slippage","setSlippage","fairOverride","setFairOverride","fair","_useSwapFair","referral","ok","setFromAmount","swapToFromMints","oldFrom","oldTo","oldToAmount","amount","undefined","setToAmount","children","useSwapContext","ctx","Error","useSwapFair","fairRoute","useCanSwap","swapClient","wormholeMap","solletMap","fromWallet","route","equals","program","provider","wallet","publicKey","kind","get","toString","tags","includes","useReferral","fromMarket","asyncReferral","quoteMintAddress","getAssociatedTokenAddress","result"],"mappings":"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","sourcesContent":["import * as assert from \"assert\";\nimport React, { useContext, useState, useEffect } from \"react\";\nimport { useAsync } from \"react-async-hook\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport {\n  Token,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Market } from \"@project-serum/serum\";\nimport { SRM_MINT, USDC_MINT, USDT_MINT, TEZ_MINT, QUP_MINT } from \"../utils/pubkeys\";\nimport {\n  useFairRoute,\n  useRouteVerbose,\n  useDexContext,\n  FEE_MULTIPLIER,\n} from \"./Dex\";\nimport {\n  useTokenListContext,\n  SPL_REGISTRY_SOLLET_TAG,\n  SPL_REGISTRY_WORM_TAG,\n} from \"./TokenList\";\nimport { useOwnedTokenAccount } from \"../context/Token\";\n\nconst DEFAULT_SLIPPAGE_PERCENT = 0.5;\n\nexport type SwapContext = {\n  // Mint being traded from. The user must own these tokens.\n  fromMint: PublicKey;\n  setFromMint: (m: PublicKey) => void;\n\n  // Mint being traded to. The user will receive these tokens after the swap.\n  toMint: PublicKey;\n  setToMint: (m: PublicKey) => void;\n\n  // Amount used for the swap.\n  fromAmount: number;\n  setFromAmount: (a: number) => void;\n\n  // *Expected* amount received from the swap.\n  toAmount: number;\n  setToAmount: (a: number) => void;\n\n  // Function to flip what we consider to be the \"to\" and \"from\" mints.\n  swapToFromMints: () => void;\n\n  // The amount (in units of percent) a swap can be off from the estimate\n  // shown to the user.\n  slippage: number;\n  setSlippage: (n: number) => void;\n\n  // Null if the user is using fairs directly from DEX prices.\n  // Otherwise, a user specified override for the price to use when calculating\n  // swap amounts.\n  fairOverride: number | null;\n  setFairOverride: (n: number | null) => void;\n\n  // The referral *owner* address. Associated token accounts must be created,\n  // first, for this to be used.\n  referral?: PublicKey;\n\n  // True if all newly created market accounts should be closed in the\n  // same user flow (ideally in the same transaction).\n  isClosingNewAccounts: boolean;\n\n  // True if the swap exchange rate should be a function of nothing but the\n  // from and to tokens, ignoring any quote tokens that may have been\n  // accumulated by performing the swap.\n  //\n  // Always false (for now).\n  isStrict: boolean;\n  setIsStrict: (isStrict: boolean) => void;\n\n  setIsClosingNewAccounts: (b: boolean) => void;\n};\nconst _SwapContext = React.createContext<null | SwapContext>(null);\n\nexport function SwapContextProvider(props: any) {\n  const [fromMint, setFromMint] = useState(props.fromMint ?? TEZ_MINT);\n  const [toMint, setToMint] = useState(props.toMint ?? QUP_MINT);\n  const [fromAmount, _setFromAmount] = useState(props.fromAmount ?? 0);\n  const [toAmount, _setToAmount] = useState(props.toAmount ?? 0);\n  const [isClosingNewAccounts, setIsClosingNewAccounts] = useState(false);\n  const [isStrict, setIsStrict] = useState(false);\n  const [slippage, setSlippage] = useState(DEFAULT_SLIPPAGE_PERCENT);\n  const [fairOverride, setFairOverride] = useState<number | null>(null);\n  const fair = _useSwapFair(fromMint, toMint, fairOverride);\n  const referral = props.referral;\n\n  assert.ok(slippage >= 0);\n\n  useEffect(() => {\n    if (!fair) {\n      return;\n    }\n    setFromAmount(fromAmount);\n  }, [fair]);\n\n  const swapToFromMints = () => {\n    const oldFrom = fromMint;\n    const oldTo = toMint;\n    const oldToAmount = toAmount;\n    _setFromAmount(oldToAmount);\n    setFromMint(oldTo);\n    setToMint(oldFrom);\n  };\n\n  const setFromAmount = (amount: number) => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n      _setToAmount(0);\n      return;\n    }\n    _setFromAmount(amount);\n    _setToAmount(FEE_MULTIPLIER * (amount / fair));\n  };\n\n  const setToAmount = (amount: number) => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n      _setToAmount(0);\n      return;\n    }\n    _setToAmount(amount);\n    _setFromAmount((amount * fair) / FEE_MULTIPLIER);\n  };\n\n  return (\n    <_SwapContext.Provider\n      value={{\n        fromMint,\n        setFromMint,\n        toMint,\n        setToMint,\n        fromAmount,\n        setFromAmount,\n        toAmount,\n        setToAmount,\n        swapToFromMints,\n        slippage,\n        setSlippage,\n        fairOverride,\n        setFairOverride,\n        isClosingNewAccounts,\n        isStrict,\n        setIsStrict,\n        setIsClosingNewAccounts,\n        referral,\n      }}\n    >\n      {props.children}\n    </_SwapContext.Provider>\n  );\n}\n\nexport function useSwapContext(): SwapContext {\n  const ctx = useContext(_SwapContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useSwapFair(): number | undefined {\n  const { fairOverride, fromMint, toMint } = useSwapContext();\n  return _useSwapFair(fromMint, toMint, fairOverride);\n}\n\nfunction _useSwapFair(\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  fairOverride: number | null\n): number | undefined {\n  const fairRoute = useFairRoute(fromMint, toMint);\n  const fair = fairOverride === null ? fairRoute : fairOverride;\n  return fair;\n}\n\n// Returns true if the user can swap with the current context.\nexport function useCanSwap(): boolean {\n  const { fromMint, toMint, fromAmount, toAmount } = useSwapContext();\n  const { swapClient } = useDexContext();\n  const { wormholeMap, solletMap } = useTokenListContext();\n  const fromWallet = useOwnedTokenAccount(fromMint);\n  const fair = useSwapFair();\n  const route = useRouteVerbose(fromMint, toMint);\n  if (route === null) {\n    return false;\n  }\n\n  return (\n    // From wallet exists.\n    fromWallet !== undefined &&\n    fromWallet !== null &&\n    // Fair price is defined.\n    fair !== undefined &&\n    fair > 0 &&\n    // Mints are distinct.\n    fromMint.equals(toMint) === false &&\n    // Wallet is connected.\n    swapClient.program.provider.wallet.publicKey !== null &&\n    // Trade amounts greater than zero.\n    fromAmount > 0 &&\n    toAmount > 0 &&\n    // Trade route exists.\n    route !== null &&\n    // Wormhole <-> native markets must have the wormhole token as the\n    // *from* address since they're one-sided markets.\n    (route.kind !== \"wormhole-native\" ||\n      wormholeMap\n        .get(fromMint.toString())\n        ?.tags?.includes(SPL_REGISTRY_WORM_TAG) !== undefined) &&\n    // Wormhole <-> sollet markets must have the sollet token as the\n    // *from* address since they're one sided markets.\n    (route.kind !== \"wormhole-sollet\" ||\n      solletMap\n        .get(fromMint.toString())\n        ?.tags?.includes(SPL_REGISTRY_SOLLET_TAG) !== undefined)\n  );\n}\n\nexport function useReferral(fromMarket?: Market): PublicKey | undefined {\n  const { referral } = useSwapContext();\n  const asyncReferral = useAsync(async () => {\n    if (!referral) {\n      return undefined;\n    }\n    if (!fromMarket) {\n      return undefined;\n    }\n    if (\n      !fromMarket.quoteMintAddress.equals(USDC_MINT) &&\n      !fromMarket.quoteMintAddress.equals(USDT_MINT)\n    ) {\n      return undefined;\n    }\n\n    return Token.getAssociatedTokenAddress(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      fromMarket.quoteMintAddress,\n      referral\n    );\n  }, [fromMarket]);\n\n  if (!asyncReferral.result) {\n    return undefined;\n  }\n  return asyncReferral.result;\n}\n"]},"metadata":{},"sourceType":"module"}