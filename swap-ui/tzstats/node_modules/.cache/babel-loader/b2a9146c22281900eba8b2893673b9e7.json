{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociatedTokenAddress = exports.getVaultOwnerAndNonce = exports.USDT_PUBKEY = exports.USDC_PUBKEY = exports.SWAP_PID = exports.DEX_PID = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar web3_js_1 = require(\"@solana/web3.js\"); // Serum DEX program id on mainnet-beta.\n\n\nexports.DEX_PID = new web3_js_1.PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'); // Swap program id on mainnet-beta.\n\nexports.SWAP_PID = new web3_js_1.PublicKey('22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD'); // USDC mint on mainnet-beta.\n\nexports.USDC_PUBKEY = new web3_js_1.PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'); // USDT mint on mainnet-beta.\n\nexports.USDT_PUBKEY = new web3_js_1.PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'); // Return the program derived address used by the serum DEX to control token\n// vaults.\n\nfunction getVaultOwnerAndNonce(_x) {\n  return _getVaultOwnerAndNonce.apply(this, arguments);\n}\n\nfunction _getVaultOwnerAndNonce() {\n  _getVaultOwnerAndNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(marketPublicKey) {\n    var dexProgramId,\n        nonce,\n        vaultOwner,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dexProgramId = _args.length > 1 && _args[1] !== undefined ? _args[1] : exports.DEX_PID;\n            nonce = new bn_js_1.default(0);\n\n          case 2:\n            if (!(nonce.toNumber() < 255)) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.prev = 3;\n            _context.next = 6;\n            return web3_js_1.PublicKey.createProgramAddress([marketPublicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)], dexProgramId);\n\n          case 6:\n            vaultOwner = _context.sent;\n            return _context.abrupt(\"return\", [vaultOwner, nonce]);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](3);\n            nonce.iaddn(1);\n\n          case 13:\n            _context.next = 2;\n            break;\n\n          case 15:\n            throw new Error('Unable to find nonce');\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 10]]);\n  }));\n  return _getVaultOwnerAndNonce.apply(this, arguments);\n}\n\nexports.getVaultOwnerAndNonce = getVaultOwnerAndNonce; // Returns an associated token address for spl tokens.\n\nfunction getAssociatedTokenAddress(_x2, _x3, _x4, _x5) {\n  return _getAssociatedTokenAddress.apply(this, arguments);\n}\n\nfunction _getAssociatedTokenAddress() {\n  _getAssociatedTokenAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(associatedProgramId, programId, mint, owner) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId);\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent[0]);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getAssociatedTokenAddress.apply(this, arguments);\n}\n\nexports.getAssociatedTokenAddress = getAssociatedTokenAddress;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,iBAAA,CAAA,C,CAEA;;;AACa,OAAA,CAAA,OAAA,GAAU,IAAI,SAAA,CAAA,SAAJ,CACrB,8CADqB,CAAV,C,CAIb;;AACa,OAAA,CAAA,QAAA,GAAW,IAAI,SAAA,CAAA,SAAJ,CACtB,8CADsB,CAAX,C,CAIb;;AACa,OAAA,CAAA,WAAA,GAAc,IAAI,SAAA,CAAA,SAAJ,CACzB,8CADyB,CAAd,C,CAIb;;AACa,OAAA,CAAA,WAAA,GAAc,IAAI,SAAA,CAAA,SAAJ,CACzB,8CADyB,CAAd,C,CAIb;AACA;;SACsB,qB;;;;;oFAAf,iBACL,eADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,YAAA,YAFK,2DAEqB,OAAA,CAAA,OAFrB;AAIC,YAAA,KAJD,GAIS,IAAI,OAAA,CAAA,OAAJ,CAAO,CAAP,CAJT;;AAAA;AAAA,kBAKE,KAAK,CAAC,QAAN,KAAmB,GALrB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mBAOwB,SAAA,CAAA,SAAA,CAAU,oBAAV,CACvB,CAAC,eAAe,CAAC,QAAhB,EAAD,EAA6B,KAAK,CAAC,WAAN,CAAkB,MAAlB,EAA0B,IAA1B,EAAgC,CAAhC,CAA7B,CADuB,EAEvB,YAFuB,CAPxB;;AAAA;AAOK,YAAA,UAPL;AAAA,6CAWM,CAAC,UAAD,EAAa,KAAb,CAXN;;AAAA;AAAA;AAAA;AAaD,YAAA,KAAK,CAAC,KAAN,CAAY,CAAZ;;AAbC;AAAA;AAAA;;AAAA;AAAA,kBAgBC,IAAI,KAAJ,CAAU,sBAAV,CAhBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAAP,OAAA,CAAA,qBAAA,GAAA,qBAAA,C,CAmBA;;SACsB,yB;;;;;wFAAf,kBACL,mBADK,EAEL,SAFK,EAGL,IAHK,EAIL,KAJK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAOG,SAAA,CAAA,SAAA,CAAU,kBAAV,CACJ,CAAC,KAAK,CAAC,QAAN,EAAD,EAAmB,SAAS,CAAC,QAAV,EAAnB,EAAyC,IAAI,CAAC,QAAL,EAAzC,CADI,EAEJ,mBAFI,CAPH;;AAAA;AAAA,6DAWH,CAXG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAAP,OAAA,CAAA,yBAAA,GAAA,yBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAssociatedTokenAddress = exports.getVaultOwnerAndNonce = exports.USDT_PUBKEY = exports.USDC_PUBKEY = exports.SWAP_PID = exports.DEX_PID = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\n// Serum DEX program id on mainnet-beta.\nexports.DEX_PID = new web3_js_1.PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');\n// Swap program id on mainnet-beta.\nexports.SWAP_PID = new web3_js_1.PublicKey('22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD');\n// USDC mint on mainnet-beta.\nexports.USDC_PUBKEY = new web3_js_1.PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');\n// USDT mint on mainnet-beta.\nexports.USDT_PUBKEY = new web3_js_1.PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB');\n// Return the program derived address used by the serum DEX to control token\n// vaults.\nasync function getVaultOwnerAndNonce(marketPublicKey, dexProgramId = exports.DEX_PID) {\n    const nonce = new bn_js_1.default(0);\n    while (nonce.toNumber() < 255) {\n        try {\n            const vaultOwner = await web3_js_1.PublicKey.createProgramAddress([marketPublicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)], dexProgramId);\n            return [vaultOwner, nonce];\n        }\n        catch (e) {\n            nonce.iaddn(1);\n        }\n    }\n    throw new Error('Unable to find nonce');\n}\nexports.getVaultOwnerAndNonce = getVaultOwnerAndNonce;\n// Returns an associated token address for spl tokens.\nasync function getAssociatedTokenAddress(associatedProgramId, programId, mint, owner) {\n    return (await web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];\n}\nexports.getAssociatedTokenAddress = getAssociatedTokenAddress;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}