{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Token.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport React, { useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { BN } from \"@project-serum/anchor\";\nimport { Account } from \"@solana/web3.js\";\nimport { Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { getOwnedAssociatedTokenAccounts, parseTokenAccountData } from \"../utils/tokens\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst _TokenContext = /*#__PURE__*/React.createContext(null);\n\nexport function TokenContextProvider(props) {\n  _s();\n\n  const provider = props.provider;\n  const [, setRefresh] = useState(0); // Fetch all the owned token accounts for the wallet.\n\n  useEffect(() => {\n    if (!provider.wallet.publicKey) {\n      _OWNED_TOKEN_ACCOUNTS_CACHE.length = 0;\n      setRefresh(r => r + 1);\n      return;\n    } // Fetch SPL tokens.\n\n\n    getOwnedAssociatedTokenAccounts(provider.connection, provider.wallet.publicKey).then(accs => {\n      if (accs) {\n        // @ts-ignore\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push(...accs);\n\n        setRefresh(r => r + 1);\n      }\n    }); // Fetch SOL balance.\n\n    provider.connection.getAccountInfo(provider.wallet.publicKey).then(acc => {\n      if (acc) {\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push({\n          publicKey: provider.wallet.publicKey,\n          // @ts-ignore\n          account: {\n            amount: new BN(acc.lamports),\n            mint: SOL_MINT\n          }\n        });\n\n        setRefresh(r => r + 1);\n      }\n    });\n  }, [provider.wallet.publicKey, provider.connection]);\n  return /*#__PURE__*/_jsxDEV(_TokenContext.Provider, {\n    value: {\n      provider\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 64,\n    columnNumber: 5\n  }, this);\n}\n\n_s(TokenContextProvider, \"SENTX22wnP5IY7t1CWMHdefwhAs=\");\n\n_c = TokenContextProvider;\n\nfunction useTokenContext() {// const ctx = useContext(_TokenContext);\n  // if (ctx === null) {\n  //   throw new Error(\"Context not available\");\n  // }\n  // return ctx;\n} // Null => none exists.\n// Undefined => loading.\n\n\nexport function useOwnedTokenAccount(mint) {\n  _s2();\n\n  // const { provider } = useTokenContext();\n  const [, setRefresh] = useState(0);\n\n  const tokenAccounts = _OWNED_TOKEN_ACCOUNTS_CACHE.filter(account => mint && account.account.mint.equals(mint)); // Take the account with the most tokens in it.\n\n\n  tokenAccounts.sort((a, b) => a.account.amount > b.account.amount ? -1 : a.account.amount < b.account.amount ? 1 : 0);\n  let tokenAccount = tokenAccounts[0];\n  const isSol = mint === null || mint === void 0 ? void 0 : mint.equals(SOL_MINT); // Stream updates when the balance changes.\n\n  useEffect(() => {\n    let listener; // SOL is special cased since it's not an SPL token.\n\n    if (tokenAccount && isSol) {// listener = provider.connection.onAccountChange(\n      //   provider.wallet.publicKey,\n      //   (info: { lamports: number }) => {\n      //     const token = {\n      //       amount: new BN(info.lamports),\n      //       mint: SOL_MINT,\n      //     } as TokenAccount;\n      //     if (token.amount !== tokenAccount.account.amount) {\n      //       const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n      //       assert.ok(index >= 0);\n      //       _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n      //       setRefresh((r) => r + 1);\n      //     }\n      //   }\n      // );\n    } // SPL tokens.\n    else if (tokenAccount) {\n      listener = provider.connection.onAccountChange(tokenAccount.publicKey, info => {\n        if (info.data.length !== 0) {\n          try {\n            const token = parseTokenAccountData(info.data);\n\n            if (token.amount !== tokenAccount.account.amount) {\n              const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n\n              assert.ok(index >= 0);\n              _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n              setRefresh(r => r + 1);\n            }\n          } catch (error) {\n            console.log(\"Failed to decode token AccountInfo\");\n          }\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [provider.connection, tokenAccount]);\n\n  if (mint === undefined) {\n    return undefined;\n  }\n\n  if (!isSol && tokenAccounts.length === 0) {\n    return null;\n  }\n\n  return tokenAccount;\n}\n\n_s2(useOwnedTokenAccount, \"SENTX22wnP5IY7t1CWMHdefwhAs=\");\n\nexport function useMint(mint) {\n  _s3();\n\n  // const { provider } = useTokenContext();\n  // Lazy load the mint account if needeed.\n  const asyncMintInfo = useAsync(async () => {\n    if (!mint) {\n      return undefined;\n    }\n\n    if (_MINT_CACHE.get(mint.toString())) {\n      return _MINT_CACHE.get(mint.toString());\n    }\n\n    const mintClient = new Token(provider.connection, mint, TOKEN_PROGRAM_ID, new Account());\n    const mintInfo = mintClient.getMintInfo();\n\n    _MINT_CACHE.set(mint.toString(), mintInfo);\n\n    return mintInfo;\n  }, [provider.connection, mint]);\n\n  if (asyncMintInfo.result) {\n    return asyncMintInfo.result;\n  }\n\n  return undefined;\n}\n\n_s3(useMint, \"d8XbK7JMShdcPzQooERsF9RuV2Y=\", false, function () {\n  return [useAsync];\n});\n\nexport function setMintCache(pk, account) {\n  _MINT_CACHE.set(pk.toString(), new Promise(resolve => resolve(account)));\n} // Cache storing all token accounts for the connected wallet provider.\n\nconst _OWNED_TOKEN_ACCOUNTS_CACHE = []; // Cache storing all previously fetched mint infos.\n// @ts-ignore\n\nconst _MINT_CACHE = new Map([[SOL_MINT.toString(), {\n  decimals: 9\n}]]);\n\nvar _c;\n\n$RefreshReg$(_c, \"TokenContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Token.tsx"],"names":["React","useState","useEffect","assert","useAsync","BN","Account","Token","TOKEN_PROGRAM_ID","getOwnedAssociatedTokenAccounts","parseTokenAccountData","SOL_MINT","_TokenContext","createContext","TokenContextProvider","props","provider","setRefresh","wallet","publicKey","_OWNED_TOKEN_ACCOUNTS_CACHE","length","r","connection","then","accs","push","getAccountInfo","acc","account","amount","lamports","mint","children","useTokenContext","useOwnedTokenAccount","tokenAccounts","filter","equals","sort","a","b","tokenAccount","isSol","listener","onAccountChange","info","data","token","index","indexOf","ok","error","console","log","removeAccountChangeListener","undefined","useMint","asyncMintInfo","_MINT_CACHE","get","toString","mintClient","mintInfo","getMintInfo","set","result","setMintCache","pk","Promise","resolve","Map","decimals"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { Provider, BN } from \"@project-serum/anchor\";\nimport { PublicKey, Account } from \"@solana/web3.js\";\nimport {\n  MintInfo,\n  AccountInfo as TokenAccount,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport {\n  getOwnedAssociatedTokenAccounts,\n  parseTokenAccountData,\n} from \"../utils/tokens\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\n\nexport type TokenContext = {\n  provider: Provider;\n};\nconst _TokenContext = React.createContext<TokenContext | null>(null);\n\nexport function TokenContextProvider(props: any) {\n  const provider = props.provider;\n  const [, setRefresh] = useState(0);\n\n  // Fetch all the owned token accounts for the wallet.\n  useEffect(() => {\n    if (!provider.wallet.publicKey) {\n      _OWNED_TOKEN_ACCOUNTS_CACHE.length = 0;\n      setRefresh((r) => r + 1);\n      return;\n    }\n    // Fetch SPL tokens.\n    getOwnedAssociatedTokenAccounts(\n      provider.connection,\n      provider.wallet.publicKey\n    ).then((accs) => {\n      if (accs) {\n        // @ts-ignore\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push(...accs);\n        setRefresh((r) => r + 1);\n      }\n    });\n    // Fetch SOL balance.\n    provider.connection\n      .getAccountInfo(provider.wallet.publicKey)\n      .then((acc: { lamports: number }) => {\n        if (acc) {\n          _OWNED_TOKEN_ACCOUNTS_CACHE.push({\n            publicKey: provider.wallet.publicKey,\n            // @ts-ignore\n            account: {\n              amount: new BN(acc.lamports),\n              mint: SOL_MINT,\n            },\n          });\n          setRefresh((r) => r + 1);\n        }\n      });\n  }, [provider.wallet.publicKey, provider.connection]);\n\n  return (\n    <_TokenContext.Provider\n      value={{\n        provider,\n      }}\n    >\n      {props.children}\n    </_TokenContext.Provider>\n  );\n}\n\nfunction useTokenContext() {\n  // const ctx = useContext(_TokenContext);\n  // if (ctx === null) {\n  //   throw new Error(\"Context not available\");\n  // }\n  // return ctx;\n}\n\n// Null => none exists.\n// Undefined => loading.\nexport function useOwnedTokenAccount(\n  mint?: PublicKey\n): { publicKey: PublicKey; account: TokenAccount } | null | undefined {\n  // const { provider } = useTokenContext();\n  const [, setRefresh] = useState(0);\n  const tokenAccounts = _OWNED_TOKEN_ACCOUNTS_CACHE.filter(\n    (account) => mint && account.account.mint.equals(mint)\n  );\n\n  // Take the account with the most tokens in it.\n  tokenAccounts.sort((a, b) =>\n    a.account.amount > b.account.amount\n      ? -1\n      : a.account.amount < b.account.amount\n      ? 1\n      : 0\n  );\n\n  let tokenAccount = tokenAccounts[0];\n  const isSol = mint?.equals(SOL_MINT);\n\n  // Stream updates when the balance changes.\n  useEffect(() => {\n    let listener: number;\n    // SOL is special cased since it's not an SPL token.\n    if (tokenAccount && isSol) {\n      // listener = provider.connection.onAccountChange(\n      //   provider.wallet.publicKey,\n      //   (info: { lamports: number }) => {\n      //     const token = {\n      //       amount: new BN(info.lamports),\n      //       mint: SOL_MINT,\n      //     } as TokenAccount;\n      //     if (token.amount !== tokenAccount.account.amount) {\n      //       const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n      //       assert.ok(index >= 0);\n      //       _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n      //       setRefresh((r) => r + 1);\n      //     }\n      //   }\n      // );\n    }\n    // SPL tokens.\n    else if (tokenAccount) {\n      listener = provider.connection.onAccountChange(\n        tokenAccount.publicKey,\n        (info) => {\n          if (info.data.length !== 0) {\n            try {\n              const token = parseTokenAccountData(info.data);\n              if (token.amount !== tokenAccount.account.amount) {\n                const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n                assert.ok(index >= 0);\n                _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n                setRefresh((r) => r + 1);\n              }\n            } catch (error) {\n              console.log(\"Failed to decode token AccountInfo\");\n            }\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [provider.connection, tokenAccount]);\n\n  if (mint === undefined) {\n    return undefined;\n  }\n\n  if (!isSol && tokenAccounts.length === 0) {\n    return null;\n  }\n\n  return tokenAccount;\n}\n\nexport function useMint(mint?: PublicKey): MintInfo | undefined | null {\n  // const { provider } = useTokenContext();\n  // Lazy load the mint account if needeed.\n  const asyncMintInfo = useAsync(async () => {\n    if (!mint) {\n      return undefined;\n    }\n    if (_MINT_CACHE.get(mint.toString())) {\n      return _MINT_CACHE.get(mint.toString());\n    }\n\n    const mintClient = new Token(\n      provider.connection,\n      mint,\n      TOKEN_PROGRAM_ID,\n      new Account()\n    );\n    const mintInfo = mintClient.getMintInfo();\n    _MINT_CACHE.set(mint.toString(), mintInfo);\n    return mintInfo;\n  }, [provider.connection, mint]);\n\n  if (asyncMintInfo.result) {\n    return asyncMintInfo.result;\n  }\n  return undefined;\n}\n\nexport function setMintCache(pk: PublicKey, account: MintInfo) {\n  _MINT_CACHE.set(pk.toString(), new Promise((resolve) => resolve(account)));\n}\n\n// Cache storing all token accounts for the connected wallet provider.\nconst _OWNED_TOKEN_ACCOUNTS_CACHE: Array<{\n  publicKey: PublicKey;\n  account: TokenAccount;\n}> = [];\n\n// Cache storing all previously fetched mint infos.\n// @ts-ignore\nconst _MINT_CACHE = new Map<string, Promise<MintInfo>>([\n  [SOL_MINT.toString(), { decimals: 9 }],\n]);\n"]},"metadata":{},"sourceType":"module"}