{"ast":null,"code":"import _regeneratorRuntime from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _toConsumableArray from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useContext,useState,useEffect}from\"react\";import*as assert from\"assert\";import{useAsync}from\"react-async-hook\";import{BN}from\"@project-serum/anchor\";import{Account}from\"@solana/web3.js\";import{Token,TOKEN_PROGRAM_ID}from\"@solana/spl-token\";import{getOwnedAssociatedTokenAccounts,parseTokenAccountData}from\"../utils/tokens\";import{SOL_MINT}from\"../utils/pubkeys\";import{jsx as _jsx}from\"react/jsx-runtime\";var _TokenContext=/*#__PURE__*/React.createContext(null);export function TokenContextProvider(props){var provider=props.provider;var _useState=useState(0),_useState2=_slicedToArray(_useState,2),setRefresh=_useState2[1];// Fetch all the owned token accounts for the wallet.\nuseEffect(function(){if(!provider.wallet.publicKey){_OWNED_TOKEN_ACCOUNTS_CACHE.length=0;setRefresh(function(r){return r+1;});return;}// Fetch SPL tokens.\ngetOwnedAssociatedTokenAccounts(provider.connection,provider.wallet.publicKey).then(function(accs){if(accs){// @ts-ignore\n_OWNED_TOKEN_ACCOUNTS_CACHE.push.apply(_OWNED_TOKEN_ACCOUNTS_CACHE,_toConsumableArray(accs));setRefresh(function(r){return r+1;});}});// Fetch SOL balance.\nprovider.connection.getAccountInfo(provider.wallet.publicKey).then(function(acc){if(acc){_OWNED_TOKEN_ACCOUNTS_CACHE.push({publicKey:provider.wallet.publicKey,// @ts-ignore\naccount:{amount:new BN(acc.lamports),mint:SOL_MINT}});setRefresh(function(r){return r+1;});}});},[provider.wallet.publicKey,provider.connection]);return/*#__PURE__*/_jsx(_TokenContext.Provider,{value:{provider:provider},children:props.children});}function useTokenContext(){var ctx=useContext(_TokenContext);if(ctx===null){throw new Error(\"Context not available\");}return ctx;}// Null => none exists.\n// Undefined => loading.\nexport function useOwnedTokenAccount(mint){var _useTokenContext=useTokenContext(),provider=_useTokenContext.provider;var _useState3=useState(0),_useState4=_slicedToArray(_useState3,2),setRefresh=_useState4[1];var tokenAccounts=_OWNED_TOKEN_ACCOUNTS_CACHE.filter(function(account){return mint&&account.account.mint.equals(mint);});// Take the account with the most tokens in it.\ntokenAccounts.sort(function(a,b){return a.account.amount>b.account.amount?-1:a.account.amount<b.account.amount?1:0;});var tokenAccount=tokenAccounts[0];var isSol=mint===null||mint===void 0?void 0:mint.equals(SOL_MINT);// Stream updates when the balance changes.\nuseEffect(function(){var listener;// SOL is special cased since it's not an SPL token.\nif(tokenAccount&&isSol){listener=provider.connection.onAccountChange(provider.wallet.publicKey,function(info){var token={amount:new BN(info.lamports),mint:SOL_MINT};if(token.amount!==tokenAccount.account.amount){var index=_OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);assert.ok(index>=0);_OWNED_TOKEN_ACCOUNTS_CACHE[index].account=token;setRefresh(function(r){return r+1;});}});}// SPL tokens.\nelse if(tokenAccount){listener=provider.connection.onAccountChange(tokenAccount.publicKey,function(info){if(info.data.length!==0){try{var token=parseTokenAccountData(info.data);if(token.amount!==tokenAccount.account.amount){var index=_OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);assert.ok(index>=0);_OWNED_TOKEN_ACCOUNTS_CACHE[index].account=token;setRefresh(function(r){return r+1;});}}catch(error){console.log(\"Failed to decode token AccountInfo\");}}});}return function(){if(listener){provider.connection.removeAccountChangeListener(listener);}};},[provider.connection,tokenAccount]);if(mint===undefined){return undefined;}if(!isSol&&tokenAccounts.length===0){return null;}return tokenAccount;}export function useMint(mint){var _useTokenContext2=useTokenContext(),provider=_useTokenContext2.provider;// Lazy load the mint account if needeed.\nvar asyncMintInfo=useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var mintClient,mintInfo;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(mint){_context.next=2;break;}return _context.abrupt(\"return\",undefined);case 2:if(!_MINT_CACHE.get(mint.toString())){_context.next=4;break;}return _context.abrupt(\"return\",_MINT_CACHE.get(mint.toString()));case 4:mintClient=new Token(provider.connection,mint,TOKEN_PROGRAM_ID,new Account());mintInfo=mintClient.getMintInfo();_MINT_CACHE.set(mint.toString(),mintInfo);return _context.abrupt(\"return\",mintInfo);case 8:case\"end\":return _context.stop();}}},_callee);})),[provider.connection,mint]);if(asyncMintInfo.result){return asyncMintInfo.result;}return undefined;}export function setMintCache(pk,account){_MINT_CACHE.set(pk.toString(),new Promise(function(resolve){return resolve(account);}));}// Cache storing all token accounts for the connected wallet provider.\nvar _OWNED_TOKEN_ACCOUNTS_CACHE=[];// Cache storing all previously fetched mint infos.\n// @ts-ignore\nvar _MINT_CACHE=new Map([[SOL_MINT.toString(),{decimals:9}]]);","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Token.tsx"],"names":["React","useContext","useState","useEffect","assert","useAsync","BN","Account","Token","TOKEN_PROGRAM_ID","getOwnedAssociatedTokenAccounts","parseTokenAccountData","SOL_MINT","_TokenContext","createContext","TokenContextProvider","props","provider","setRefresh","wallet","publicKey","_OWNED_TOKEN_ACCOUNTS_CACHE","length","r","connection","then","accs","push","getAccountInfo","acc","account","amount","lamports","mint","children","useTokenContext","ctx","Error","useOwnedTokenAccount","tokenAccounts","filter","equals","sort","a","b","tokenAccount","isSol","listener","onAccountChange","info","token","index","indexOf","ok","data","error","console","log","removeAccountChangeListener","undefined","useMint","asyncMintInfo","_MINT_CACHE","get","toString","mintClient","mintInfo","getMintInfo","set","result","setMintCache","pk","Promise","resolve","Map","decimals"],"mappings":"ypBAAA,MAAOA,CAAAA,KAAP,EAAgBC,UAAhB,CAA4BC,QAA5B,CAAsCC,SAAtC,KAAuD,OAAvD,CACA,MAAO,GAAKC,CAAAA,MAAZ,KAAwB,QAAxB,CACA,OAASC,QAAT,KAAyB,kBAAzB,CACA,OAAmBC,EAAnB,KAA6B,uBAA7B,CACA,OAAoBC,OAApB,KAAmC,iBAAnC,CACA,OAGEC,KAHF,CAIEC,gBAJF,KAKO,mBALP,CAMA,OACEC,+BADF,CAEEC,qBAFF,KAGO,iBAHP,CAIA,OAASC,QAAT,KAAyB,kBAAzB,C,2CAKA,GAAMC,CAAAA,aAAa,cAAGb,KAAK,CAACc,aAAN,CAAyC,IAAzC,CAAtB,CAEA,MAAO,SAASC,CAAAA,oBAAT,CAA8BC,KAA9B,CAA0C,CAC/C,GAAMC,CAAAA,QAAQ,CAAGD,KAAK,CAACC,QAAvB,CACA,cAAuBf,QAAQ,CAAC,CAAD,CAA/B,wCAASgB,UAAT,eAEA;AACAf,SAAS,CAAC,UAAM,CACd,GAAI,CAACc,QAAQ,CAACE,MAAT,CAAgBC,SAArB,CAAgC,CAC9BC,2BAA2B,CAACC,MAA5B,CAAqC,CAArC,CACAJ,UAAU,CAAC,SAACK,CAAD,QAAOA,CAAAA,CAAC,CAAG,CAAX,EAAD,CAAV,CACA,OACD,CACD;AACAb,+BAA+B,CAC7BO,QAAQ,CAACO,UADoB,CAE7BP,QAAQ,CAACE,MAAT,CAAgBC,SAFa,CAA/B,CAGEK,IAHF,CAGO,SAACC,IAAD,CAAU,CACf,GAAIA,IAAJ,CAAU,CACR;AACAL,2BAA2B,CAACM,IAA5B,OAAAN,2BAA2B,oBAASK,IAAT,EAA3B,CACAR,UAAU,CAAC,SAACK,CAAD,QAAOA,CAAAA,CAAC,CAAG,CAAX,EAAD,CAAV,CACD,CACF,CATD,EAUA;AACAN,QAAQ,CAACO,UAAT,CACGI,cADH,CACkBX,QAAQ,CAACE,MAAT,CAAgBC,SADlC,EAEGK,IAFH,CAEQ,SAACI,GAAD,CAA+B,CACnC,GAAIA,GAAJ,CAAS,CACPR,2BAA2B,CAACM,IAA5B,CAAiC,CAC/BP,SAAS,CAAEH,QAAQ,CAACE,MAAT,CAAgBC,SADI,CAE/B;AACAU,OAAO,CAAE,CACPC,MAAM,CAAE,GAAIzB,CAAAA,EAAJ,CAAOuB,GAAG,CAACG,QAAX,CADD,CAEPC,IAAI,CAAErB,QAFC,CAHsB,CAAjC,EAQAM,UAAU,CAAC,SAACK,CAAD,QAAOA,CAAAA,CAAC,CAAG,CAAX,EAAD,CAAV,CACD,CACF,CAdH,EAeD,CAjCQ,CAiCN,CAACN,QAAQ,CAACE,MAAT,CAAgBC,SAAjB,CAA4BH,QAAQ,CAACO,UAArC,CAjCM,CAAT,CAmCA,mBACE,KAAC,aAAD,CAAe,QAAf,EACE,KAAK,CAAE,CACLP,QAAQ,CAARA,QADK,CADT,UAKGD,KAAK,CAACkB,QALT,EADF,CASD,CAED,QAASC,CAAAA,eAAT,EAA2B,CACzB,GAAMC,CAAAA,GAAG,CAAGnC,UAAU,CAACY,aAAD,CAAtB,CACA,GAAIuB,GAAG,GAAK,IAAZ,CAAkB,CAChB,KAAM,IAAIC,CAAAA,KAAJ,CAAU,uBAAV,CAAN,CACD,CACD,MAAOD,CAAAA,GAAP,CACD,CAED;AACA;AACA,MAAO,SAASE,CAAAA,oBAAT,CACLL,IADK,CAE+D,CACpE,qBAAqBE,eAAe,EAApC,CAAQlB,QAAR,kBAAQA,QAAR,CACA,eAAuBf,QAAQ,CAAC,CAAD,CAA/B,yCAASgB,UAAT,eACA,GAAMqB,CAAAA,aAAa,CAAGlB,2BAA2B,CAACmB,MAA5B,CACpB,SAACV,OAAD,QAAaG,CAAAA,IAAI,EAAIH,OAAO,CAACA,OAAR,CAAgBG,IAAhB,CAAqBQ,MAArB,CAA4BR,IAA5B,CAArB,EADoB,CAAtB,CAIA;AACAM,aAAa,CAACG,IAAd,CAAmB,SAACC,CAAD,CAAIC,CAAJ,QACjBD,CAAAA,CAAC,CAACb,OAAF,CAAUC,MAAV,CAAmBa,CAAC,CAACd,OAAF,CAAUC,MAA7B,CACI,CAAC,CADL,CAEIY,CAAC,CAACb,OAAF,CAAUC,MAAV,CAAmBa,CAAC,CAACd,OAAF,CAAUC,MAA7B,CACA,CADA,CAEA,CALa,EAAnB,EAQA,GAAIc,CAAAA,YAAY,CAAGN,aAAa,CAAC,CAAD,CAAhC,CACA,GAAMO,CAAAA,KAAK,CAAGb,IAAH,SAAGA,IAAH,iBAAGA,IAAI,CAAEQ,MAAN,CAAa7B,QAAb,CAAd,CAEA;AACAT,SAAS,CAAC,UAAM,CACd,GAAI4C,CAAAA,QAAJ,CACA;AACA,GAAIF,YAAY,EAAIC,KAApB,CAA2B,CACzBC,QAAQ,CAAG9B,QAAQ,CAACO,UAAT,CAAoBwB,eAApB,CACT/B,QAAQ,CAACE,MAAT,CAAgBC,SADP,CAET,SAAC6B,IAAD,CAAgC,CAC9B,GAAMC,CAAAA,KAAK,CAAG,CACZnB,MAAM,CAAE,GAAIzB,CAAAA,EAAJ,CAAO2C,IAAI,CAACjB,QAAZ,CADI,CAEZC,IAAI,CAAErB,QAFM,CAAd,CAIA,GAAIsC,KAAK,CAACnB,MAAN,GAAiBc,YAAY,CAACf,OAAb,CAAqBC,MAA1C,CAAkD,CAChD,GAAMoB,CAAAA,KAAK,CAAG9B,2BAA2B,CAAC+B,OAA5B,CAAoCP,YAApC,CAAd,CACAzC,MAAM,CAACiD,EAAP,CAAUF,KAAK,EAAI,CAAnB,EACA9B,2BAA2B,CAAC8B,KAAD,CAA3B,CAAmCrB,OAAnC,CAA6CoB,KAA7C,CACAhC,UAAU,CAAC,SAACK,CAAD,QAAOA,CAAAA,CAAC,CAAG,CAAX,EAAD,CAAV,CACD,CACF,CAbQ,CAAX,CAeD,CACD;AAjBA,IAkBK,IAAIsB,YAAJ,CAAkB,CACrBE,QAAQ,CAAG9B,QAAQ,CAACO,UAAT,CAAoBwB,eAApB,CACTH,YAAY,CAACzB,SADJ,CAET,SAAC6B,IAAD,CAAU,CACR,GAAIA,IAAI,CAACK,IAAL,CAAUhC,MAAV,GAAqB,CAAzB,CAA4B,CAC1B,GAAI,CACF,GAAM4B,CAAAA,KAAK,CAAGvC,qBAAqB,CAACsC,IAAI,CAACK,IAAN,CAAnC,CACA,GAAIJ,KAAK,CAACnB,MAAN,GAAiBc,YAAY,CAACf,OAAb,CAAqBC,MAA1C,CAAkD,CAChD,GAAMoB,CAAAA,KAAK,CAAG9B,2BAA2B,CAAC+B,OAA5B,CAAoCP,YAApC,CAAd,CACAzC,MAAM,CAACiD,EAAP,CAAUF,KAAK,EAAI,CAAnB,EACA9B,2BAA2B,CAAC8B,KAAD,CAA3B,CAAmCrB,OAAnC,CAA6CoB,KAA7C,CACAhC,UAAU,CAAC,SAACK,CAAD,QAAOA,CAAAA,CAAC,CAAG,CAAX,EAAD,CAAV,CACD,CACF,CAAC,MAAOgC,KAAP,CAAc,CACdC,OAAO,CAACC,GAAR,CAAY,oCAAZ,EACD,CACF,CACF,CAhBQ,CAAX,CAkBD,CACD,MAAO,WAAM,CACX,GAAIV,QAAJ,CAAc,CACZ9B,QAAQ,CAACO,UAAT,CAAoBkC,2BAApB,CAAgDX,QAAhD,EACD,CACF,CAJD,CAKD,CA9CQ,CA8CN,CAAC9B,QAAQ,CAACO,UAAV,CAAsBqB,YAAtB,CA9CM,CAAT,CAgDA,GAAIZ,IAAI,GAAK0B,SAAb,CAAwB,CACtB,MAAOA,CAAAA,SAAP,CACD,CAED,GAAI,CAACb,KAAD,EAAUP,aAAa,CAACjB,MAAd,GAAyB,CAAvC,CAA0C,CACxC,MAAO,KAAP,CACD,CAED,MAAOuB,CAAAA,YAAP,CACD,CAED,MAAO,SAASe,CAAAA,OAAT,CAAiB3B,IAAjB,CAAgE,CACrE,sBAAqBE,eAAe,EAApC,CAAQlB,QAAR,mBAAQA,QAAR,CACA;AACA,GAAM4C,CAAAA,aAAa,CAAGxD,QAAQ,sEAAC,8JACxB4B,IADwB,yDAEpB0B,SAFoB,aAIzBG,WAAW,CAACC,GAAZ,CAAgB9B,IAAI,CAAC+B,QAAL,EAAhB,CAJyB,yDAKpBF,WAAW,CAACC,GAAZ,CAAgB9B,IAAI,CAAC+B,QAAL,EAAhB,CALoB,SAQvBC,UARuB,CAQV,GAAIzD,CAAAA,KAAJ,CACjBS,QAAQ,CAACO,UADQ,CAEjBS,IAFiB,CAGjBxB,gBAHiB,CAIjB,GAAIF,CAAAA,OAAJ,EAJiB,CARU,CAcvB2D,QAduB,CAcZD,UAAU,CAACE,WAAX,EAdY,CAe7BL,WAAW,CAACM,GAAZ,CAAgBnC,IAAI,CAAC+B,QAAL,EAAhB,CAAiCE,QAAjC,EAf6B,gCAgBtBA,QAhBsB,wDAAD,GAiB3B,CAACjD,QAAQ,CAACO,UAAV,CAAsBS,IAAtB,CAjB2B,CAA9B,CAmBA,GAAI4B,aAAa,CAACQ,MAAlB,CAA0B,CACxB,MAAOR,CAAAA,aAAa,CAACQ,MAArB,CACD,CACD,MAAOV,CAAAA,SAAP,CACD,CAED,MAAO,SAASW,CAAAA,YAAT,CAAsBC,EAAtB,CAAqCzC,OAArC,CAAwD,CAC7DgC,WAAW,CAACM,GAAZ,CAAgBG,EAAE,CAACP,QAAH,EAAhB,CAA+B,GAAIQ,CAAAA,OAAJ,CAAY,SAACC,OAAD,QAAaA,CAAAA,OAAO,CAAC3C,OAAD,CAApB,EAAZ,CAA/B,EACD,CAED;AACA,GAAMT,CAAAA,2BAGJ,CAAG,EAHL,CAKA;AACA;AACA,GAAMyC,CAAAA,WAAW,CAAG,GAAIY,CAAAA,GAAJ,CAAmC,CACrD,CAAC9D,QAAQ,CAACoD,QAAT,EAAD,CAAsB,CAAEW,QAAQ,CAAE,CAAZ,CAAtB,CADqD,CAAnC,CAApB","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { Provider, BN } from \"@project-serum/anchor\";\nimport { PublicKey, Account } from \"@solana/web3.js\";\nimport {\n  MintInfo,\n  AccountInfo as TokenAccount,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport {\n  getOwnedAssociatedTokenAccounts,\n  parseTokenAccountData,\n} from \"../utils/tokens\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\n\nexport type TokenContext = {\n  provider: Provider;\n};\nconst _TokenContext = React.createContext<TokenContext | null>(null);\n\nexport function TokenContextProvider(props: any) {\n  const provider = props.provider;\n  const [, setRefresh] = useState(0);\n\n  // Fetch all the owned token accounts for the wallet.\n  useEffect(() => {\n    if (!provider.wallet.publicKey) {\n      _OWNED_TOKEN_ACCOUNTS_CACHE.length = 0;\n      setRefresh((r) => r + 1);\n      return;\n    }\n    // Fetch SPL tokens.\n    getOwnedAssociatedTokenAccounts(\n      provider.connection,\n      provider.wallet.publicKey\n    ).then((accs) => {\n      if (accs) {\n        // @ts-ignore\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push(...accs);\n        setRefresh((r) => r + 1);\n      }\n    });\n    // Fetch SOL balance.\n    provider.connection\n      .getAccountInfo(provider.wallet.publicKey)\n      .then((acc: { lamports: number }) => {\n        if (acc) {\n          _OWNED_TOKEN_ACCOUNTS_CACHE.push({\n            publicKey: provider.wallet.publicKey,\n            // @ts-ignore\n            account: {\n              amount: new BN(acc.lamports),\n              mint: SOL_MINT,\n            },\n          });\n          setRefresh((r) => r + 1);\n        }\n      });\n  }, [provider.wallet.publicKey, provider.connection]);\n\n  return (\n    <_TokenContext.Provider\n      value={{\n        provider,\n      }}\n    >\n      {props.children}\n    </_TokenContext.Provider>\n  );\n}\n\nfunction useTokenContext() {\n  const ctx = useContext(_TokenContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\n// Null => none exists.\n// Undefined => loading.\nexport function useOwnedTokenAccount(\n  mint?: PublicKey\n): { publicKey: PublicKey; account: TokenAccount } | null | undefined {\n  const { provider } = useTokenContext();\n  const [, setRefresh] = useState(0);\n  const tokenAccounts = _OWNED_TOKEN_ACCOUNTS_CACHE.filter(\n    (account) => mint && account.account.mint.equals(mint)\n  );\n\n  // Take the account with the most tokens in it.\n  tokenAccounts.sort((a, b) =>\n    a.account.amount > b.account.amount\n      ? -1\n      : a.account.amount < b.account.amount\n      ? 1\n      : 0\n  );\n\n  let tokenAccount = tokenAccounts[0];\n  const isSol = mint?.equals(SOL_MINT);\n\n  // Stream updates when the balance changes.\n  useEffect(() => {\n    let listener: number;\n    // SOL is special cased since it's not an SPL token.\n    if (tokenAccount && isSol) {\n      listener = provider.connection.onAccountChange(\n        provider.wallet.publicKey,\n        (info: { lamports: number }) => {\n          const token = {\n            amount: new BN(info.lamports),\n            mint: SOL_MINT,\n          } as TokenAccount;\n          if (token.amount !== tokenAccount.account.amount) {\n            const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n            assert.ok(index >= 0);\n            _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    // SPL tokens.\n    else if (tokenAccount) {\n      listener = provider.connection.onAccountChange(\n        tokenAccount.publicKey,\n        (info) => {\n          if (info.data.length !== 0) {\n            try {\n              const token = parseTokenAccountData(info.data);\n              if (token.amount !== tokenAccount.account.amount) {\n                const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n                assert.ok(index >= 0);\n                _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n                setRefresh((r) => r + 1);\n              }\n            } catch (error) {\n              console.log(\"Failed to decode token AccountInfo\");\n            }\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [provider.connection, tokenAccount]);\n\n  if (mint === undefined) {\n    return undefined;\n  }\n\n  if (!isSol && tokenAccounts.length === 0) {\n    return null;\n  }\n\n  return tokenAccount;\n}\n\nexport function useMint(mint?: PublicKey): MintInfo | undefined | null {\n  const { provider } = useTokenContext();\n  // Lazy load the mint account if needeed.\n  const asyncMintInfo = useAsync(async () => {\n    if (!mint) {\n      return undefined;\n    }\n    if (_MINT_CACHE.get(mint.toString())) {\n      return _MINT_CACHE.get(mint.toString());\n    }\n\n    const mintClient = new Token(\n      provider.connection,\n      mint,\n      TOKEN_PROGRAM_ID,\n      new Account()\n    );\n    const mintInfo = mintClient.getMintInfo();\n    _MINT_CACHE.set(mint.toString(), mintInfo);\n    return mintInfo;\n  }, [provider.connection, mint]);\n\n  if (asyncMintInfo.result) {\n    return asyncMintInfo.result;\n  }\n  return undefined;\n}\n\nexport function setMintCache(pk: PublicKey, account: MintInfo) {\n  _MINT_CACHE.set(pk.toString(), new Promise((resolve) => resolve(account)));\n}\n\n// Cache storing all token accounts for the connected wallet provider.\nconst _OWNED_TOKEN_ACCOUNTS_CACHE: Array<{\n  publicKey: PublicKey;\n  account: TokenAccount;\n}> = [];\n\n// Cache storing all previously fetched mint infos.\n// @ts-ignore\nconst _MINT_CACHE = new Map<string, Promise<MintInfo>>([\n  [SOL_MINT.toString(), { decimals: 9 }],\n]);\n"]},"metadata":{},"sourceType":"module"}