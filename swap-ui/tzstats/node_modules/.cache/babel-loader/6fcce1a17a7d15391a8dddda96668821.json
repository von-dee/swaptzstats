{"ast":null,"code":"import _regeneratorRuntime from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useContext,useState,useEffect}from\"react\";import*as assert from\"assert\";import{useAsync}from\"react-async-hook\";import{MintLayout}from\"@solana/spl-token\";import{PublicKey}from\"@solana/web3.js\";import*as anchor from\"@project-serum/anchor\";import{Market,OpenOrders,Orderbook as OrderbookSide}from\"@project-serum/serum\";import{DEX_PID,USDC_MINT,USDT_MINT,SOL_MINT,WRAPPED_SOL_MINT,WORM_USDC_MINT,WORM_USDT_MINT,WORM_USDC_MARKET,WORM_USDT_MARKET,WORM_MARKET_BASE}from\"../utils/pubkeys\";import{useTokenMap,useTokenListContext}from\"./TokenList\";import{fetchSolletInfo,requestWormholeSwapMarketIfNeeded}from\"./Sollet\";import{setMintCache}from\"./Token\";import{jsx as _jsx}from\"react/jsx-runtime\";var BASE_TAKER_FEE_BPS=0.0022;export var FEE_MULTIPLIER=1-BASE_TAKER_FEE_BPS;var _DexContext=/*#__PURE__*/React.createContext(null);export function DexContextProvider(props){var _useState=useState(new Map()),_useState2=_slicedToArray(_useState,2),ooAccounts=_useState2[0],setOoAccounts=_useState2[1];var swapClient=props.swapClient;// Removes the given open orders from the context.\nvar closeOpenOrders=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(openOrder){var _newOoAccounts$get;var newOoAccounts,openOrders;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:newOoAccounts=new Map(ooAccounts);openOrders=(_newOoAccounts$get=newOoAccounts.get(openOrder.market.toString()))===null||_newOoAccounts$get===void 0?void 0:_newOoAccounts$get.filter(function(oo){return!oo.address.equals(openOrder.address);});if(openOrders&&openOrders.length>0){newOoAccounts.set(openOrder.market.toString(),openOrders);}else{newOoAccounts.delete(openOrder.market.toString());}setOoAccounts(newOoAccounts);case 4:case\"end\":return _context.stop();}}},_callee);}));return function closeOpenOrders(_x){return _ref.apply(this,arguments);};}();// Three operations:\n//\n// 1. Fetch all open orders accounts for the connected wallet.\n// 2. Batch fetch all market accounts for those open orders.\n// 3. Batch fetch all mints associated with the markets.\nuseEffect(function(){if(!swapClient.program.provider.wallet.publicKey){setOoAccounts(new Map());return;}OpenOrders.findForOwner(swapClient.program.provider.connection,swapClient.program.provider.wallet.publicKey,DEX_PID).then(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(openOrders){var newOoAccounts,markets,multipleMarkets,marketClients,mintPubkeys,mints,mintInfos;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:newOoAccounts=new Map();markets=new Set();openOrders.forEach(function(oo){markets.add(oo.market.toString());if(newOoAccounts.get(oo.market.toString())){newOoAccounts.get(oo.market.toString()).push(oo);}else{newOoAccounts.set(oo.market.toString(),[oo]);}});if(!(markets.size>100)){_context2.next=5;break;}throw new Error(\"Too many markets. Please file an issue to update this\");case 5:_context2.next=7;return anchor.utils.rpc.getMultipleAccounts(swapClient.program.provider.connection,Array.from(markets.values()).map(function(m){return new PublicKey(m);}));case 7:multipleMarkets=_context2.sent;marketClients=multipleMarkets.map(function(programAccount){return{publicKey:programAccount===null||programAccount===void 0?void 0:programAccount.publicKey,account:new Market(Market.getLayout(DEX_PID).decode(programAccount===null||programAccount===void 0?void 0:programAccount.account.data),-1,// Set below so that we can batch fetch mints.\n-1,// Set below so that we can batch fetch mints.\nswapClient.program.provider.opts,DEX_PID)};});setOoAccounts(newOoAccounts);// Batch fetch all the mints, since we know we'll need them at some\n// point.\nmintPubkeys=Array.from(new Set(marketClients.map(function(m){return[m.account.baseMintAddress.toString(),m.account.quoteMintAddress.toString()];}).flat()).values()).map(function(pk){return new PublicKey(pk);});if(!(mintPubkeys.length>100)){_context2.next=13;break;}throw new Error(\"Too many mints. Please file an issue to update this\");case 13:_context2.next=15;return anchor.utils.rpc.getMultipleAccounts(swapClient.program.provider.connection,mintPubkeys);case 15:mints=_context2.sent;mintInfos=mints.map(function(mint){var mintInfo=MintLayout.decode(mint.account.data);setMintCache(mint.publicKey,mintInfo);return{publicKey:mint.publicKey,mintInfo:mintInfo};});marketClients.forEach(function(m){var baseMintInfo=mintInfos.filter(function(mint){return mint.publicKey.equals(m.account.baseMintAddress);})[0];var quoteMintInfo=mintInfos.filter(function(mint){return mint.publicKey.equals(m.account.quoteMintAddress);})[0];assert.ok(baseMintInfo&&quoteMintInfo);// @ts-ignore\nm.account._baseSplTokenDecimals=baseMintInfo.mintInfo.decimals;// @ts-ignore\nm.account._quoteSplTokenDecimals=quoteMintInfo.mintInfo.decimals;_MARKET_CACHE.set(m.publicKey.toString(),new Promise(function(resolve){return resolve(m.account);}));});case 18:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref2.apply(this,arguments);};}());},[swapClient.program.provider.connection,swapClient.program.provider.wallet.publicKey,swapClient.program.provider.opts]);return/*#__PURE__*/_jsx(_DexContext.Provider,{value:{openOrders:ooAccounts,closeOpenOrders:closeOpenOrders,swapClient:swapClient},children:props.children});}export function useDexContext(){var ctx=useContext(_DexContext);if(ctx===null){throw new Error(\"Context not available\");}return ctx;}export function useOpenOrders(){var ctx=useDexContext();return ctx.openOrders;}// Lazy load a given market.\nexport function useMarket(market){var _useDexContext=useDexContext(),swapClient=_useDexContext.swapClient;var asyncMarket=useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(){var marketClient;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(market){_context4.next=2;break;}return _context4.abrupt(\"return\",undefined);case 2:if(!_MARKET_CACHE.get(market.toString())){_context4.next=4;break;}return _context4.abrupt(\"return\",_MARKET_CACHE.get(market.toString()));case 4:marketClient=new Promise(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(resolve){var marketClient;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return Market.load(swapClient.program.provider.connection,market,swapClient.program.provider.opts,DEX_PID);case 2:marketClient=_context3.sent;resolve(marketClient);case 4:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x3){return _ref4.apply(this,arguments);};}());_MARKET_CACHE.set(market.toString(),marketClient);return _context4.abrupt(\"return\",marketClient);case 7:case\"end\":return _context4.stop();}}},_callee4);})),[swapClient.program.provider.connection,market]);if(asyncMarket.result){return asyncMarket.result;}return undefined;}// Lazy load the orderbook for a given market.\nexport function useOrderbook(market){var _useDexContext2=useDexContext(),swapClient=_useDexContext2.swapClient;var marketClient=useMarket(market);var _useState3=useState(0),_useState4=_slicedToArray(_useState3,2),refresh=_useState4[0],setRefresh=_useState4[1];var asyncOrderbook=useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(){var orderbook;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:if(!(!market||!marketClient)){_context6.next=2;break;}return _context6.abrupt(\"return\",undefined);case 2:if(!_ORDERBOOK_CACHE.get(market.toString())){_context6.next=4;break;}return _context6.abrupt(\"return\",_ORDERBOOK_CACHE.get(market.toString()));case 4:orderbook=new Promise(/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(resolve){var _yield$Promise$all,_yield$Promise$all2,bids,asks;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return Promise.all([marketClient.loadBids(swapClient.program.provider.connection),marketClient.loadAsks(swapClient.program.provider.connection)]);case 2:_yield$Promise$all=_context5.sent;_yield$Promise$all2=_slicedToArray(_yield$Promise$all,2);bids=_yield$Promise$all2[0];asks=_yield$Promise$all2[1];resolve({bids:bids,asks:asks});case 7:case\"end\":return _context5.stop();}}},_callee5);}));return function(_x4){return _ref6.apply(this,arguments);};}());_ORDERBOOK_CACHE.set(market.toString(),orderbook);return _context6.abrupt(\"return\",orderbook);case 7:case\"end\":return _context6.stop();}}},_callee6);})),[refresh,swapClient.program.provider.connection,market,marketClient]);// Stream in bids updates.\nuseEffect(function(){var listener;if(marketClient===null||marketClient===void 0?void 0:marketClient.bidsAddress){listener=swapClient.program.provider.connection.onAccountChange(marketClient===null||marketClient===void 0?void 0:marketClient.bidsAddress,/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(info){var bids,orderbook,oldBestBid,newBestBid;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:bids=OrderbookSide.decode(marketClient,info.data);_context7.next=3;return _ORDERBOOK_CACHE.get(marketClient.address.toString());case 3:orderbook=_context7.sent;oldBestBid=orderbook===null||orderbook===void 0?void 0:orderbook.bids.items(true).next().value;newBestBid=bids.items(true).next().value;if(orderbook&&oldBestBid&&newBestBid&&oldBestBid.price!==newBestBid.price){orderbook.bids=bids;setRefresh(function(r){return r+1;});}case 7:case\"end\":return _context7.stop();}}},_callee7);}));return function(_x5){return _ref7.apply(this,arguments);};}());}return function(){if(listener){swapClient.program.provider.connection.removeAccountChangeListener(listener);}};},[marketClient,marketClient===null||marketClient===void 0?void 0:marketClient.bidsAddress,swapClient.program.provider.connection]);// Stream in asks updates.\nuseEffect(function(){var listener;if(marketClient===null||marketClient===void 0?void 0:marketClient.asksAddress){listener=swapClient.program.provider.connection.onAccountChange(marketClient===null||marketClient===void 0?void 0:marketClient.asksAddress,/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(info){var asks,orderbook,oldBestOffer,newBestOffer;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:asks=OrderbookSide.decode(marketClient,info.data);_context8.next=3;return _ORDERBOOK_CACHE.get(marketClient.address.toString());case 3:orderbook=_context8.sent;oldBestOffer=orderbook===null||orderbook===void 0?void 0:orderbook.asks.items(false).next().value;newBestOffer=asks.items(false).next().value;if(orderbook&&oldBestOffer&&newBestOffer&&oldBestOffer.price!==newBestOffer.price){orderbook.asks=asks;setRefresh(function(r){return r+1;});}case 7:case\"end\":return _context8.stop();}}},_callee8);}));return function(_x6){return _ref8.apply(this,arguments);};}());}return function(){if(listener){swapClient.program.provider.connection.removeAccountChangeListener(listener);}};},[marketClient,marketClient===null||marketClient===void 0?void 0:marketClient.bidsAddress,swapClient.program.provider.connection]);if(asyncOrderbook.result){return asyncOrderbook.result;}return undefined;}export function useMarketName(market){var _tokenMap$get,_tokenMap$get2;var tokenMap=useTokenMap();var marketClient=useMarket(market);if(!marketClient){return null;}var baseTicker=marketClient?(_tokenMap$get=tokenMap.get(marketClient===null||marketClient===void 0?void 0:marketClient.baseMintAddress.toString()))===null||_tokenMap$get===void 0?void 0:_tokenMap$get.symbol:\"-\";var quoteTicker=marketClient?(_tokenMap$get2=tokenMap.get(marketClient===null||marketClient===void 0?void 0:marketClient.quoteMintAddress.toString()))===null||_tokenMap$get2===void 0?void 0:_tokenMap$get2.symbol:\"-\";var name=\"\".concat(baseTicker,\" / \").concat(quoteTicker);return name;}// Fair price for a given market, as defined by the mid.\nexport function useBbo(market){var orderbook=useOrderbook(market);if(orderbook===undefined){return undefined;}var bestBid=orderbook.bids.items(true).next().value;var bestOffer=orderbook.asks.items(false).next().value;if(!bestBid&&!bestOffer){return{};}if(!bestBid){return{bestOffer:bestOffer.price};}if(!bestOffer){return{bestBid:bestBid.price};}var mid=(bestBid.price+bestOffer.price)/2.0;return{bestBid:bestBid.price,bestOffer:bestOffer.price,mid:mid};}// Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\nexport function useFairRoute(fromMint,toMint){var route=useRoute(fromMint,toMint);var fromBbo=useBbo(route?route[0]:undefined);var fromMarket=useMarket(route?route[0]:undefined);var toBbo=useBbo(route?route[1]:undefined);if(route===null){return undefined;}if(route.length===1&&fromBbo!==undefined){if(fromMarket===undefined){return undefined;}if((fromMarket===null||fromMarket===void 0?void 0:fromMarket.baseMintAddress.equals(fromMint))||(fromMarket===null||fromMarket===void 0?void 0:fromMarket.baseMintAddress.equals(WRAPPED_SOL_MINT))&&fromMint.equals(SOL_MINT)){return fromBbo.bestBid&&1.0/fromBbo.bestBid;}else{return fromBbo.bestOffer&&fromBbo.bestOffer;}}if(fromBbo===undefined||fromBbo.bestBid===undefined||toBbo===undefined||toBbo.bestOffer===undefined){return undefined;}return toBbo.bestOffer/fromBbo.bestBid;}export function useRoute(fromMint,toMint){var route=useRouteVerbose(fromMint,toMint);if(route===null){return null;}return route.markets;}// Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\nexport function useRouteVerbose(fromMint,toMint){var _useDexContext3=useDexContext(),swapClient=_useDexContext3.swapClient;var _useTokenListContext=useTokenListContext(),wormholeMap=_useTokenListContext.wormholeMap,solletMap=_useTokenListContext.solletMap;var asyncRoute=useAsync(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(){var swapMarket,_swapMarket,wormholeMarket,_kind,markets,kind;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return wormholeSwapMarket(swapClient.program.provider.connection,fromMint,toMint,wormholeMap,solletMap);case 2:swapMarket=_context9.sent;if(!(swapMarket!==null)){_context9.next=6;break;}_swapMarket=_slicedToArray(swapMarket,2),wormholeMarket=_swapMarket[0],_kind=_swapMarket[1];return _context9.abrupt(\"return\",{markets:[wormholeMarket],kind:_kind});case 6:markets=swapClient.route(fromMint.equals(SOL_MINT)?WRAPPED_SOL_MINT:fromMint,toMint.equals(SOL_MINT)?WRAPPED_SOL_MINT:toMint);if(!(markets===null)){_context9.next=9;break;}return _context9.abrupt(\"return\",null);case 9:kind=\"usdx\";return _context9.abrupt(\"return\",{markets:markets,kind:kind});case 11:case\"end\":return _context9.stop();}}},_callee9);})),[fromMint,toMint,swapClient]);if(asyncRoute.result){return asyncRoute.result;}return null;}// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nvar WORMHOLE_NATIVE_MAP=new Map([[wormKey(WORM_USDC_MINT,USDC_MINT),WORM_USDC_MARKET],[wormKey(WORM_USDT_MINT,USDT_MINT),WORM_USDT_MARKET]]);function wormKey(fromMint,toMint){var _ref10=fromMint<toMint?[fromMint,toMint]:[toMint,fromMint],_ref11=_slicedToArray(_ref10,2),first=_ref11[0],second=_ref11[1];return first.toString()+second.toString();}function wormholeSwapMarket(_x7,_x8,_x9,_x10,_x11){return _wormholeSwapMarket.apply(this,arguments);}function _wormholeSwapMarket(){_wormholeSwapMarket=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(conn,fromMint,toMint,wormholeMap,solletMap){var market;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:market=wormholeNativeMarket(fromMint,toMint);if(!(market!==null)){_context10.next=3;break;}return _context10.abrupt(\"return\",[market,\"wormhole-native\"]);case 3:_context10.next=5;return wormholeSolletMarket(conn,fromMint,toMint,wormholeMap,solletMap);case 5:market=_context10.sent;if(!(market===null)){_context10.next=8;break;}return _context10.abrupt(\"return\",null);case 8:return _context10.abrupt(\"return\",[market,\"wormhole-sollet\"]);case 9:case\"end\":return _context10.stop();}}},_callee10);}));return _wormholeSwapMarket.apply(this,arguments);}function wormholeNativeMarket(fromMint,toMint){var _WORMHOLE_NATIVE_MAP$;return(_WORMHOLE_NATIVE_MAP$=WORMHOLE_NATIVE_MAP.get(wormKey(fromMint,toMint)))!==null&&_WORMHOLE_NATIVE_MAP$!==void 0?_WORMHOLE_NATIVE_MAP$:null;}// Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\nfunction wormholeSolletMarket(_x12,_x13,_x14,_x15,_x16){return _wormholeSolletMarket.apply(this,arguments);}// Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\nfunction _wormholeSolletMarket(){_wormholeSolletMarket=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(conn,fromMint,toMint,wormholeMap,solletMap){var fromWormhole,isFromWormhole,toWormhole,isToWormhole,fromSollet,isFromSollet,toSollet,isToSollet,_extensions,base,_ref12,_ref13,quote,wormholeInfo,solletInfo,market,marketExists;return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:fromWormhole=wormholeMap.get(fromMint.toString());isFromWormhole=fromWormhole!==undefined;toWormhole=wormholeMap.get(toMint.toString());isToWormhole=toWormhole!==undefined;fromSollet=solletMap.get(fromMint.toString());isFromSollet=fromSollet!==undefined;toSollet=solletMap.get(toMint.toString());isToSollet=toSollet!==undefined;if(!((isFromWormhole||isToWormhole)&&isFromWormhole!==isToWormhole)){_context11.next=28;break;}if(!((isFromSollet||isToSollet)&&isFromSollet!==isToSollet)){_context11.next=28;break;}base=isFromSollet?fromMint:toMint;_ref12=isFromWormhole?[fromMint,fromWormhole]:[toMint,toWormhole],_ref13=_slicedToArray(_ref12,2),quote=_ref13[0],wormholeInfo=_ref13[1];_context11.next=14;return fetchSolletInfo(base);case 14:solletInfo=_context11.sent;if(!(solletInfo.erc20Contract!==((_extensions=wormholeInfo.extensions)===null||_extensions===void 0?void 0:_extensions.address))){_context11.next=17;break;}return _context11.abrupt(\"return\",null);case 17:_context11.next=19;return deriveWormholeMarket(base,quote);case 19:market=_context11.sent;if(!(market===null)){_context11.next=22;break;}return _context11.abrupt(\"return\",null);case 22:_context11.next=24;return requestWormholeSwapMarketIfNeeded(conn,base,quote,market,solletInfo);case 24:marketExists=_context11.sent;if(marketExists){_context11.next=27;break;}return _context11.abrupt(\"return\",null);case 27:return _context11.abrupt(\"return\",market);case 28:return _context11.abrupt(\"return\",null);case 29:case\"end\":return _context11.stop();}}},_callee11);}));return _wormholeSolletMarket.apply(this,arguments);}function deriveWormholeMarket(_x17,_x18){return _deriveWormholeMarket.apply(this,arguments);}function _deriveWormholeMarket(){_deriveWormholeMarket=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12(baseMint,quoteMint){var version,padToTwo,seed,_args12=arguments;return _regeneratorRuntime.wrap(function _callee12$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:version=_args12.length>2&&_args12[2]!==undefined?_args12[2]:0;if(!(version>99)){_context12.next=4;break;}console.log(\"Swap market version cannot be greater than 99\");return _context12.abrupt(\"return\",null);case 4:if(!(version<0)){_context12.next=7;break;}console.log(\"Version cannot be less than zero\");return _context12.abrupt(\"return\",null);case 7:padToTwo=function padToTwo(n){return n<=99?\"0\".concat(n).slice(-2):n;};seed=baseMint.toString().slice(0,15)+quoteMint.toString().slice(0,15)+padToTwo(version);_context12.next=11;return PublicKey.createWithSeed(WORM_MARKET_BASE,seed,DEX_PID);case 11:return _context12.abrupt(\"return\",_context12.sent);case 12:case\"end\":return _context12.stop();}}},_callee12);}));return _deriveWormholeMarket.apply(this,arguments);}var _ORDERBOOK_CACHE=new Map();var _MARKET_CACHE=new Map();","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Dex.tsx"],"names":["React","useContext","useState","useEffect","assert","useAsync","MintLayout","PublicKey","anchor","Market","OpenOrders","Orderbook","OrderbookSide","DEX_PID","USDC_MINT","USDT_MINT","SOL_MINT","WRAPPED_SOL_MINT","WORM_USDC_MINT","WORM_USDT_MINT","WORM_USDC_MARKET","WORM_USDT_MARKET","WORM_MARKET_BASE","useTokenMap","useTokenListContext","fetchSolletInfo","requestWormholeSwapMarketIfNeeded","setMintCache","BASE_TAKER_FEE_BPS","FEE_MULTIPLIER","_DexContext","createContext","DexContextProvider","props","Map","ooAccounts","setOoAccounts","swapClient","closeOpenOrders","openOrder","newOoAccounts","openOrders","get","market","toString","filter","oo","address","equals","length","set","delete","program","provider","wallet","publicKey","findForOwner","connection","then","markets","Set","forEach","add","push","size","Error","utils","rpc","getMultipleAccounts","Array","from","values","map","m","multipleMarkets","marketClients","programAccount","account","getLayout","decode","data","opts","mintPubkeys","baseMintAddress","quoteMintAddress","flat","pk","mints","mintInfos","mint","mintInfo","baseMintInfo","quoteMintInfo","ok","_baseSplTokenDecimals","decimals","_quoteSplTokenDecimals","_MARKET_CACHE","Promise","resolve","children","useDexContext","ctx","useOpenOrders","useMarket","asyncMarket","undefined","marketClient","load","result","useOrderbook","refresh","setRefresh","asyncOrderbook","_ORDERBOOK_CACHE","orderbook","all","loadBids","loadAsks","bids","asks","listener","bidsAddress","onAccountChange","info","oldBestBid","items","next","value","newBestBid","price","r","removeAccountChangeListener","asksAddress","oldBestOffer","newBestOffer","useMarketName","tokenMap","baseTicker","symbol","quoteTicker","name","useBbo","bestBid","bestOffer","mid","useFairRoute","fromMint","toMint","route","useRoute","fromBbo","fromMarket","toBbo","useRouteVerbose","wormholeMap","solletMap","asyncRoute","wormholeSwapMarket","swapMarket","wormholeMarket","kind","WORMHOLE_NATIVE_MAP","wormKey","first","second","conn","wormholeNativeMarket","wormholeSolletMarket","fromWormhole","isFromWormhole","toWormhole","isToWormhole","fromSollet","isFromSollet","toSollet","isToSollet","base","quote","wormholeInfo","solletInfo","erc20Contract","extensions","deriveWormholeMarket","marketExists","baseMint","quoteMint","version","console","log","padToTwo","n","slice","seed","createWithSeed"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { MintLayout } from \"@solana/spl-token\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { Swap as SwapClient } from \"@project-serum/swap\";\nimport {\n  Market,\n  OpenOrders,\n  Orderbook as OrderbookSide,\n} from \"@project-serum/serum\";\nimport {\n  DEX_PID,\n  USDC_MINT,\n  USDT_MINT,\n  SOL_MINT,\n  WRAPPED_SOL_MINT,\n  WORM_USDC_MINT,\n  WORM_USDT_MINT,\n  WORM_USDC_MARKET,\n  WORM_USDT_MARKET,\n  WORM_MARKET_BASE,\n} from \"../utils/pubkeys\";\nimport { useTokenMap, useTokenListContext } from \"./TokenList\";\nimport { fetchSolletInfo, requestWormholeSwapMarketIfNeeded } from \"./Sollet\";\nimport { setMintCache } from \"./Token\";\n\nconst BASE_TAKER_FEE_BPS = 0.0022;\nexport const FEE_MULTIPLIER = 1 - BASE_TAKER_FEE_BPS;\n\ntype DexContext = {\n  // Maps market address to open orders accounts.\n  openOrders: Map<string, Array<OpenOrders>>;\n  closeOpenOrders: (openOrder: OpenOrders) => void;\n  swapClient: SwapClient;\n};\nconst _DexContext = React.createContext<DexContext | null>(null);\n\nexport function DexContextProvider(props: any) {\n  const [ooAccounts, setOoAccounts] = useState<Map<string, Array<OpenOrders>>>(\n    new Map()\n  );\n  const swapClient = props.swapClient;\n\n  // Removes the given open orders from the context.\n  const closeOpenOrders = async (openOrder: OpenOrders) => {\n    const newOoAccounts = new Map(ooAccounts);\n    const openOrders = newOoAccounts\n      .get(openOrder.market.toString())\n      ?.filter((oo: OpenOrders) => !oo.address.equals(openOrder.address));\n    if (openOrders && openOrders.length > 0) {\n      newOoAccounts.set(openOrder.market.toString(), openOrders);\n    } else {\n      newOoAccounts.delete(openOrder.market.toString());\n    }\n    setOoAccounts(newOoAccounts);\n  };\n\n  // Three operations:\n  //\n  // 1. Fetch all open orders accounts for the connected wallet.\n  // 2. Batch fetch all market accounts for those open orders.\n  // 3. Batch fetch all mints associated with the markets.\n  useEffect(() => {\n    if (!swapClient.program.provider.wallet.publicKey) {\n      setOoAccounts(new Map());\n      return;\n    }\n    OpenOrders.findForOwner(\n      swapClient.program.provider.connection,\n      swapClient.program.provider.wallet.publicKey,\n      DEX_PID\n    ).then(async (openOrders) => {\n      const newOoAccounts = new Map();\n      let markets = new Set<string>();\n      openOrders.forEach((oo) => {\n        markets.add(oo.market.toString());\n        if (newOoAccounts.get(oo.market.toString())) {\n          newOoAccounts.get(oo.market.toString()).push(oo);\n        } else {\n          newOoAccounts.set(oo.market.toString(), [oo]);\n        }\n      });\n      if (markets.size > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\n          \"Too many markets. Please file an issue to update this\"\n        );\n      }\n      const multipleMarkets = await anchor.utils.rpc.getMultipleAccounts(\n        swapClient.program.provider.connection,\n        Array.from(markets.values()).map((m) => new PublicKey(m))\n      );\n      const marketClients = multipleMarkets.map((programAccount) => {\n        return {\n          publicKey: programAccount?.publicKey,\n          account: new Market(\n            Market.getLayout(DEX_PID).decode(programAccount?.account.data),\n            -1, // Set below so that we can batch fetch mints.\n            -1, // Set below so that we can batch fetch mints.\n            swapClient.program.provider.opts,\n            DEX_PID\n          ),\n        };\n      });\n\n      setOoAccounts(newOoAccounts);\n\n      // Batch fetch all the mints, since we know we'll need them at some\n      // point.\n      const mintPubkeys = Array.from(\n        new Set<string>(\n          marketClients\n            .map((m) => [\n              m.account.baseMintAddress.toString(),\n              m.account.quoteMintAddress.toString(),\n            ])\n            .flat()\n        ).values()\n      ).map((pk) => new PublicKey(pk));\n\n      if (mintPubkeys.length > 100) {\n        // Punt request chunking until there's user demand.\n        throw new Error(\"Too many mints. Please file an issue to update this\");\n      }\n\n      const mints = await anchor.utils.rpc.getMultipleAccounts(\n        swapClient.program.provider.connection,\n        mintPubkeys\n      );\n      const mintInfos = mints.map((mint) => {\n        const mintInfo = MintLayout.decode(mint!.account.data);\n        setMintCache(mint!.publicKey, mintInfo);\n        return { publicKey: mint!.publicKey, mintInfo };\n      });\n\n      marketClients.forEach((m) => {\n        const baseMintInfo = mintInfos.filter((mint) =>\n          mint.publicKey.equals(m.account.baseMintAddress)\n        )[0];\n        const quoteMintInfo = mintInfos.filter((mint) =>\n          mint.publicKey.equals(m.account.quoteMintAddress)\n        )[0];\n        assert.ok(baseMintInfo && quoteMintInfo);\n        // @ts-ignore\n        m.account._baseSplTokenDecimals = baseMintInfo.mintInfo.decimals;\n        // @ts-ignore\n        m.account._quoteSplTokenDecimals = quoteMintInfo.mintInfo.decimals;\n        _MARKET_CACHE.set(\n          m.publicKey!.toString(),\n          new Promise<Market>((resolve) => resolve(m.account))\n        );\n      });\n    });\n  }, [\n    swapClient.program.provider.connection,\n    swapClient.program.provider.wallet.publicKey,\n    swapClient.program.provider.opts,\n  ]);\n  return (\n    <_DexContext.Provider\n      value={{\n        openOrders: ooAccounts,\n        closeOpenOrders,\n        swapClient,\n      }}\n    >\n      {props.children}\n    </_DexContext.Provider>\n  );\n}\n\nexport function useDexContext(): DexContext {\n  const ctx = useContext(_DexContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useOpenOrders(): Map<string, Array<OpenOrders>> {\n  const ctx = useDexContext();\n  return ctx.openOrders;\n}\n\n// Lazy load a given market.\nexport function useMarket(market?: PublicKey): Market | undefined {\n  const { swapClient } = useDexContext();\n\n  const asyncMarket = useAsync(async () => {\n    if (!market) {\n      return undefined;\n    }\n    if (_MARKET_CACHE.get(market.toString())) {\n      return _MARKET_CACHE.get(market.toString());\n    }\n\n    const marketClient = new Promise<Market>(async (resolve) => {\n      // TODO: if we already have the mints, then pass them through to the\n      //       market client here to save a network request.\n      const marketClient = await Market.load(\n        swapClient.program.provider.connection,\n        market,\n        swapClient.program.provider.opts,\n        DEX_PID\n      );\n      resolve(marketClient);\n    });\n\n    _MARKET_CACHE.set(market.toString(), marketClient);\n    return marketClient;\n  }, [swapClient.program.provider.connection, market]);\n\n  if (asyncMarket.result) {\n    return asyncMarket.result;\n  }\n\n  return undefined;\n}\n\n// Lazy load the orderbook for a given market.\nexport function useOrderbook(market?: PublicKey): Orderbook | undefined {\n  const { swapClient } = useDexContext();\n  const marketClient = useMarket(market);\n  const [refresh, setRefresh] = useState(0);\n\n  const asyncOrderbook = useAsync(async () => {\n    if (!market || !marketClient) {\n      return undefined;\n    }\n    if (_ORDERBOOK_CACHE.get(market.toString())) {\n      return _ORDERBOOK_CACHE.get(market.toString());\n    }\n\n    const orderbook = new Promise<Orderbook>(async (resolve) => {\n      const [bids, asks] = await Promise.all([\n        marketClient.loadBids(swapClient.program.provider.connection),\n        marketClient.loadAsks(swapClient.program.provider.connection),\n      ]);\n\n      resolve({\n        bids,\n        asks,\n      });\n    });\n\n    _ORDERBOOK_CACHE.set(market.toString(), orderbook);\n\n    return orderbook;\n  }, [refresh, swapClient.program.provider.connection, market, marketClient]);\n\n  // Stream in bids updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.bidsAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.bidsAddress,\n        async (info) => {\n          const bids = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestBid = orderbook?.bids.items(true).next().value;\n          const newBestBid = bids.items(true).next().value;\n          if (\n            orderbook &&\n            oldBestBid &&\n            newBestBid &&\n            oldBestBid.price !== newBestBid.price\n          ) {\n            orderbook.bids = bids;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  // Stream in asks updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.asksAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.asksAddress,\n        async (info) => {\n          const asks = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestOffer = orderbook?.asks.items(false).next().value;\n          const newBestOffer = asks.items(false).next().value;\n          if (\n            orderbook &&\n            oldBestOffer &&\n            newBestOffer &&\n            oldBestOffer.price !== newBestOffer.price\n          ) {\n            orderbook.asks = asks;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  if (asyncOrderbook.result) {\n    return asyncOrderbook.result;\n  }\n\n  return undefined;\n}\n\nexport function useMarketName(market: PublicKey): string | null {\n  const tokenMap = useTokenMap();\n  const marketClient = useMarket(market);\n  if (!marketClient) {\n    return null;\n  }\n  const baseTicker = marketClient\n    ? tokenMap.get(marketClient?.baseMintAddress.toString())?.symbol\n    : \"-\";\n  const quoteTicker = marketClient\n    ? tokenMap.get(marketClient?.quoteMintAddress.toString())?.symbol\n    : \"-\";\n  const name = `${baseTicker} / ${quoteTicker}`;\n  return name;\n}\n\n// Fair price for a given market, as defined by the mid.\nexport function useBbo(market?: PublicKey): Bbo | undefined {\n  const orderbook = useOrderbook(market);\n  if (orderbook === undefined) {\n    return undefined;\n  }\n  const bestBid = orderbook.bids.items(true).next().value;\n  const bestOffer = orderbook.asks.items(false).next().value;\n  if (!bestBid && !bestOffer) {\n    return {};\n  }\n  if (!bestBid) {\n    return { bestOffer: bestOffer.price };\n  }\n  if (!bestOffer) {\n    return { bestBid: bestBid.price };\n  }\n  const mid = (bestBid.price + bestOffer.price) / 2.0;\n  return { bestBid: bestBid.price, bestOffer: bestOffer.price, mid };\n}\n\n// Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\nexport function useFairRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): number | undefined {\n  const route = useRoute(fromMint, toMint);\n  const fromBbo = useBbo(route ? route[0] : undefined);\n  const fromMarket = useMarket(route ? route[0] : undefined);\n  const toBbo = useBbo(route ? route[1] : undefined);\n\n  if (route === null) {\n    return undefined;\n  }\n\n  if (route.length === 1 && fromBbo !== undefined) {\n    if (fromMarket === undefined) {\n      return undefined;\n    }\n    if (\n      fromMarket?.baseMintAddress.equals(fromMint) ||\n      (fromMarket?.baseMintAddress.equals(WRAPPED_SOL_MINT) &&\n        fromMint.equals(SOL_MINT))\n    ) {\n      return fromBbo.bestBid && 1.0 / fromBbo.bestBid;\n    } else {\n      return fromBbo.bestOffer && fromBbo.bestOffer;\n    }\n  }\n  if (\n    fromBbo === undefined ||\n    fromBbo.bestBid === undefined ||\n    toBbo === undefined ||\n    toBbo.bestOffer === undefined\n  ) {\n    return undefined;\n  }\n  return toBbo.bestOffer / fromBbo.bestBid;\n}\n\nexport function useRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): Array<PublicKey> | null {\n  const route = useRouteVerbose(fromMint, toMint);\n  if (route === null) {\n    return null;\n  }\n  return route.markets;\n}\n\n// Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\nexport function useRouteVerbose(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): { markets: Array<PublicKey>; kind: RouteKind } | null {\n  const { swapClient } = useDexContext();\n  const { wormholeMap, solletMap } = useTokenListContext();\n  const asyncRoute = useAsync(async () => {\n    const swapMarket = await wormholeSwapMarket(\n      swapClient.program.provider.connection,\n      fromMint,\n      toMint,\n      wormholeMap,\n      solletMap\n    );\n    if (swapMarket !== null) {\n      const [wormholeMarket, kind] = swapMarket;\n      return { markets: [wormholeMarket], kind };\n    }\n    const markets = swapClient.route(\n      fromMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : fromMint,\n      toMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : toMint\n    );\n    if (markets === null) {\n      return null;\n    }\n    const kind: RouteKind = \"usdx\";\n    return { markets, kind };\n  }, [fromMint, toMint, swapClient]);\n\n  if (asyncRoute.result) {\n    return asyncRoute.result;\n  }\n  return null;\n}\n\ntype Orderbook = {\n  bids: OrderbookSide;\n  asks: OrderbookSide;\n};\n\n// Wormhole utils.\n\ntype RouteKind = \"wormhole-native\" | \"wormhole-sollet\" | \"usdx\";\n\n// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nconst WORMHOLE_NATIVE_MAP = new Map<string, PublicKey>([\n  [wormKey(WORM_USDC_MINT, USDC_MINT), WORM_USDC_MARKET],\n  [wormKey(WORM_USDT_MINT, USDT_MINT), WORM_USDT_MARKET],\n]);\n\nfunction wormKey(fromMint: PublicKey, toMint: PublicKey): string {\n  const [first, second] =\n    fromMint < toMint ? [fromMint, toMint] : [toMint, fromMint];\n  return first.toString() + second.toString();\n}\n\nasync function wormholeSwapMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<[PublicKey, RouteKind] | null> {\n  let market = wormholeNativeMarket(fromMint, toMint);\n  if (market !== null) {\n    return [market, \"wormhole-native\"];\n  }\n  market = await wormholeSolletMarket(\n    conn,\n    fromMint,\n    toMint,\n    wormholeMap,\n    solletMap\n  );\n  if (market === null) {\n    return null;\n  }\n  return [market, \"wormhole-sollet\"];\n}\n\nfunction wormholeNativeMarket(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): PublicKey | null {\n  return WORMHOLE_NATIVE_MAP.get(wormKey(fromMint, toMint)) ?? null;\n}\n\n// Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\nasync function wormholeSolletMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<PublicKey | null> {\n  const fromWormhole = wormholeMap.get(fromMint.toString());\n  const isFromWormhole = fromWormhole !== undefined;\n\n  const toWormhole = wormholeMap.get(toMint.toString());\n  const isToWormhole = toWormhole !== undefined;\n\n  const fromSollet = solletMap.get(fromMint.toString());\n  const isFromSollet = fromSollet !== undefined;\n\n  const toSollet = solletMap.get(toMint.toString());\n  const isToSollet = toSollet !== undefined;\n\n  if ((isFromWormhole || isToWormhole) && isFromWormhole !== isToWormhole) {\n    if ((isFromSollet || isToSollet) && isFromSollet !== isToSollet) {\n      const base = isFromSollet ? fromMint : toMint;\n      const [quote, wormholeInfo] = isFromWormhole\n        ? [fromMint, fromWormhole]\n        : [toMint, toWormhole];\n\n      const solletInfo = await fetchSolletInfo(base);\n\n      if (solletInfo.erc20Contract !== wormholeInfo!.extensions?.address) {\n        return null;\n      }\n\n      const market = await deriveWormholeMarket(base, quote);\n      if (market === null) {\n        return null;\n      }\n\n      const marketExists = await requestWormholeSwapMarketIfNeeded(\n        conn,\n        base,\n        quote,\n        market,\n        solletInfo\n      );\n      if (!marketExists) {\n        return null;\n      }\n\n      return market;\n    }\n  }\n  return null;\n}\n\n// Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\nasync function deriveWormholeMarket(\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  version = 0\n): Promise<PublicKey | null> {\n  if (version > 99) {\n    console.log(\"Swap market version cannot be greater than 99\");\n    return null;\n  }\n  if (version < 0) {\n    console.log(\"Version cannot be less than zero\");\n    return null;\n  }\n\n  const padToTwo = (n: number) => (n <= 99 ? `0${n}`.slice(-2) : n);\n  const seed =\n    baseMint.toString().slice(0, 15) +\n    quoteMint.toString().slice(0, 15) +\n    padToTwo(version);\n  return await PublicKey.createWithSeed(WORM_MARKET_BASE, seed, DEX_PID);\n}\n\ntype Bbo = {\n  bestBid?: number;\n  bestOffer?: number;\n  mid?: number;\n};\n\nconst _ORDERBOOK_CACHE = new Map<string, Promise<Orderbook>>();\nconst _MARKET_CACHE = new Map<string, Promise<Market>>();\n"]},"metadata":{},"sourceType":"module"}