{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Swap = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst spl_token_1 = require(\"@solana/spl-token\");\n\nconst anchor_1 = require(\"@project-serum/anchor\");\n\nconst serum_1 = require(\"@project-serum/serum\");\n\nconst idl_1 = require(\"./idl\");\n\nconst utils_1 = require(\"./utils\");\n\nconst swap_markets_1 = __importDefault(require(\"./swap-markets\")); // Close account feature flag.\n//\n// TODO: enable once the DEX supports closing open orders accounts.\n\n\nconst CLOSE_ENABLED = false;\n/**\n *\n * # Swap\n *\n * A module to swap tokens across markets the Serum DEX, providing a thin\n * wrapper around an [Anchor](https://github.com/project-serum/anchor) client\n * for the purpose of providing a simplified `swap` API.\n *\n * ## Swap Program Basics\n *\n * One should have a basic understanding of the on-chain\n * [Swap](https://github.com/project-serum/swap) program before using the\n * client. Two core APIs are exposed.\n *\n * * [swap](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L36) -\n *   swaps two tokens on a single A/B market. This is just an IOC trade at the\n *   BBO that instantly settles.\n * * [swapTransitive](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L107) -\n *   swaps two tokens across **two** A/x, B/x markets in the same manner as\n *   `swap`.\n *\n * For both APIs, if the number of tokens received from the trade is less than\n * the client provided `minExchangeRate`, the transaction aborts.\n *\n * Note that if this client package is insufficient, one can always use the\n * Anchor generated client directly, exposing an API mapping one-to-one to\n * these program instructions. See the\n * [`tests/`](https://github.com/project-serum/swap/blob/master/tests/swap.js)\n * for examples of using the Anchor generated swap client.\n *\n * ## Serum Orderbook Program Basics\n *\n * Additionally, because the Swap program is an on-chain frontend for the Serum\n * DEX, one should also be aware of the basic accounts needed for trading on\n * the Serum DEX.\n *\n * Namely, a wallet must have an \"open orders\" account for each market the\n * wallet trades on. The \"open orders\" account is akin to how a wallet\n *  must have an SPL token account to own tokens, except instead of holding\n * tokens, the wallet can make trades on the orderbook.\n *\n * ### Creating Open Orders Accounts\n *\n * When the wallet doesn't have an open orders account already created,\n * the swap client provides two choices. Automatically create the required\n * accounts by preloading the instructions in the [[swap]] transaction.\n *\n * Note that if the user is swapping between two non-USD(x) tokens, e.g., wBTC\n * for wETH, then the user needs *two* open orders accounts on both wBTC/USD(x)\n * and wETH/USD(x) markets. In the event both of these open orders accounts are\n * created for the rfirst time, then the transaction is broken up into two\n * (and `Provider.sendAll` is used) to prevent hitting transaction size limits.\n */\n\nclass Swap {\n  /**\n   * @param provider  The wallet and network context to use for the client.\n   * @param tokenList The token list providing market addresses for each mint.\n   */\n  constructor(provider, tokenList) {\n    this._program = new anchor_1.Program(idl_1.IDL, utils_1.SWAP_PID, provider);\n    this._swapMarkets = new swap_markets_1.default(provider, tokenList);\n  }\n  /**\n   * Anchor generated client for the swap program.\n   */\n\n\n  get program() {\n    return this._program;\n  }\n  /**\n   * Token list registry for fetching USD(x) markets for each mint.\n   */\n\n\n  get swapMarkets() {\n    return this._swapMarkets;\n  }\n  /**\n   * Returns a list of markets to trade across to swap `fromMint` to `toMint`.\n   */\n\n\n  route(fromMint, toMint) {\n    return this.swapMarkets.route(fromMint, toMint);\n  }\n  /**\n   * Executes a swap against the Serum DEX.\n   */\n\n\n  async swap(params) {\n    const pk = this.program.provider.wallet.publicKey;\n\n    if (!pk || web3_js_1.PublicKey.default.equals(pk)) {\n      throw new Error('Wallet not found');\n    }\n\n    let txs = await this.swapTxs(params);\n\n    if (params.additionalTransactions) {\n      txs = txs.concat(params.additionalTransactions);\n    }\n\n    return this.program.provider.sendAll(txs, params.options);\n  }\n  /**\n   * Returns transactions for swapping on the Serum DEX.\n   */\n\n\n  async swapTxs(params) {\n    let {\n      fromMint,\n      toMint,\n      quoteWallet,\n      fromWallet,\n      toWallet,\n      quoteMint,\n      fromMarket,\n      toMarket,\n      amount,\n      minExchangeRate,\n      referral,\n      close,\n      fromOpenOrders,\n      toOpenOrders\n    } = params; // If swapping to/from a USD(x) token, then swap directly on the market.\n\n    if (isUsdx(fromMint)) {\n      let coinWallet = toWallet;\n      let pcWallet = fromWallet;\n      let baseMint = toMint;\n      let quoteMint = fromMint;\n      let side = Side.Bid; // Special case USDT/USDC market since the coin is always USDT and\n      // the pc is always USDC.\n\n      if (toMint.equals(utils_1.USDC_PUBKEY)) {\n        coinWallet = fromWallet;\n        pcWallet = toWallet;\n        baseMint = fromMint;\n        quoteMint = toMint;\n        side = Side.Ask;\n      } else if (toMint.equals(utils_1.USDT_PUBKEY)) {\n        coinWallet = toWallet;\n        pcWallet = fromWallet;\n        baseMint = toMint;\n        quoteMint = quoteMint;\n        side = Side.Bid;\n      }\n\n      return await this.swapDirectTxs({\n        coinWallet,\n        pcWallet,\n        baseMint,\n        quoteMint,\n        side,\n        amount,\n        minExchangeRate,\n        referral,\n        close,\n        fromMarket,\n        fromOpenOrders\n      });\n    } else if (isUsdx(toMint)) {\n      return await this.swapDirectTxs({\n        coinWallet: fromWallet,\n        pcWallet: toWallet,\n        baseMint: fromMint,\n        quoteMint: toMint,\n        side: Side.Ask,\n        amount,\n        minExchangeRate,\n        referral,\n        close,\n        fromMarket,\n        fromOpenOrders\n      });\n    } // Direct swap market explicitly given.\n\n\n    if (fromMarket !== undefined && toMarket === undefined) {\n      return await this.swapDirectTxs({\n        coinWallet: fromWallet,\n        pcWallet: toWallet,\n        baseMint: fromMint,\n        quoteMint: toMint,\n        side: fromMint.equals(fromMarket.baseMintAddress) ? Side.Ask : Side.Bid,\n        amount,\n        minExchangeRate,\n        referral,\n        close,\n        fromMarket,\n        fromOpenOrders\n      });\n    } // Neither wallet is a USD stable coin. So perform a transitive swap.\n\n\n    if (!quoteMint) {\n      throw new Error('quoteMint must be provided for a transitive swap');\n    }\n\n    if (!toMarket) {\n      throw new Error('toMarket must be provided for transitive swaps');\n    }\n\n    return await this.swapTransitiveTxs({\n      fromMint,\n      toMint,\n      pcMint: quoteMint,\n      fromWallet,\n      toWallet,\n      pcWallet: quoteWallet,\n      amount,\n      minExchangeRate,\n      referral,\n      close,\n      fromMarket,\n      toMarket,\n      fromOpenOrders,\n      toOpenOrders\n    });\n  }\n\n  async swapDirectTxs({\n    coinWallet,\n    pcWallet,\n    baseMint,\n    quoteMint,\n    side,\n    amount,\n    minExchangeRate,\n    referral,\n    close,\n    fromMarket,\n    fromOpenOrders\n  }) {\n    const [vaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n    let openOrders = fromOpenOrders;\n    const needsOpenOrders = openOrders === undefined;\n    const tx = new web3_js_1.Transaction();\n    const signers = []; // If either wallet isn't given, then create the associated token account.\n\n    if (!coinWallet) {\n      coinWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, this.program.provider.wallet.publicKey);\n      tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, coinWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n    }\n\n    if (!pcWallet) {\n      pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, this.program.provider.wallet.publicKey);\n      tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n    } // Create the open orders account, if needed.\n\n\n    if (needsOpenOrders) {\n      const oo = web3_js_1.Keypair.generate();\n      signers.push(oo);\n      openOrders = oo.publicKey;\n      tx.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n    }\n\n    tx.add(this.program.instruction.swap(side, amount, minExchangeRate, {\n      accounts: {\n        market: {\n          market: fromMarket.address,\n          // @ts-ignore\n          requestQueue: fromMarket._decoded.requestQueue,\n          // @ts-ignore\n          eventQueue: fromMarket._decoded.eventQueue,\n          bids: fromMarket.bidsAddress,\n          asks: fromMarket.asksAddress,\n          // @ts-ignore\n          coinVault: fromMarket._decoded.baseVault,\n          // @ts-ignore\n          pcVault: fromMarket._decoded.quoteVault,\n          vaultSigner,\n          openOrders,\n          orderPayerTokenAccount: side.bid ? pcWallet : coinWallet,\n          coinWallet: coinWallet\n        },\n        pcWallet,\n        authority: this.program.provider.wallet.publicKey,\n        dexProgram: utils_1.DEX_PID,\n        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n        rent: spl_token_1.TOKEN_PROGRAM_ID\n      },\n      remainingAccounts: referral && [{\n        pubkey: referral,\n        isWritable: true,\n        isSigner: false\n      }]\n    })); // If an account was opened for this swap, then close it in the same\n    // transaction.\n\n    if (CLOSE_ENABLED && close && needsOpenOrders) {\n      tx.add(this.program.instruction.closeAccount({\n        accounts: {\n          openOrders,\n          authority: this.program.provider.wallet.publicKey,\n          destination: this.program.provider.wallet.publicKey,\n          market: fromMarket.address,\n          dexProgram: utils_1.DEX_PID\n        }\n      }));\n    }\n\n    return [{\n      tx,\n      signers\n    }];\n  }\n\n  async swapTransitiveTxs({\n    fromMint,\n    toMint,\n    pcMint,\n    fromWallet,\n    toWallet,\n    pcWallet,\n    amount,\n    minExchangeRate,\n    referral,\n    close,\n    fromMarket,\n    toMarket,\n    fromOpenOrders,\n    toOpenOrders\n  }) {\n    // If the open orders are undefined, assume they don't exist.\n    const fromNeedsOpenOrders = fromOpenOrders === undefined;\n    const toNeedsOpenOrders = toOpenOrders === undefined; // In the event the transaction would be over the transaction size limit,\n    // we break up the transaction into multiple and use `Provider.sendAll`\n    // as a workaround, providing a single user flow for the swap action.\n    //\n    // Alternatively, one could breakup the different actions here into explicit\n    // user flows. I.e., three separate flows for creating open orders\n    // counts, swapping, and closing open orders accounts. If choosing to do\n    // this, it's recommended to use the anchor generated client directly,\n    // instead of the client here.\n\n    let openOrdersTransaction = undefined;\n    const openOrdersSigners = [];\n    const swapTransaction = new web3_js_1.Transaction();\n    const swapSigners = [];\n    let closeTransaction = undefined;\n    const closeSigners = []; // Calculate the vault signers for each market.\n\n    const [fromVaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n    const [toVaultSigner] = await utils_1.getVaultOwnerAndNonce(toMarket.address); // If token accounts aren't given, create them.\n\n    if (!fromWallet) {\n      fromWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, this.program.provider.wallet.publicKey);\n      swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, fromWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n    }\n\n    if (!toWallet) {\n      toWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, this.program.provider.wallet.publicKey);\n      swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, toWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n    }\n\n    if (!pcWallet) {\n      pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, this.program.provider.wallet.publicKey);\n      swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n    } // Add instructions to create open orders, if needed.\n    //\n    // If creating open orders accounts on *both* from and to markets, then\n    // split out the create open orders instructions into their own transaction.\n\n\n    if (fromNeedsOpenOrders && toNeedsOpenOrders) {\n      openOrdersTransaction = new web3_js_1.Transaction();\n      const ooFrom = web3_js_1.Keypair.generate();\n      openOrdersSigners.push(ooFrom);\n      openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, ooFrom.publicKey, utils_1.DEX_PID));\n      fromOpenOrders = ooFrom.publicKey;\n      const ooTo = web3_js_1.Keypair.generate();\n      openOrdersSigners.push(ooTo);\n      openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, ooTo.publicKey, utils_1.DEX_PID));\n      toOpenOrders = ooTo.publicKey;\n      openOrdersTransaction.add(this.program.instruction.initAccount({\n        accounts: {\n          openOrders: ooFrom.publicKey,\n          authority: this.program.provider.wallet.publicKey,\n          market: fromMarket.address,\n          dexProgram: utils_1.DEX_PID,\n          rent: web3_js_1.SYSVAR_RENT_PUBKEY\n        }\n      }));\n      openOrdersTransaction.add(this.program.instruction.initAccount({\n        accounts: {\n          openOrders: ooTo.publicKey,\n          authority: this.program.provider.wallet.publicKey,\n          market: toMarket.address,\n          dexProgram: utils_1.DEX_PID,\n          rent: web3_js_1.SYSVAR_RENT_PUBKEY\n        }\n      }));\n    } else if (fromNeedsOpenOrders) {\n      const oo = web3_js_1.Keypair.generate();\n      swapSigners.push(oo);\n      swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n      fromOpenOrders = oo.publicKey;\n    } else if (toNeedsOpenOrders) {\n      const oo = web3_js_1.Keypair.generate();\n      swapSigners.push(oo);\n      swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n      toOpenOrders = oo.publicKey;\n    }\n\n    swapTransaction.add(this.program.instruction.swapTransitive(amount, minExchangeRate, {\n      accounts: {\n        from: {\n          market: fromMarket.address,\n          // @ts-ignore\n          requestQueue: fromMarket._decoded.requestQueue,\n          // @ts-ignore\n          eventQueue: fromMarket._decoded.eventQueue,\n          bids: fromMarket.bidsAddress,\n          asks: fromMarket.asksAddress,\n          // @ts-ignore\n          coinVault: fromMarket._decoded.baseVault,\n          // @ts-ignore\n          pcVault: fromMarket._decoded.quoteVault,\n          vaultSigner: fromVaultSigner,\n          openOrders: fromOpenOrders,\n          orderPayerTokenAccount: fromWallet,\n          coinWallet: fromWallet\n        },\n        to: {\n          market: toMarket.address,\n          // @ts-ignore\n          requestQueue: toMarket._decoded.requestQueue,\n          // @ts-ignore\n          eventQueue: toMarket._decoded.eventQueue,\n          bids: toMarket.bidsAddress,\n          asks: toMarket.asksAddress,\n          // @ts-ignore\n          coinVault: toMarket._decoded.baseVault,\n          // @ts-ignore\n          pcVault: toMarket._decoded.quoteVault,\n          vaultSigner: toVaultSigner,\n          openOrders: toOpenOrders,\n          orderPayerTokenAccount: pcWallet,\n          coinWallet: toWallet\n        },\n        pcWallet,\n        authority: this.program.provider.wallet.publicKey,\n        dexProgram: utils_1.DEX_PID,\n        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n        rent: spl_token_1.TOKEN_PROGRAM_ID\n      },\n      remainingAccounts: referral && [{\n        pubkey: referral,\n        isWritable: true,\n        isSigner: false\n      }]\n    }));\n\n    if (CLOSE_ENABLED && close && fromNeedsOpenOrders) {\n      closeTransaction = new web3_js_1.Transaction();\n      closeTransaction.add(this.program.instruction.closeAccount({\n        accounts: {\n          openOrders: fromOpenOrders,\n          authority: this.program.provider.wallet.publicKey,\n          destination: this.program.provider.wallet.publicKey,\n          market: fromMarket.address,\n          dexProgram: utils_1.DEX_PID\n        }\n      }));\n    }\n\n    if (CLOSE_ENABLED && close && toNeedsOpenOrders) {\n      if (!closeTransaction) {\n        closeTransaction = new web3_js_1.Transaction();\n      }\n\n      closeTransaction.add(this.program.instruction.closeAccount({\n        accounts: {\n          openOrders: toOpenOrders,\n          authority: this.program.provider.wallet.publicKey,\n          destination: this.program.provider.wallet.publicKey,\n          market: toMarket.address,\n          dexProgram: utils_1.DEX_PID\n        }\n      }));\n    }\n\n    const txs = [];\n\n    if (openOrdersTransaction !== undefined) {\n      txs.push({\n        tx: openOrdersTransaction,\n        signers: openOrdersSigners\n      });\n    }\n\n    txs.push({\n      tx: swapTransaction,\n      signers: swapSigners\n    });\n\n    if (closeTransaction !== undefined) {\n      txs.push({\n        tx: closeTransaction,\n        signers: closeSigners\n      });\n    }\n\n    return txs;\n  }\n\n}\n\nexports.Swap = Swap;\n\nfunction isUsdx(mint) {\n  return mint.equals(utils_1.USDC_PUBKEY) || mint.equals(utils_1.USDT_PUBKEY);\n}\n\nconst Side = {\n  Bid: {\n    bid: {}\n  },\n  Ask: {\n    ask: {}\n  }\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Swap = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst anchor_1 = require(\"@project-serum/anchor\");\nconst serum_1 = require(\"@project-serum/serum\");\nconst idl_1 = require(\"./idl\");\nconst utils_1 = require(\"./utils\");\nconst swap_markets_1 = __importDefault(require(\"./swap-markets\"));\n// Close account feature flag.\n//\n// TODO: enable once the DEX supports closing open orders accounts.\nconst CLOSE_ENABLED = false;\n/**\n *\n * # Swap\n *\n * A module to swap tokens across markets the Serum DEX, providing a thin\n * wrapper around an [Anchor](https://github.com/project-serum/anchor) client\n * for the purpose of providing a simplified `swap` API.\n *\n * ## Swap Program Basics\n *\n * One should have a basic understanding of the on-chain\n * [Swap](https://github.com/project-serum/swap) program before using the\n * client. Two core APIs are exposed.\n *\n * * [swap](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L36) -\n *   swaps two tokens on a single A/B market. This is just an IOC trade at the\n *   BBO that instantly settles.\n * * [swapTransitive](https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L107) -\n *   swaps two tokens across **two** A/x, B/x markets in the same manner as\n *   `swap`.\n *\n * For both APIs, if the number of tokens received from the trade is less than\n * the client provided `minExchangeRate`, the transaction aborts.\n *\n * Note that if this client package is insufficient, one can always use the\n * Anchor generated client directly, exposing an API mapping one-to-one to\n * these program instructions. See the\n * [`tests/`](https://github.com/project-serum/swap/blob/master/tests/swap.js)\n * for examples of using the Anchor generated swap client.\n *\n * ## Serum Orderbook Program Basics\n *\n * Additionally, because the Swap program is an on-chain frontend for the Serum\n * DEX, one should also be aware of the basic accounts needed for trading on\n * the Serum DEX.\n *\n * Namely, a wallet must have an \"open orders\" account for each market the\n * wallet trades on. The \"open orders\" account is akin to how a wallet\n *  must have an SPL token account to own tokens, except instead of holding\n * tokens, the wallet can make trades on the orderbook.\n *\n * ### Creating Open Orders Accounts\n *\n * When the wallet doesn't have an open orders account already created,\n * the swap client provides two choices. Automatically create the required\n * accounts by preloading the instructions in the [[swap]] transaction.\n *\n * Note that if the user is swapping between two non-USD(x) tokens, e.g., wBTC\n * for wETH, then the user needs *two* open orders accounts on both wBTC/USD(x)\n * and wETH/USD(x) markets. In the event both of these open orders accounts are\n * created for the rfirst time, then the transaction is broken up into two\n * (and `Provider.sendAll` is used) to prevent hitting transaction size limits.\n */\nclass Swap {\n    /**\n     * @param provider  The wallet and network context to use for the client.\n     * @param tokenList The token list providing market addresses for each mint.\n     */\n    constructor(provider, tokenList) {\n        this._program = new anchor_1.Program(idl_1.IDL, utils_1.SWAP_PID, provider);\n        this._swapMarkets = new swap_markets_1.default(provider, tokenList);\n    }\n    /**\n     * Anchor generated client for the swap program.\n     */\n    get program() {\n        return this._program;\n    }\n    /**\n     * Token list registry for fetching USD(x) markets for each mint.\n     */\n    get swapMarkets() {\n        return this._swapMarkets;\n    }\n    /**\n     * Returns a list of markets to trade across to swap `fromMint` to `toMint`.\n     */\n    route(fromMint, toMint) {\n        return this.swapMarkets.route(fromMint, toMint);\n    }\n    /**\n     * Executes a swap against the Serum DEX.\n     */\n    async swap(params) {\n        const pk = this.program.provider.wallet.publicKey;\n        if (!pk || web3_js_1.PublicKey.default.equals(pk)) {\n            throw new Error('Wallet not found');\n        }\n        let txs = await this.swapTxs(params);\n        if (params.additionalTransactions) {\n            txs = txs.concat(params.additionalTransactions);\n        }\n        return this.program.provider.sendAll(txs, params.options);\n    }\n    /**\n     * Returns transactions for swapping on the Serum DEX.\n     */\n    async swapTxs(params) {\n        let { fromMint, toMint, quoteWallet, fromWallet, toWallet, quoteMint, fromMarket, toMarket, amount, minExchangeRate, referral, close, fromOpenOrders, toOpenOrders, } = params;\n        // If swapping to/from a USD(x) token, then swap directly on the market.\n        if (isUsdx(fromMint)) {\n            let coinWallet = toWallet;\n            let pcWallet = fromWallet;\n            let baseMint = toMint;\n            let quoteMint = fromMint;\n            let side = Side.Bid;\n            // Special case USDT/USDC market since the coin is always USDT and\n            // the pc is always USDC.\n            if (toMint.equals(utils_1.USDC_PUBKEY)) {\n                coinWallet = fromWallet;\n                pcWallet = toWallet;\n                baseMint = fromMint;\n                quoteMint = toMint;\n                side = Side.Ask;\n            }\n            else if (toMint.equals(utils_1.USDT_PUBKEY)) {\n                coinWallet = toWallet;\n                pcWallet = fromWallet;\n                baseMint = toMint;\n                quoteMint = quoteMint;\n                side = Side.Bid;\n            }\n            return await this.swapDirectTxs({\n                coinWallet,\n                pcWallet,\n                baseMint,\n                quoteMint,\n                side,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        else if (isUsdx(toMint)) {\n            return await this.swapDirectTxs({\n                coinWallet: fromWallet,\n                pcWallet: toWallet,\n                baseMint: fromMint,\n                quoteMint: toMint,\n                side: Side.Ask,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        // Direct swap market explicitly given.\n        if (fromMarket !== undefined && toMarket === undefined) {\n            return await this.swapDirectTxs({\n                coinWallet: fromWallet,\n                pcWallet: toWallet,\n                baseMint: fromMint,\n                quoteMint: toMint,\n                side: fromMint.equals(fromMarket.baseMintAddress) ? Side.Ask : Side.Bid,\n                amount,\n                minExchangeRate,\n                referral,\n                close,\n                fromMarket,\n                fromOpenOrders,\n            });\n        }\n        // Neither wallet is a USD stable coin. So perform a transitive swap.\n        if (!quoteMint) {\n            throw new Error('quoteMint must be provided for a transitive swap');\n        }\n        if (!toMarket) {\n            throw new Error('toMarket must be provided for transitive swaps');\n        }\n        return await this.swapTransitiveTxs({\n            fromMint,\n            toMint,\n            pcMint: quoteMint,\n            fromWallet,\n            toWallet,\n            pcWallet: quoteWallet,\n            amount,\n            minExchangeRate,\n            referral,\n            close,\n            fromMarket,\n            toMarket,\n            fromOpenOrders,\n            toOpenOrders,\n        });\n    }\n    async swapDirectTxs({ coinWallet, pcWallet, baseMint, quoteMint, side, amount, minExchangeRate, referral, close, fromMarket, fromOpenOrders, }) {\n        const [vaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n        let openOrders = fromOpenOrders;\n        const needsOpenOrders = openOrders === undefined;\n        const tx = new web3_js_1.Transaction();\n        const signers = [];\n        // If either wallet isn't given, then create the associated token account.\n        if (!coinWallet) {\n            coinWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, this.program.provider.wallet.publicKey);\n            tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, baseMint, coinWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!pcWallet) {\n            pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, this.program.provider.wallet.publicKey);\n            tx.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        // Create the open orders account, if needed.\n        if (needsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            signers.push(oo);\n            openOrders = oo.publicKey;\n            tx.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n        }\n        tx.add(this.program.instruction.swap(side, amount, minExchangeRate, {\n            accounts: {\n                market: {\n                    market: fromMarket.address,\n                    // @ts-ignore\n                    requestQueue: fromMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: fromMarket._decoded.eventQueue,\n                    bids: fromMarket.bidsAddress,\n                    asks: fromMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: fromMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: fromMarket._decoded.quoteVault,\n                    vaultSigner,\n                    openOrders,\n                    orderPayerTokenAccount: side.bid ? pcWallet : coinWallet,\n                    coinWallet: coinWallet,\n                },\n                pcWallet,\n                authority: this.program.provider.wallet.publicKey,\n                dexProgram: utils_1.DEX_PID,\n                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                rent: spl_token_1.TOKEN_PROGRAM_ID,\n            },\n            remainingAccounts: referral && [\n                { pubkey: referral, isWritable: true, isSigner: false },\n            ],\n        }));\n        // If an account was opened for this swap, then close it in the same\n        // transaction.\n        if (CLOSE_ENABLED && close && needsOpenOrders) {\n            tx.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        return [{ tx, signers }];\n    }\n    async swapTransitiveTxs({ fromMint, toMint, pcMint, fromWallet, toWallet, pcWallet, amount, minExchangeRate, referral, close, fromMarket, toMarket, fromOpenOrders, toOpenOrders, }) {\n        // If the open orders are undefined, assume they don't exist.\n        const fromNeedsOpenOrders = fromOpenOrders === undefined;\n        const toNeedsOpenOrders = toOpenOrders === undefined;\n        // In the event the transaction would be over the transaction size limit,\n        // we break up the transaction into multiple and use `Provider.sendAll`\n        // as a workaround, providing a single user flow for the swap action.\n        //\n        // Alternatively, one could breakup the different actions here into explicit\n        // user flows. I.e., three separate flows for creating open orders\n        // counts, swapping, and closing open orders accounts. If choosing to do\n        // this, it's recommended to use the anchor generated client directly,\n        // instead of the client here.\n        let openOrdersTransaction = undefined;\n        const openOrdersSigners = [];\n        const swapTransaction = new web3_js_1.Transaction();\n        const swapSigners = [];\n        let closeTransaction = undefined;\n        const closeSigners = [];\n        // Calculate the vault signers for each market.\n        const [fromVaultSigner] = await utils_1.getVaultOwnerAndNonce(fromMarket.address);\n        const [toVaultSigner] = await utils_1.getVaultOwnerAndNonce(toMarket.address);\n        // If token accounts aren't given, create them.\n        if (!fromWallet) {\n            fromWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fromMint, fromWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!toWallet) {\n            toWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, toMint, toWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        if (!pcWallet) {\n            pcWallet = await utils_1.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, this.program.provider.wallet.publicKey);\n            swapTransaction.add(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, pcMint, pcWallet, this.program.provider.wallet.publicKey, this.program.provider.wallet.publicKey));\n        }\n        // Add instructions to create open orders, if needed.\n        //\n        // If creating open orders accounts on *both* from and to markets, then\n        // split out the create open orders instructions into their own transaction.\n        if (fromNeedsOpenOrders && toNeedsOpenOrders) {\n            openOrdersTransaction = new web3_js_1.Transaction();\n            const ooFrom = web3_js_1.Keypair.generate();\n            openOrdersSigners.push(ooFrom);\n            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, ooFrom.publicKey, utils_1.DEX_PID));\n            fromOpenOrders = ooFrom.publicKey;\n            const ooTo = web3_js_1.Keypair.generate();\n            openOrdersSigners.push(ooTo);\n            openOrdersTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, ooTo.publicKey, utils_1.DEX_PID));\n            toOpenOrders = ooTo.publicKey;\n            openOrdersTransaction.add(this.program.instruction.initAccount({\n                accounts: {\n                    openOrders: ooFrom.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,\n                },\n            }));\n            openOrdersTransaction.add(this.program.instruction.initAccount({\n                accounts: {\n                    openOrders: ooTo.publicKey,\n                    authority: this.program.provider.wallet.publicKey,\n                    market: toMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,\n                },\n            }));\n        }\n        else if (fromNeedsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            swapSigners.push(oo);\n            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, fromMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n            fromOpenOrders = oo.publicKey;\n        }\n        else if (toNeedsOpenOrders) {\n            const oo = web3_js_1.Keypair.generate();\n            swapSigners.push(oo);\n            swapTransaction.add(await serum_1.OpenOrders.makeCreateAccountTransaction(this.program.provider.connection, toMarket.address, this.program.provider.wallet.publicKey, oo.publicKey, utils_1.DEX_PID));\n            toOpenOrders = oo.publicKey;\n        }\n        swapTransaction.add(this.program.instruction.swapTransitive(amount, minExchangeRate, {\n            accounts: {\n                from: {\n                    market: fromMarket.address,\n                    // @ts-ignore\n                    requestQueue: fromMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: fromMarket._decoded.eventQueue,\n                    bids: fromMarket.bidsAddress,\n                    asks: fromMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: fromMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: fromMarket._decoded.quoteVault,\n                    vaultSigner: fromVaultSigner,\n                    openOrders: fromOpenOrders,\n                    orderPayerTokenAccount: fromWallet,\n                    coinWallet: fromWallet,\n                },\n                to: {\n                    market: toMarket.address,\n                    // @ts-ignore\n                    requestQueue: toMarket._decoded.requestQueue,\n                    // @ts-ignore\n                    eventQueue: toMarket._decoded.eventQueue,\n                    bids: toMarket.bidsAddress,\n                    asks: toMarket.asksAddress,\n                    // @ts-ignore\n                    coinVault: toMarket._decoded.baseVault,\n                    // @ts-ignore\n                    pcVault: toMarket._decoded.quoteVault,\n                    vaultSigner: toVaultSigner,\n                    openOrders: toOpenOrders,\n                    orderPayerTokenAccount: pcWallet,\n                    coinWallet: toWallet,\n                },\n                pcWallet,\n                authority: this.program.provider.wallet.publicKey,\n                dexProgram: utils_1.DEX_PID,\n                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,\n                rent: spl_token_1.TOKEN_PROGRAM_ID,\n            },\n            remainingAccounts: referral && [\n                { pubkey: referral, isWritable: true, isSigner: false },\n            ],\n        }));\n        if (CLOSE_ENABLED && close && fromNeedsOpenOrders) {\n            closeTransaction = new web3_js_1.Transaction();\n            closeTransaction.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders: fromOpenOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: fromMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        if (CLOSE_ENABLED && close && toNeedsOpenOrders) {\n            if (!closeTransaction) {\n                closeTransaction = new web3_js_1.Transaction();\n            }\n            closeTransaction.add(this.program.instruction.closeAccount({\n                accounts: {\n                    openOrders: toOpenOrders,\n                    authority: this.program.provider.wallet.publicKey,\n                    destination: this.program.provider.wallet.publicKey,\n                    market: toMarket.address,\n                    dexProgram: utils_1.DEX_PID,\n                },\n            }));\n        }\n        const txs = [];\n        if (openOrdersTransaction !== undefined) {\n            txs.push({ tx: openOrdersTransaction, signers: openOrdersSigners });\n        }\n        txs.push({ tx: swapTransaction, signers: swapSigners });\n        if (closeTransaction !== undefined) {\n            txs.push({ tx: closeTransaction, signers: closeSigners });\n        }\n        return txs;\n    }\n}\nexports.Swap = Swap;\nfunction isUsdx(mint) {\n    return mint.equals(utils_1.USDC_PUBKEY) || mint.equals(utils_1.USDT_PUBKEY);\n}\nconst Side = {\n    Bid: { bid: {} },\n    Ask: { ask: {} },\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}