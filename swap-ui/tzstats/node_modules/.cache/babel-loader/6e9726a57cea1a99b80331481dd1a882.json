{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useAsync } from \"react-async-hook\";\nimport { PublicKey } from \"@solana/web3.js\"; // Token info tracked by the sollet bridge.\n\nexport function useSolletInfo(mint) {\n  _s();\n\n  return useAsync(async () => {\n    return fetchSolletInfo(mint);\n  }, [mint]);\n} // Fetches the token info from the sollet bridge.\n\n_s(useSolletInfo, \"zwAEN0BKe16JtgYZhCKw4wlfBzA=\", false, function () {\n  return [useAsync];\n});\n\nexport async function fetchSolletInfo(mint) {\n  let info = _SOLLET_INFO_CACHE.get(mint.toString());\n\n  if (info !== undefined) {\n    return info;\n  }\n\n  const infoRaw = await swapApiRequest(\"GET\", `coins/sol/${mint.toString()}`);\n  info = { ...infoRaw,\n    splMint: new PublicKey(infoRaw.splMint)\n  };\n\n  _SOLLET_INFO_CACHE.set(mint.toString(), info);\n\n  return info;\n} // Requests the creation of a sollet wormhole swap market, if it doesn't\n// already exist. Note: this triggers a creation notification. Creation\n// doesn't happen immediately, but at some unspecified point in the future\n// since market makers need to setup on the swap market and provide liquidity.\n//\n// Returns true if the market exists already. False otherwise.\n\nexport async function requestWormholeSwapMarketIfNeeded(connection, solletMint, wormholeMint, swapMarket, solletInfo) {\n  const cached = _SWAP_MARKET_EXISTS_CACHE.get(swapMarket.toString());\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const acc = await connection.getAccountInfo(swapMarket);\n\n  if (acc === null) {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), false);\n\n    const resource = `wormhole/pool/${solletInfo.ticker}/${swapMarket.toString()}/${solletMint.toString()}/${wormholeMint.toString()}`;\n    swapApiRequest(\"POST\", resource).catch(console.error);\n    return false;\n  } else {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), true);\n\n    return true;\n  }\n}\nexport async function swapApiRequest(method, path, body) {\n  let headers = {};\n  let params = {\n    headers,\n    method\n  };\n\n  if (method === \"GET\") {\n    params.cache = \"no-cache\";\n  } else if (body) {\n    headers[\"Content-Type\"] = \"application/json\";\n    params.body = JSON.stringify(body);\n  }\n\n  let resp = await fetch(`https://swap.sollet.io/api/${path}`, params);\n  return await handleSwapApiResponse(resp);\n}\n\nasync function handleSwapApiResponse(resp) {\n  let json = await resp.json();\n\n  if (!json.success) {\n    throw new SwapApiError(json.error, resp.status);\n  }\n\n  return json.result;\n}\n\nexport class SwapApiError extends Error {\n  constructor(msg, status) {\n    super(msg);\n    this.name = void 0;\n    this.status = void 0;\n    this.name = \"SwapApiError\";\n    this.status = status;\n  }\n\n}\n\nconst _SOLLET_INFO_CACHE = new Map();\n\nconst _SWAP_MARKET_EXISTS_CACHE = new Map();","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Sollet.tsx"],"names":["useAsync","PublicKey","useSolletInfo","mint","fetchSolletInfo","info","_SOLLET_INFO_CACHE","get","toString","undefined","infoRaw","swapApiRequest","splMint","set","requestWormholeSwapMarketIfNeeded","connection","solletMint","wormholeMint","swapMarket","solletInfo","cached","_SWAP_MARKET_EXISTS_CACHE","acc","getAccountInfo","resource","ticker","catch","console","error","method","path","body","headers","params","cache","JSON","stringify","resp","fetch","handleSwapApiResponse","json","success","SwapApiError","status","result","Error","constructor","msg","name","Map"],"mappings":"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","sourcesContent":["import { useAsync, UseAsyncReturn } from \"react-async-hook\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Token info tracked by the sollet bridge.\ntype SolletInfo = {\n  blockchain: string;\n  erc20Contract: string;\n  name: string;\n  splMint: PublicKey;\n  ticker: string;\n};\n\nexport function useSolletInfo(mint: PublicKey): UseAsyncReturn<SolletInfo> {\n  return useAsync(async () => {\n    return fetchSolletInfo(mint);\n  }, [mint]);\n}\n\n// Fetches the token info from the sollet bridge.\nexport async function fetchSolletInfo(mint: PublicKey): Promise<SolletInfo> {\n  let info = _SOLLET_INFO_CACHE.get(mint.toString());\n  if (info !== undefined) {\n    return info;\n  }\n\n  const infoRaw = await swapApiRequest(\"GET\", `coins/sol/${mint.toString()}`);\n  info = { ...infoRaw, splMint: new PublicKey(infoRaw.splMint) };\n  _SOLLET_INFO_CACHE.set(mint.toString(), info!);\n\n  return info!;\n}\n\n// Requests the creation of a sollet wormhole swap market, if it doesn't\n// already exist. Note: this triggers a creation notification. Creation\n// doesn't happen immediately, but at some unspecified point in the future\n// since market makers need to setup on the swap market and provide liquidity.\n//\n// Returns true if the market exists already. False otherwise.\nexport async function requestWormholeSwapMarketIfNeeded(\n  connection: Connection,\n  solletMint: PublicKey,\n  wormholeMint: PublicKey,\n  swapMarket: PublicKey,\n  solletInfo: SolletInfo\n): Promise<boolean> {\n  const cached = _SWAP_MARKET_EXISTS_CACHE.get(swapMarket.toString());\n  if (cached !== undefined) {\n    return cached;\n  }\n  const acc = await connection.getAccountInfo(swapMarket);\n  if (acc === null) {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), false);\n    const resource = `wormhole/pool/${\n      solletInfo.ticker\n    }/${swapMarket.toString()}/${solletMint.toString()}/${wormholeMint.toString()}`;\n    swapApiRequest(\"POST\", resource).catch(console.error);\n    return false;\n  } else {\n    _SWAP_MARKET_EXISTS_CACHE.set(swapMarket.toString(), true);\n    return true;\n  }\n}\n\nexport async function swapApiRequest(\n  method: string,\n  path: string,\n  body?: Object\n) {\n  let headers: any = {};\n  let params: any = { headers, method };\n  if (method === \"GET\") {\n    params.cache = \"no-cache\";\n  } else if (body) {\n    headers[\"Content-Type\"] = \"application/json\";\n    params.body = JSON.stringify(body);\n  }\n  let resp = await fetch(`https://swap.sollet.io/api/${path}`, params);\n  return await handleSwapApiResponse(resp);\n}\n\nasync function handleSwapApiResponse(resp: Response) {\n  let json = await resp.json();\n  if (!json.success) {\n    throw new SwapApiError(json.error, resp.status);\n  }\n  return json.result;\n}\n\nexport class SwapApiError extends Error {\n  readonly name: string;\n  readonly status: number;\n  constructor(msg: string, status: number) {\n    super(msg);\n    this.name = \"SwapApiError\";\n    this.status = status;\n  }\n}\n\nconst _SOLLET_INFO_CACHE = new Map<string, SolletInfo>();\nconst _SWAP_MARKET_EXISTS_CACHE = new Map<string, boolean>();\n"]},"metadata":{},"sourceType":"module"}