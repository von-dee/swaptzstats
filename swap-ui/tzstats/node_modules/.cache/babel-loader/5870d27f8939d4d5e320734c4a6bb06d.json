{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Swap.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport * as assert from \"assert\";\nimport React, { useContext, useState, useEffect } from \"react\";\nimport { useAsync } from \"react-async-hook\";\nimport { Token, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { SRM_MINT, USDC_MINT, USDT_MINT } from \"../utils/pubkeys\";\nimport { useFairRoute, useRouteVerbose, useDexContext, FEE_MULTIPLIER } from \"./Dex\";\nimport { useTokenListContext, SPL_REGISTRY_SOLLET_TAG, SPL_REGISTRY_WORM_TAG } from \"./TokenList\";\nimport { useOwnedTokenAccount } from \"../context/Token\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_SLIPPAGE_PERCENT = 0.5;\n\nconst _SwapContext = /*#__PURE__*/React.createContext(null);\n\nexport function SwapContextProvider(props) {\n  _s();\n\n  var _props$fromMint, _props$toMint, _props$fromAmount, _props$toAmount;\n\n  const [fromMint, setFromMint] = useState((_props$fromMint = props.fromMint) !== null && _props$fromMint !== void 0 ? _props$fromMint : SRM_MINT);\n  const [toMint, setToMint] = useState((_props$toMint = props.toMint) !== null && _props$toMint !== void 0 ? _props$toMint : USDC_MINT);\n  const [fromAmount, _setFromAmount] = useState((_props$fromAmount = props.fromAmount) !== null && _props$fromAmount !== void 0 ? _props$fromAmount : 0);\n  const [toAmount, _setToAmount] = useState((_props$toAmount = props.toAmount) !== null && _props$toAmount !== void 0 ? _props$toAmount : 0);\n  const [isClosingNewAccounts, setIsClosingNewAccounts] = useState(false);\n  const [isStrict, setIsStrict] = useState(false);\n  const [slippage, setSlippage] = useState(DEFAULT_SLIPPAGE_PERCENT);\n  const [fairOverride, setFairOverride] = useState(null);\n\n  const fair = _useSwapFair(fromMint, toMint, fairOverride);\n\n  const referral = props.referral;\n  assert.ok(slippage >= 0);\n  useEffect(() => {\n    if (!fair) {\n      return;\n    }\n\n    setFromAmount(fromAmount);\n  }, [fair]);\n\n  const swapToFromMints = () => {\n    const oldFrom = fromMint;\n    const oldTo = toMint;\n    const oldToAmount = toAmount;\n\n    _setFromAmount(oldToAmount);\n\n    setFromMint(oldTo);\n    setToMint(oldFrom);\n  };\n\n  const setFromAmount = amount => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n\n      _setToAmount(0);\n\n      return;\n    }\n\n    _setFromAmount(amount);\n\n    _setToAmount(FEE_MULTIPLIER * (amount / fair));\n  };\n\n  const setToAmount = amount => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n\n      _setToAmount(0);\n\n      return;\n    }\n\n    _setToAmount(amount);\n\n    _setFromAmount(amount * fair / FEE_MULTIPLIER);\n  };\n\n  return /*#__PURE__*/_jsxDEV(_SwapContext.Provider, {\n    value: {\n      fromMint,\n      setFromMint,\n      toMint,\n      setToMint,\n      fromAmount,\n      setFromAmount,\n      toAmount,\n      setToAmount,\n      swapToFromMints,\n      slippage,\n      setSlippage,\n      fairOverride,\n      setFairOverride,\n      isClosingNewAccounts,\n      isStrict,\n      setIsStrict,\n      setIsClosingNewAccounts,\n      referral\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 129,\n    columnNumber: 5\n  }, this);\n}\n\n_s(SwapContextProvider, \"+0GtEQ/uxmnz1WELI1DUWf+0fr4=\");\n\n_c = SwapContextProvider;\nexport function useSwapContext() {\n  _s2();\n\n  const ctx = useContext(_SwapContext);\n\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n\n  return ctx;\n}\n\n_s2(useSwapContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\n\nexport function useSwapFair() {\n  _s3();\n\n  const {\n    fairOverride,\n    fromMint,\n    toMint\n  } = useSwapContext();\n  return _useSwapFair(fromMint, toMint, fairOverride);\n}\n\n_s3(useSwapFair, \"O2Edy4KlWc0cEHXR/9udH3QoWus=\", false, function () {\n  return [useSwapContext];\n});\n\nfunction _useSwapFair(fromMint, toMint, fairOverride) {\n  _s4();\n\n  const fairRoute = useFairRoute(fromMint, toMint);\n  const fair = fairOverride === null ? fairRoute : fairOverride;\n  return fair;\n} // Returns true if the user can swap with the current context.\n\n\n_s4(_useSwapFair, \"uybj59RGsn+ZdqR+4//70pEIvbI=\", false, function () {\n  return [useFairRoute];\n});\n\nexport function useCanSwap() {\n  _s5();\n\n  var _wormholeMap$get, _wormholeMap$get$tags, _solletMap$get, _solletMap$get$tags;\n\n  const {\n    fromMint,\n    toMint,\n    fromAmount,\n    toAmount\n  } = useSwapContext();\n  const {\n    swapClient\n  } = useDexContext();\n  const {\n    wormholeMap,\n    solletMap\n  } = useTokenListContext();\n  const fromWallet = useOwnedTokenAccount(fromMint);\n  const fair = useSwapFair();\n  const route = useRouteVerbose(fromMint, toMint);\n\n  if (route === null) {\n    return false;\n  }\n\n  return (// From wallet exists.\n    fromWallet !== undefined && fromWallet !== null && // Fair price is defined.\n    fair !== undefined && fair > 0 && // Mints are distinct.\n    fromMint.equals(toMint) === false && // Wallet is connected.\n    swapClient.program.provider.wallet.publicKey !== null && // Trade amounts greater than zero.\n    fromAmount > 0 && toAmount > 0 && // Trade route exists.\n    route !== null && (route.kind !== \"wormhole-native\" || ((_wormholeMap$get = wormholeMap.get(fromMint.toString())) === null || _wormholeMap$get === void 0 ? void 0 : (_wormholeMap$get$tags = _wormholeMap$get.tags) === null || _wormholeMap$get$tags === void 0 ? void 0 : _wormholeMap$get$tags.includes(SPL_REGISTRY_WORM_TAG)) !== undefined) && (route.kind !== \"wormhole-sollet\" || ((_solletMap$get = solletMap.get(fromMint.toString())) === null || _solletMap$get === void 0 ? void 0 : (_solletMap$get$tags = _solletMap$get.tags) === null || _solletMap$get$tags === void 0 ? void 0 : _solletMap$get$tags.includes(SPL_REGISTRY_SOLLET_TAG)) !== undefined)\n  );\n}\n\n_s5(useCanSwap, \"jZjOrlg7vQVpoPE4DfwbOaonq/w=\", false, function () {\n  return [useSwapContext, useDexContext, useTokenListContext, useOwnedTokenAccount, useSwapFair, useRouteVerbose];\n});\n\nexport function useReferral(fromMarket) {\n  _s6();\n\n  const {\n    referral\n  } = useSwapContext();\n  const asyncReferral = useAsync(async () => {\n    if (!referral) {\n      return undefined;\n    }\n\n    if (!fromMarket) {\n      return undefined;\n    }\n\n    if (!fromMarket.quoteMintAddress.equals(USDC_MINT) && !fromMarket.quoteMintAddress.equals(USDT_MINT)) {\n      return undefined;\n    }\n\n    return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, fromMarket.quoteMintAddress, referral);\n  }, [fromMarket]);\n\n  if (!asyncReferral.result) {\n    return undefined;\n  }\n\n  return asyncReferral.result;\n}\n\n_s6(useReferral, \"PJAIazkSSkWB1XeQNPGnoaRglEg=\", false, function () {\n  return [useSwapContext, useAsync];\n});\n\nvar _c;\n\n$RefreshReg$(_c, \"SwapContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Swap.tsx"],"names":["assert","React","useContext","useState","useEffect","useAsync","Token","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","SRM_MINT","USDC_MINT","USDT_MINT","useFairRoute","useRouteVerbose","useDexContext","FEE_MULTIPLIER","useTokenListContext","SPL_REGISTRY_SOLLET_TAG","SPL_REGISTRY_WORM_TAG","useOwnedTokenAccount","DEFAULT_SLIPPAGE_PERCENT","_SwapContext","createContext","SwapContextProvider","props","fromMint","setFromMint","toMint","setToMint","fromAmount","_setFromAmount","toAmount","_setToAmount","isClosingNewAccounts","setIsClosingNewAccounts","isStrict","setIsStrict","slippage","setSlippage","fairOverride","setFairOverride","fair","_useSwapFair","referral","ok","setFromAmount","swapToFromMints","oldFrom","oldTo","oldToAmount","amount","undefined","setToAmount","children","useSwapContext","ctx","Error","useSwapFair","fairRoute","useCanSwap","swapClient","wormholeMap","solletMap","fromWallet","route","equals","program","provider","wallet","publicKey","kind","get","toString","tags","includes","useReferral","fromMarket","asyncReferral","quoteMintAddress","getAssociatedTokenAddress","result"],"mappings":"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","sourcesContent":["import * as assert from \"assert\";\nimport React, { useContext, useState, useEffect } from \"react\";\nimport { useAsync } from \"react-async-hook\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport {\n  Token,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Market } from \"@project-serum/serum\";\nimport { SRM_MINT, USDC_MINT, USDT_MINT, TEZ_MINT, QUP_MINT } from \"../utils/pubkeys\";\nimport {\n  useFairRoute,\n  useRouteVerbose,\n  useDexContext,\n  FEE_MULTIPLIER,\n} from \"./Dex\";\nimport {\n  useTokenListContext,\n  SPL_REGISTRY_SOLLET_TAG,\n  SPL_REGISTRY_WORM_TAG,\n} from \"./TokenList\";\nimport { useOwnedTokenAccount } from \"../context/Token\";\n\nconst DEFAULT_SLIPPAGE_PERCENT = 0.5;\n\nexport type SwapContext = {\n  // Mint being traded from. The user must own these tokens.\n  fromMint: PublicKey;\n  setFromMint: (m: PublicKey) => void;\n\n  // Mint being traded to. The user will receive these tokens after the swap.\n  toMint: PublicKey;\n  setToMint: (m: PublicKey) => void;\n\n  // Amount used for the swap.\n  fromAmount: number;\n  setFromAmount: (a: number) => void;\n\n  // *Expected* amount received from the swap.\n  toAmount: number;\n  setToAmount: (a: number) => void;\n\n  // Function to flip what we consider to be the \"to\" and \"from\" mints.\n  swapToFromMints: () => void;\n\n  // The amount (in units of percent) a swap can be off from the estimate\n  // shown to the user.\n  slippage: number;\n  setSlippage: (n: number) => void;\n\n  // Null if the user is using fairs directly from DEX prices.\n  // Otherwise, a user specified override for the price to use when calculating\n  // swap amounts.\n  fairOverride: number | null;\n  setFairOverride: (n: number | null) => void;\n\n  // The referral *owner* address. Associated token accounts must be created,\n  // first, for this to be used.\n  referral?: PublicKey;\n\n  // True if all newly created market accounts should be closed in the\n  // same user flow (ideally in the same transaction).\n  isClosingNewAccounts: boolean;\n\n  // True if the swap exchange rate should be a function of nothing but the\n  // from and to tokens, ignoring any quote tokens that may have been\n  // accumulated by performing the swap.\n  //\n  // Always false (for now).\n  isStrict: boolean;\n  setIsStrict: (isStrict: boolean) => void;\n\n  setIsClosingNewAccounts: (b: boolean) => void;\n};\nconst _SwapContext = React.createContext<null | SwapContext>(null);\n\nexport function SwapContextProvider(props: any) {\n  const [fromMint, setFromMint] = useState(props.fromMint ?? SRM_MINT);\n  const [toMint, setToMint] = useState(props.toMint ?? USDC_MINT);\n  const [fromAmount, _setFromAmount] = useState(props.fromAmount ?? 0);\n  const [toAmount, _setToAmount] = useState(props.toAmount ?? 0);\n  const [isClosingNewAccounts, setIsClosingNewAccounts] = useState(false);\n  const [isStrict, setIsStrict] = useState(false);\n  const [slippage, setSlippage] = useState(DEFAULT_SLIPPAGE_PERCENT);\n  const [fairOverride, setFairOverride] = useState<number | null>(null);\n  const fair = _useSwapFair(fromMint, toMint, fairOverride);\n  const referral = props.referral;\n\n  assert.ok(slippage >= 0);\n\n  useEffect(() => {\n    if (!fair) {\n      return;\n    }\n    setFromAmount(fromAmount);\n  }, [fair]);\n\n  const swapToFromMints = () => {\n    const oldFrom = fromMint;\n    const oldTo = toMint;\n    const oldToAmount = toAmount;\n    _setFromAmount(oldToAmount);\n    setFromMint(oldTo);\n    setToMint(oldFrom);\n  };\n\n  const setFromAmount = (amount: number) => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n      _setToAmount(0);\n      return;\n    }\n    _setFromAmount(amount);\n    _setToAmount(FEE_MULTIPLIER * (amount / fair));\n  };\n\n  const setToAmount = (amount: number) => {\n    if (fair === undefined) {\n      _setFromAmount(0);\n      _setToAmount(0);\n      return;\n    }\n    _setToAmount(amount);\n    _setFromAmount((amount * fair) / FEE_MULTIPLIER);\n  };\n\n  return (\n    <_SwapContext.Provider\n      value={{\n        fromMint,\n        setFromMint,\n        toMint,\n        setToMint,\n        fromAmount,\n        setFromAmount,\n        toAmount,\n        setToAmount,\n        swapToFromMints,\n        slippage,\n        setSlippage,\n        fairOverride,\n        setFairOverride,\n        isClosingNewAccounts,\n        isStrict,\n        setIsStrict,\n        setIsClosingNewAccounts,\n        referral,\n      }}\n    >\n      {props.children}\n    </_SwapContext.Provider>\n  );\n}\n\nexport function useSwapContext(): SwapContext {\n  const ctx = useContext(_SwapContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useSwapFair(): number | undefined {\n  const { fairOverride, fromMint, toMint } = useSwapContext();\n  return _useSwapFair(fromMint, toMint, fairOverride);\n}\n\nfunction _useSwapFair(\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  fairOverride: number | null\n): number | undefined {\n  const fairRoute = useFairRoute(fromMint, toMint);\n  const fair = fairOverride === null ? fairRoute : fairOverride;\n  return fair;\n}\n\n// Returns true if the user can swap with the current context.\nexport function useCanSwap(): boolean {\n  const { fromMint, toMint, fromAmount, toAmount } = useSwapContext();\n  const { swapClient } = useDexContext();\n  const { wormholeMap, solletMap } = useTokenListContext();\n  const fromWallet = useOwnedTokenAccount(fromMint);\n  const fair = useSwapFair();\n  const route = useRouteVerbose(fromMint, toMint);\n  if (route === null) {\n    return false;\n  }\n\n  return (\n    // From wallet exists.\n    fromWallet !== undefined &&\n    fromWallet !== null &&\n    // Fair price is defined.\n    fair !== undefined &&\n    fair > 0 &&\n    // Mints are distinct.\n    fromMint.equals(toMint) === false &&\n    // Wallet is connected.\n    swapClient.program.provider.wallet.publicKey !== null &&\n    // Trade amounts greater than zero.\n    fromAmount > 0 &&\n    toAmount > 0 &&\n    // Trade route exists.\n    route !== null &&\n    // Wormhole <-> native markets must have the wormhole token as the\n    // *from* address since they're one-sided markets.\n    (route.kind !== \"wormhole-native\" ||\n      wormholeMap\n        .get(fromMint.toString())\n        ?.tags?.includes(SPL_REGISTRY_WORM_TAG) !== undefined) &&\n    // Wormhole <-> sollet markets must have the sollet token as the\n    // *from* address since they're one sided markets.\n    (route.kind !== \"wormhole-sollet\" ||\n      solletMap\n        .get(fromMint.toString())\n        ?.tags?.includes(SPL_REGISTRY_SOLLET_TAG) !== undefined)\n  );\n}\n\nexport function useReferral(fromMarket?: Market): PublicKey | undefined {\n  const { referral } = useSwapContext();\n  const asyncReferral = useAsync(async () => {\n    if (!referral) {\n      return undefined;\n    }\n    if (!fromMarket) {\n      return undefined;\n    }\n    if (\n      !fromMarket.quoteMintAddress.equals(USDC_MINT) &&\n      !fromMarket.quoteMintAddress.equals(USDT_MINT)\n    ) {\n      return undefined;\n    }\n\n    return Token.getAssociatedTokenAddress(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      fromMarket.quoteMintAddress,\n      referral\n    );\n  }, [fromMarket]);\n\n  if (!asyncReferral.result) {\n    return undefined;\n  }\n  return asyncReferral.result;\n}\n"]},"metadata":{},"sourceType":"module"}