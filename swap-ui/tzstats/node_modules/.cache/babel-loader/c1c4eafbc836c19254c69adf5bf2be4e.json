{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst serum_1 = require(\"@project-serum/serum\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst utils_1 = require(\"./utils\"); // Utility class to parse the token list for markets.\n\n\nclass SwapMarkets {\n  constructor(provider, tokenList) {\n    this.provider = provider;\n    this.tokenList = tokenList;\n  }\n\n  tokens() {\n    return this.tokenList.getList().filter(t => {\n      var _a, _b;\n\n      const isUsdxQuoted = ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt) || ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdc);\n      return isUsdxQuoted;\n    }).map(t => new web3_js_1.PublicKey(t.address));\n  }\n\n  pairs(mint) {\n    var _a, _b;\n\n    const tokenList = this.tokenList.getList();\n    const mintInfo = this.tokenList.getList().filter(t => t.address === mint.toString())[0];\n\n    if (mintInfo === undefined) {\n      return [];\n    }\n\n    const pairs = new Set(); // Add all tokens that also have USDC quoted markets.\n\n    if ((_a = mintInfo.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) {\n      pairs.add(utils_1.USDC_PUBKEY.toString());\n      let iter = tokenList.filter(t => {\n        var _a;\n\n        return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc);\n      }).map(t => t.address);\n      iter.forEach(pairs.add, pairs);\n    } // Add all tokens that also have USDT quoted markets.\n\n\n    if ((_b = mintInfo.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) {\n      pairs.add(utils_1.USDT_PUBKEY.toString());\n      tokenList.filter(t => {\n        var _a;\n\n        return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt);\n      }).map(t => t.address).forEach(pairs.add, pairs);\n    }\n\n    return [...pairs].map(t => new web3_js_1.PublicKey(t));\n  } // Returns the `usdxMint` quoted market address *if* no open orders account\n  // already exists.\n\n\n  async getMarketAddressIfNeeded(usdxMint, baseMint) {\n    const marketAddress = this.getMarketAddress(usdxMint, baseMint);\n\n    if (marketAddress === null) {\n      throw new Error('Market not found');\n    }\n\n    let accounts = await serum_1.OpenOrders.findForMarketAndOwner(this.provider.connection, marketAddress, this.provider.wallet.publicKey, utils_1.DEX_PID);\n\n    if (accounts[0] !== undefined) {\n      throw new Error('Open orders account already exists');\n    }\n\n    return marketAddress;\n  } // Returns the `usdxMint` quoted market address.\n\n\n  getMarketAddress(usdxMint, baseMint) {\n    const market = this.tokenList.getList().filter(t => {\n      var _a, _b;\n\n      if (t.address !== (baseMint === null || baseMint === void 0 ? void 0 : baseMint.toString())) {\n        return false;\n      }\n\n      if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n        return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n      } else if (usdxMint.equals(utils_1.USDT_PUBKEY)) {\n        return ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) !== undefined;\n      } else {\n        return false;\n      }\n    }).map(t => {\n      if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n        return new web3_js_1.PublicKey(t.extensions.serumV3Usdc);\n      } else {\n        return new web3_js_1.PublicKey(t.extensions.serumV3Usdt);\n      }\n    })[0];\n\n    if (market === undefined) {\n      return null;\n    }\n\n    return market;\n  } // Returns true if there's a trade across two USDC quoted markets\n  // `fromMint` `toMint`.\n\n\n  usdcPathExists(fromMint, toMint) {\n    const fromMarket = this.tokenList.getList().filter(t => t.address === fromMint.toString()).filter(t => {\n      var _a;\n\n      return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n    })[0];\n    const toMarket = this.tokenList.getList().filter(t => t.address === toMint.toString()).filter(t => {\n      var _a;\n\n      return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n    })[0];\n    return fromMarket !== undefined && toMarket !== undefined;\n  }\n\n  route(fromMint, toMint) {\n    if (fromMint.equals(utils_1.USDC_PUBKEY) || fromMint.equals(utils_1.USDT_PUBKEY)) {\n      const market = this.getMarketAddress(fromMint, toMint);\n\n      if (market === null) {\n        return null;\n      }\n\n      return [market];\n    } else if (toMint.equals(utils_1.USDC_PUBKEY) || toMint.equals(utils_1.USDT_PUBKEY)) {\n      const market = this.getMarketAddress(toMint, fromMint);\n\n      if (market === null) {\n        return null;\n      }\n\n      return [market];\n    } else {\n      let fromMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, fromMint);\n      let toMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, toMint);\n\n      if (fromMarket === null || toMarket === null) {\n        fromMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, fromMint);\n        toMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, toMint);\n\n        if (fromMarket === null || toMarket === null) {\n          return null;\n        }\n      }\n\n      return [fromMarket, toMarket];\n    }\n  }\n\n}\n\nexports.default = SwapMarkets;","map":{"version":3,"sources":["../src/swap-markets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst serum_1 = require(\"@project-serum/serum\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst utils_1 = require(\"./utils\");\n// Utility class to parse the token list for markets.\nclass SwapMarkets {\n    constructor(provider, tokenList) {\n        this.provider = provider;\n        this.tokenList = tokenList;\n    }\n    tokens() {\n        return this.tokenList\n            .getList()\n            .filter((t) => {\n            var _a, _b;\n            const isUsdxQuoted = ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt) || ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdc);\n            return isUsdxQuoted;\n        })\n            .map((t) => new web3_js_1.PublicKey(t.address));\n    }\n    pairs(mint) {\n        var _a, _b;\n        const tokenList = this.tokenList.getList();\n        const mintInfo = this.tokenList\n            .getList()\n            .filter((t) => t.address === mint.toString())[0];\n        if (mintInfo === undefined) {\n            return [];\n        }\n        const pairs = new Set();\n        // Add all tokens that also have USDC quoted markets.\n        if ((_a = mintInfo.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) {\n            pairs.add(utils_1.USDC_PUBKEY.toString());\n            let iter = tokenList\n                .filter((t) => { var _a; return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc); })\n                .map((t) => t.address);\n            iter.forEach(pairs.add, pairs);\n        }\n        // Add all tokens that also have USDT quoted markets.\n        if ((_b = mintInfo.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) {\n            pairs.add(utils_1.USDT_PUBKEY.toString());\n            tokenList\n                .filter((t) => { var _a; return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt); })\n                .map((t) => t.address)\n                .forEach(pairs.add, pairs);\n        }\n        return [...pairs].map((t) => new web3_js_1.PublicKey(t));\n    }\n    // Returns the `usdxMint` quoted market address *if* no open orders account\n    // already exists.\n    async getMarketAddressIfNeeded(usdxMint, baseMint) {\n        const marketAddress = this.getMarketAddress(usdxMint, baseMint);\n        if (marketAddress === null) {\n            throw new Error('Market not found');\n        }\n        let accounts = await serum_1.OpenOrders.findForMarketAndOwner(this.provider.connection, marketAddress, this.provider.wallet.publicKey, utils_1.DEX_PID);\n        if (accounts[0] !== undefined) {\n            throw new Error('Open orders account already exists');\n        }\n        return marketAddress;\n    }\n    // Returns the `usdxMint` quoted market address.\n    getMarketAddress(usdxMint, baseMint) {\n        const market = this.tokenList\n            .getList()\n            .filter((t) => {\n            var _a, _b;\n            if (t.address !== (baseMint === null || baseMint === void 0 ? void 0 : baseMint.toString())) {\n                return false;\n            }\n            if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n                return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n            }\n            else if (usdxMint.equals(utils_1.USDT_PUBKEY)) {\n                return ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) !== undefined;\n            }\n            else {\n                return false;\n            }\n        })\n            .map((t) => {\n            if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n                return new web3_js_1.PublicKey(t.extensions.serumV3Usdc);\n            }\n            else {\n                return new web3_js_1.PublicKey(t.extensions.serumV3Usdt);\n            }\n        })[0];\n        if (market === undefined) {\n            return null;\n        }\n        return market;\n    }\n    // Returns true if there's a trade across two USDC quoted markets\n    // `fromMint` `toMint`.\n    usdcPathExists(fromMint, toMint) {\n        const fromMarket = this.tokenList\n            .getList()\n            .filter((t) => t.address === fromMint.toString())\n            .filter((t) => { var _a; return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined; })[0];\n        const toMarket = this.tokenList\n            .getList()\n            .filter((t) => t.address === toMint.toString())\n            .filter((t) => { var _a; return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined; })[0];\n        return fromMarket !== undefined && toMarket !== undefined;\n    }\n    route(fromMint, toMint) {\n        if (fromMint.equals(utils_1.USDC_PUBKEY) || fromMint.equals(utils_1.USDT_PUBKEY)) {\n            const market = this.getMarketAddress(fromMint, toMint);\n            if (market === null) {\n                return null;\n            }\n            return [market];\n        }\n        else if (toMint.equals(utils_1.USDC_PUBKEY) || toMint.equals(utils_1.USDT_PUBKEY)) {\n            const market = this.getMarketAddress(toMint, fromMint);\n            if (market === null) {\n                return null;\n            }\n            return [market];\n        }\n        else {\n            let fromMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, fromMint);\n            let toMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, toMint);\n            if (fromMarket === null || toMarket === null) {\n                fromMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, fromMint);\n                toMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, toMint);\n                if (fromMarket === null || toMarket === null) {\n                    return null;\n                }\n            }\n            return [fromMarket, toMarket];\n        }\n    }\n}\nexports.default = SwapMarkets;\n//# sourceMappingURL=swap-markets.js.map"]},"metadata":{},"sourceType":"script"}