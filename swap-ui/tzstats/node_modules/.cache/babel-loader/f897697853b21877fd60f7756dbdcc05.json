{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Dex.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$();\n\nimport React, { useContext, useState, useEffect } from \"react\";\nimport { useAsync } from \"react-async-hook\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Market, Orderbook as OrderbookSide } from \"@project-serum/serum\";\nimport { DEX_PID, USDC_MINT, USDT_MINT, SOL_MINT, WRAPPED_SOL_MINT, WORM_USDC_MINT, WORM_USDT_MINT, WORM_USDC_MARKET, WORM_USDT_MARKET, WORM_MARKET_BASE } from \"../utils/pubkeys\";\nimport { useTokenMap, useTokenListContext } from \"./TokenList\";\nimport { fetchSolletInfo, requestWormholeSwapMarketIfNeeded } from \"./Sollet\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BASE_TAKER_FEE_BPS = 0.0022;\nexport const FEE_MULTIPLIER = 1 - BASE_TAKER_FEE_BPS;\n\nconst _DexContext = /*#__PURE__*/React.createContext(null);\n\nexport function DexContextProvider(props) {\n  _s();\n\n  const [ooAccounts, setOoAccounts] = useState(new Map());\n  const swapClient = props.swapClient; // Removes the given open orders from the context.\n\n  const closeOpenOrders = async openOrder => {\n    var _newOoAccounts$get;\n\n    const newOoAccounts = new Map(ooAccounts);\n    const openOrders = (_newOoAccounts$get = newOoAccounts.get(openOrder.market.toString())) === null || _newOoAccounts$get === void 0 ? void 0 : _newOoAccounts$get.filter(oo => !oo.address.equals(openOrder.address));\n\n    if (openOrders && openOrders.length > 0) {\n      newOoAccounts.set(openOrder.market.toString(), openOrders);\n    } else {\n      newOoAccounts.delete(openOrder.market.toString());\n    }\n\n    setOoAccounts(newOoAccounts);\n  };\n\n  return /*#__PURE__*/_jsxDEV(_DexContext.Provider, {\n    value: {\n      openOrders: ooAccounts,\n      closeOpenOrders,\n      swapClient\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 63,\n    columnNumber: 5\n  }, this);\n}\n\n_s(DexContextProvider, \"WbRD3/AeBb7OMbBIXiA/w+lYK5E=\");\n\n_c = DexContextProvider;\nexport function useDexContext() {\n  _s2();\n\n  const ctx = useContext(_DexContext);\n\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n\n  return ctx;\n}\n\n_s2(useDexContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\n\nexport function useOpenOrders() {\n  _s3();\n\n  const ctx = useDexContext();\n  return ctx.openOrders;\n} // Lazy load a given market.\n\n_s3(useOpenOrders, \"94WEhUdSpWdU4mS5j1qMu1aGxic=\", false, function () {\n  return [useDexContext];\n});\n\nexport function useMarket(market) {\n  _s4();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const asyncMarket = useAsync(async () => {\n    if (!market) {\n      return undefined;\n    }\n\n    if (_MARKET_CACHE.get(market.toString())) {\n      return _MARKET_CACHE.get(market.toString());\n    }\n\n    const marketClient = new Promise(async resolve => {\n      // TODO: if we already have the mints, then pass them through to the\n      //       market client here to save a network request.\n      const marketClient = await Market.load(swapClient.program.provider.connection, market, swapClient.program.provider.opts, DEX_PID);\n      resolve(marketClient);\n    });\n\n    _MARKET_CACHE.set(market.toString(), marketClient);\n\n    return marketClient;\n  }, [swapClient.program.provider.connection, market]);\n\n  if (asyncMarket.result) {\n    return asyncMarket.result;\n  }\n\n  return undefined;\n} // Lazy load the orderbook for a given market.\n\n_s4(useMarket, \"iJvA2rSv2MbqjQhLCzMZLk6dgMs=\", false, function () {\n  return [useDexContext, useAsync];\n});\n\nexport function useOrderbook(market) {\n  _s5();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const marketClient = useMarket(market);\n  const [refresh, setRefresh] = useState(0);\n  const asyncOrderbook = useAsync(async () => {\n    if (!market || !marketClient) {\n      return undefined;\n    }\n\n    if (_ORDERBOOK_CACHE.get(market.toString())) {\n      return _ORDERBOOK_CACHE.get(market.toString());\n    }\n\n    const orderbook = new Promise(async resolve => {\n      const [bids, asks] = await Promise.all([marketClient.loadBids(swapClient.program.provider.connection), marketClient.loadAsks(swapClient.program.provider.connection)]);\n      resolve({\n        bids,\n        asks\n      });\n    });\n\n    _ORDERBOOK_CACHE.set(market.toString(), orderbook);\n\n    return orderbook;\n  }, [refresh, swapClient.program.provider.connection, market, marketClient]); // Stream in bids updates.\n\n  useEffect(() => {\n    let listener;\n\n    if (marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, async info => {\n        const bids = OrderbookSide.decode(marketClient, info.data);\n        const orderbook = await _ORDERBOOK_CACHE.get(marketClient.address.toString());\n        const oldBestBid = orderbook === null || orderbook === void 0 ? void 0 : orderbook.bids.items(true).next().value;\n        const newBestBid = bids.items(true).next().value;\n\n        if (orderbook && oldBestBid && newBestBid && oldBestBid.price !== newBestBid.price) {\n          orderbook.bids = bids;\n          setRefresh(r => r + 1);\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [marketClient, marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, swapClient.program.provider.connection]); // Stream in asks updates.\n\n  useEffect(() => {\n    let listener;\n\n    if (marketClient === null || marketClient === void 0 ? void 0 : marketClient.asksAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(marketClient === null || marketClient === void 0 ? void 0 : marketClient.asksAddress, async info => {\n        const asks = OrderbookSide.decode(marketClient, info.data);\n        const orderbook = await _ORDERBOOK_CACHE.get(marketClient.address.toString());\n        const oldBestOffer = orderbook === null || orderbook === void 0 ? void 0 : orderbook.asks.items(false).next().value;\n        const newBestOffer = asks.items(false).next().value;\n\n        if (orderbook && oldBestOffer && newBestOffer && oldBestOffer.price !== newBestOffer.price) {\n          orderbook.asks = asks;\n          setRefresh(r => r + 1);\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [marketClient, marketClient === null || marketClient === void 0 ? void 0 : marketClient.bidsAddress, swapClient.program.provider.connection]);\n\n  if (asyncOrderbook.result) {\n    return asyncOrderbook.result;\n  }\n\n  return undefined;\n}\n\n_s5(useOrderbook, \"AFX7y/PBFBRUK7rRNrMmPjovavY=\", false, function () {\n  return [useDexContext, useMarket, useAsync];\n});\n\nexport function useMarketName(market) {\n  _s6();\n\n  var _tokenMap$get, _tokenMap$get2;\n\n  const tokenMap = useTokenMap();\n  const marketClient = useMarket(market);\n\n  if (!marketClient) {\n    return null;\n  }\n\n  const baseTicker = marketClient ? (_tokenMap$get = tokenMap.get(marketClient === null || marketClient === void 0 ? void 0 : marketClient.baseMintAddress.toString())) === null || _tokenMap$get === void 0 ? void 0 : _tokenMap$get.symbol : \"-\";\n  const quoteTicker = marketClient ? (_tokenMap$get2 = tokenMap.get(marketClient === null || marketClient === void 0 ? void 0 : marketClient.quoteMintAddress.toString())) === null || _tokenMap$get2 === void 0 ? void 0 : _tokenMap$get2.symbol : \"-\";\n  const name = `${baseTicker} / ${quoteTicker}`;\n  return name;\n} // Fair price for a given market, as defined by the mid.\n\n_s6(useMarketName, \"lyPzKNtPwMkdl3Mzppsg/jQfbKc=\", false, function () {\n  return [useTokenMap, useMarket];\n});\n\nexport function useBbo(market) {\n  _s7();\n\n  const orderbook = useOrderbook(market);\n\n  if (orderbook === undefined) {\n    return undefined;\n  }\n\n  const bestBid = orderbook.bids.items(true).next().value;\n  const bestOffer = orderbook.asks.items(false).next().value;\n\n  if (!bestBid && !bestOffer) {\n    return {};\n  }\n\n  if (!bestBid) {\n    return {\n      bestOffer: bestOffer.price\n    };\n  }\n\n  if (!bestOffer) {\n    return {\n      bestBid: bestBid.price\n    };\n  }\n\n  const mid = (bestBid.price + bestOffer.price) / 2.0;\n  return {\n    bestBid: bestBid.price,\n    bestOffer: bestOffer.price,\n    mid\n  };\n} // Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\n\n_s7(useBbo, \"Jruu7KTvlHgz8wl6nClH4is55vs=\", false, function () {\n  return [useOrderbook];\n});\n\nexport function useFairRoute(fromMint, toMint) {\n  _s8();\n\n  const route = useRoute(fromMint, toMint);\n  const fromBbo = useBbo(route ? route[0] : undefined);\n  const fromMarket = useMarket(route ? route[0] : undefined);\n  const toBbo = useBbo(route ? route[1] : undefined);\n\n  if (route === null) {\n    return undefined;\n  }\n\n  if (route.length === 1 && fromBbo !== undefined) {\n    if (fromMarket === undefined) {\n      return undefined;\n    }\n\n    if ((fromMarket === null || fromMarket === void 0 ? void 0 : fromMarket.baseMintAddress.equals(fromMint)) || (fromMarket === null || fromMarket === void 0 ? void 0 : fromMarket.baseMintAddress.equals(WRAPPED_SOL_MINT)) && fromMint.equals(SOL_MINT)) {\n      return fromBbo.bestBid && 1.0 / fromBbo.bestBid;\n    } else {\n      return fromBbo.bestOffer && fromBbo.bestOffer;\n    }\n  }\n\n  if (fromBbo === undefined || fromBbo.bestBid === undefined || toBbo === undefined || toBbo.bestOffer === undefined) {\n    return undefined;\n  }\n\n  return toBbo.bestOffer / fromBbo.bestBid;\n}\n\n_s8(useFairRoute, \"eFSbQ5TJT+4F6LrF7pQ1HraMOho=\", false, function () {\n  return [useRoute, useBbo, useMarket, useBbo];\n});\n\nexport function useRoute(fromMint, toMint) {\n  _s9();\n\n  const route = useRouteVerbose(fromMint, toMint);\n\n  if (route === null) {\n    return null;\n  }\n\n  return route.markets;\n} // Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\n\n_s9(useRoute, \"ZF5u5G2LvCfS4my7H9bdifWPr50=\", false, function () {\n  return [useRouteVerbose];\n});\n\nexport function useRouteVerbose(fromMint, toMint) {\n  _s10();\n\n  const {\n    swapClient\n  } = useDexContext();\n  const {\n    wormholeMap,\n    solletMap\n  } = useTokenListContext();\n  const asyncRoute = useAsync(async () => {\n    const swapMarket = await wormholeSwapMarket(swapClient.program.provider.connection, fromMint, toMint, wormholeMap, solletMap);\n\n    if (swapMarket !== null) {\n      const [wormholeMarket, kind] = swapMarket;\n      return {\n        markets: [wormholeMarket],\n        kind\n      };\n    }\n\n    const markets = swapClient.route(fromMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : fromMint, toMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : toMint);\n\n    if (markets === null) {\n      return null;\n    }\n\n    const kind = \"usdx\";\n    return {\n      markets,\n      kind\n    };\n  }, [fromMint, toMint, swapClient]);\n\n  if (asyncRoute.result) {\n    return asyncRoute.result;\n  }\n\n  return null;\n}\n\n_s10(useRouteVerbose, \"c/2lDLujGcE40LXK4dsyQkBudcY=\", false, function () {\n  return [useDexContext, useTokenListContext, useAsync];\n});\n\n// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nconst WORMHOLE_NATIVE_MAP = new Map([[wormKey(WORM_USDC_MINT, USDC_MINT), WORM_USDC_MARKET], [wormKey(WORM_USDT_MINT, USDT_MINT), WORM_USDT_MARKET]]);\n\nfunction wormKey(fromMint, toMint) {\n  const [first, second] = fromMint < toMint ? [fromMint, toMint] : [toMint, fromMint];\n  return first.toString() + second.toString();\n}\n\nasync function wormholeSwapMarket(conn, fromMint, toMint, wormholeMap, solletMap) {\n  let market = wormholeNativeMarket(fromMint, toMint);\n\n  if (market !== null) {\n    return [market, \"wormhole-native\"];\n  }\n\n  market = await wormholeSolletMarket(conn, fromMint, toMint, wormholeMap, solletMap);\n\n  if (market === null) {\n    return null;\n  }\n\n  return [market, \"wormhole-sollet\"];\n}\n\nfunction wormholeNativeMarket(fromMint, toMint) {\n  var _WORMHOLE_NATIVE_MAP$;\n\n  return (_WORMHOLE_NATIVE_MAP$ = WORMHOLE_NATIVE_MAP.get(wormKey(fromMint, toMint))) !== null && _WORMHOLE_NATIVE_MAP$ !== void 0 ? _WORMHOLE_NATIVE_MAP$ : null;\n} // Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\n\n\nasync function wormholeSolletMarket(conn, fromMint, toMint, wormholeMap, solletMap) {\n  const fromWormhole = wormholeMap.get(fromMint.toString());\n  const isFromWormhole = fromWormhole !== undefined;\n  const toWormhole = wormholeMap.get(toMint.toString());\n  const isToWormhole = toWormhole !== undefined;\n  const fromSollet = solletMap.get(fromMint.toString());\n  const isFromSollet = fromSollet !== undefined;\n  const toSollet = solletMap.get(toMint.toString());\n  const isToSollet = toSollet !== undefined;\n\n  if ((isFromWormhole || isToWormhole) && isFromWormhole !== isToWormhole) {\n    if ((isFromSollet || isToSollet) && isFromSollet !== isToSollet) {\n      var _extensions;\n\n      const base = isFromSollet ? fromMint : toMint;\n      const [quote, wormholeInfo] = isFromWormhole ? [fromMint, fromWormhole] : [toMint, toWormhole];\n      const solletInfo = await fetchSolletInfo(base);\n\n      if (solletInfo.erc20Contract !== ((_extensions = wormholeInfo.extensions) === null || _extensions === void 0 ? void 0 : _extensions.address)) {\n        return null;\n      }\n\n      const market = await deriveWormholeMarket(base, quote);\n\n      if (market === null) {\n        return null;\n      }\n\n      const marketExists = await requestWormholeSwapMarketIfNeeded(conn, base, quote, market, solletInfo);\n\n      if (!marketExists) {\n        return null;\n      }\n\n      return market;\n    }\n  }\n\n  return null;\n} // Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\n\n\nasync function deriveWormholeMarket(baseMint, quoteMint, version = 0) {\n  if (version > 99) {\n    console.log(\"Swap market version cannot be greater than 99\");\n    return null;\n  }\n\n  if (version < 0) {\n    console.log(\"Version cannot be less than zero\");\n    return null;\n  }\n\n  const padToTwo = n => n <= 99 ? `0${n}`.slice(-2) : n;\n\n  const seed = baseMint.toString().slice(0, 15) + quoteMint.toString().slice(0, 15) + padToTwo(version);\n  return await PublicKey.createWithSeed(WORM_MARKET_BASE, seed, DEX_PID);\n}\n\nconst _ORDERBOOK_CACHE = new Map();\n\nconst _MARKET_CACHE = new Map();\n\nvar _c;\n\n$RefreshReg$(_c, \"DexContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Dex.tsx"],"names":["React","useContext","useState","useEffect","useAsync","PublicKey","Market","Orderbook","OrderbookSide","DEX_PID","USDC_MINT","USDT_MINT","SOL_MINT","WRAPPED_SOL_MINT","WORM_USDC_MINT","WORM_USDT_MINT","WORM_USDC_MARKET","WORM_USDT_MARKET","WORM_MARKET_BASE","useTokenMap","useTokenListContext","fetchSolletInfo","requestWormholeSwapMarketIfNeeded","BASE_TAKER_FEE_BPS","FEE_MULTIPLIER","_DexContext","createContext","DexContextProvider","props","ooAccounts","setOoAccounts","Map","swapClient","closeOpenOrders","openOrder","newOoAccounts","openOrders","get","market","toString","filter","oo","address","equals","length","set","delete","children","useDexContext","ctx","Error","useOpenOrders","useMarket","asyncMarket","undefined","_MARKET_CACHE","marketClient","Promise","resolve","load","program","provider","connection","opts","result","useOrderbook","refresh","setRefresh","asyncOrderbook","_ORDERBOOK_CACHE","orderbook","bids","asks","all","loadBids","loadAsks","listener","bidsAddress","onAccountChange","info","decode","data","oldBestBid","items","next","value","newBestBid","price","r","removeAccountChangeListener","asksAddress","oldBestOffer","newBestOffer","useMarketName","tokenMap","baseTicker","baseMintAddress","symbol","quoteTicker","quoteMintAddress","name","useBbo","bestBid","bestOffer","mid","useFairRoute","fromMint","toMint","route","useRoute","fromBbo","fromMarket","toBbo","useRouteVerbose","markets","wormholeMap","solletMap","asyncRoute","swapMarket","wormholeSwapMarket","wormholeMarket","kind","WORMHOLE_NATIVE_MAP","wormKey","first","second","conn","wormholeNativeMarket","wormholeSolletMarket","fromWormhole","isFromWormhole","toWormhole","isToWormhole","fromSollet","isFromSollet","toSollet","isToSollet","base","quote","wormholeInfo","solletInfo","erc20Contract","extensions","deriveWormholeMarket","marketExists","baseMint","quoteMint","version","console","log","padToTwo","n","slice","seed","createWithSeed"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { MintLayout } from \"@solana/spl-token\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { Swap as SwapClient } from \"@project-serum/swap\";\nimport {\n  Market,\n  OpenOrders,\n  Orderbook as OrderbookSide,\n} from \"@project-serum/serum\";\nimport {\n  DEX_PID,\n  USDC_MINT,\n  USDT_MINT,\n  SOL_MINT,\n  WRAPPED_SOL_MINT,\n  WORM_USDC_MINT,\n  WORM_USDT_MINT,\n  WORM_USDC_MARKET,\n  WORM_USDT_MARKET,\n  WORM_MARKET_BASE,\n} from \"../utils/pubkeys\";\nimport { useTokenMap, useTokenListContext } from \"./TokenList\";\nimport { fetchSolletInfo, requestWormholeSwapMarketIfNeeded } from \"./Sollet\";\nimport { setMintCache } from \"./Token\";\n\nconst BASE_TAKER_FEE_BPS = 0.0022;\nexport const FEE_MULTIPLIER = 1 - BASE_TAKER_FEE_BPS;\n\ntype DexContext = {\n  // Maps market address to open orders accounts.\n  openOrders: Map<string, Array<OpenOrders>>;\n  closeOpenOrders: (openOrder: OpenOrders) => void;\n  swapClient: SwapClient;\n};\nconst _DexContext = React.createContext<DexContext | null>(null);\n\nexport function DexContextProvider(props: any) {\n  const [ooAccounts, setOoAccounts] = useState<Map<string, Array<OpenOrders>>>(\n    new Map()\n  );\n  const swapClient = props.swapClient;\n\n  // Removes the given open orders from the context.\n  const closeOpenOrders = async (openOrder: OpenOrders) => {\n    const newOoAccounts = new Map(ooAccounts);\n    const openOrders = newOoAccounts\n      .get(openOrder.market.toString())\n      ?.filter((oo: OpenOrders) => !oo.address.equals(openOrder.address));\n    if (openOrders && openOrders.length > 0) {\n      newOoAccounts.set(openOrder.market.toString(), openOrders);\n    } else {\n      newOoAccounts.delete(openOrder.market.toString());\n    }\n    setOoAccounts(newOoAccounts);\n  };\n\n\n  return (\n    <_DexContext.Provider\n      value={{\n        openOrders: ooAccounts,\n        closeOpenOrders,\n        swapClient,\n      }}\n    >\n      {props.children}\n    </_DexContext.Provider>\n  );\n}\n\nexport function useDexContext(): DexContext {\n  const ctx = useContext(_DexContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useOpenOrders(): Map<string, Array<OpenOrders>> {\n  const ctx = useDexContext();\n  return ctx.openOrders;\n}\n\n// Lazy load a given market.\nexport function useMarket(market?: PublicKey): Market | undefined {\n  const { swapClient } = useDexContext();\n\n  const asyncMarket = useAsync(async () => {\n    if (!market) {\n      return undefined;\n    }\n    if (_MARKET_CACHE.get(market.toString())) {\n      return _MARKET_CACHE.get(market.toString());\n    }\n\n    const marketClient = new Promise<Market>(async (resolve) => {\n      // TODO: if we already have the mints, then pass them through to the\n      //       market client here to save a network request.\n      const marketClient = await Market.load(\n        swapClient.program.provider.connection,\n        market,\n        swapClient.program.provider.opts,\n        DEX_PID\n      );\n      resolve(marketClient);\n    });\n\n    _MARKET_CACHE.set(market.toString(), marketClient);\n    return marketClient;\n  }, [swapClient.program.provider.connection, market]);\n\n  if (asyncMarket.result) {\n    return asyncMarket.result;\n  }\n\n  return undefined;\n}\n\n// Lazy load the orderbook for a given market.\nexport function useOrderbook(market?: PublicKey): Orderbook | undefined {\n  const { swapClient } = useDexContext();\n  const marketClient = useMarket(market);\n  const [refresh, setRefresh] = useState(0);\n\n  const asyncOrderbook = useAsync(async () => {\n    if (!market || !marketClient) {\n      return undefined;\n    }\n    if (_ORDERBOOK_CACHE.get(market.toString())) {\n      return _ORDERBOOK_CACHE.get(market.toString());\n    }\n\n    const orderbook = new Promise<Orderbook>(async (resolve) => {\n      const [bids, asks] = await Promise.all([\n        marketClient.loadBids(swapClient.program.provider.connection),\n        marketClient.loadAsks(swapClient.program.provider.connection),\n      ]);\n\n      resolve({\n        bids,\n        asks,\n      });\n    });\n\n    _ORDERBOOK_CACHE.set(market.toString(), orderbook);\n\n    return orderbook;\n  }, [refresh, swapClient.program.provider.connection, market, marketClient]);\n\n  // Stream in bids updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.bidsAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.bidsAddress,\n        async (info) => {\n          const bids = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestBid = orderbook?.bids.items(true).next().value;\n          const newBestBid = bids.items(true).next().value;\n          if (\n            orderbook &&\n            oldBestBid &&\n            newBestBid &&\n            oldBestBid.price !== newBestBid.price\n          ) {\n            orderbook.bids = bids;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  // Stream in asks updates.\n  useEffect(() => {\n    let listener: number | undefined;\n    if (marketClient?.asksAddress) {\n      listener = swapClient.program.provider.connection.onAccountChange(\n        marketClient?.asksAddress,\n        async (info) => {\n          const asks = OrderbookSide.decode(marketClient, info.data);\n          const orderbook = await _ORDERBOOK_CACHE.get(\n            marketClient.address.toString()\n          );\n          const oldBestOffer = orderbook?.asks.items(false).next().value;\n          const newBestOffer = asks.items(false).next().value;\n          if (\n            orderbook &&\n            oldBestOffer &&\n            newBestOffer &&\n            oldBestOffer.price !== newBestOffer.price\n          ) {\n            orderbook.asks = asks;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        swapClient.program.provider.connection.removeAccountChangeListener(\n          listener\n        );\n      }\n    };\n  }, [\n    marketClient,\n    marketClient?.bidsAddress,\n    swapClient.program.provider.connection,\n  ]);\n\n  if (asyncOrderbook.result) {\n    return asyncOrderbook.result;\n  }\n\n  return undefined;\n}\n\nexport function useMarketName(market: PublicKey): string | null {\n  const tokenMap = useTokenMap();\n  const marketClient = useMarket(market);\n  if (!marketClient) {\n    return null;\n  }\n  const baseTicker = marketClient\n    ? tokenMap.get(marketClient?.baseMintAddress.toString())?.symbol\n    : \"-\";\n  const quoteTicker = marketClient\n    ? tokenMap.get(marketClient?.quoteMintAddress.toString())?.symbol\n    : \"-\";\n  const name = `${baseTicker} / ${quoteTicker}`;\n  return name;\n}\n\n// Fair price for a given market, as defined by the mid.\nexport function useBbo(market?: PublicKey): Bbo | undefined {\n  const orderbook = useOrderbook(market);\n  if (orderbook === undefined) {\n    return undefined;\n  }\n  const bestBid = orderbook.bids.items(true).next().value;\n  const bestOffer = orderbook.asks.items(false).next().value;\n  if (!bestBid && !bestOffer) {\n    return {};\n  }\n  if (!bestBid) {\n    return { bestOffer: bestOffer.price };\n  }\n  if (!bestOffer) {\n    return { bestBid: bestBid.price };\n  }\n  const mid = (bestBid.price + bestOffer.price) / 2.0;\n  return { bestBid: bestBid.price, bestOffer: bestOffer.price, mid };\n}\n\n// Fair price for a theoretical toMint/fromMint market. I.e., the number\n// of `fromMint` tokens to purchase a single `toMint` token. Aggregates\n// across a trade route, if needed.\nexport function useFairRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): number | undefined {\n  const route = useRoute(fromMint, toMint);\n  const fromBbo = useBbo(route ? route[0] : undefined);\n  const fromMarket = useMarket(route ? route[0] : undefined);\n  const toBbo = useBbo(route ? route[1] : undefined);\n\n  if (route === null) {\n    return undefined;\n  }\n\n  if (route.length === 1 && fromBbo !== undefined) {\n    if (fromMarket === undefined) {\n      return undefined;\n    }\n    if (\n      fromMarket?.baseMintAddress.equals(fromMint) ||\n      (fromMarket?.baseMintAddress.equals(WRAPPED_SOL_MINT) &&\n        fromMint.equals(SOL_MINT))\n    ) {\n      return fromBbo.bestBid && 1.0 / fromBbo.bestBid;\n    } else {\n      return fromBbo.bestOffer && fromBbo.bestOffer;\n    }\n  }\n  if (\n    fromBbo === undefined ||\n    fromBbo.bestBid === undefined ||\n    toBbo === undefined ||\n    toBbo.bestOffer === undefined\n  ) {\n    return undefined;\n  }\n  return toBbo.bestOffer / fromBbo.bestBid;\n}\n\nexport function useRoute(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): Array<PublicKey> | null {\n  const route = useRouteVerbose(fromMint, toMint);\n  if (route === null) {\n    return null;\n  }\n  return route.markets;\n}\n\n// Types of routes.\n//\n// 1. Direct trades on USDC quoted markets.\n// 2. Transitive trades across two USDC qutoed markets.\n// 3. Wormhole <-> Sollet one-to-one swap markets.\n// 4. Wormhole <-> Native one-to-one swap markets.\n//\nexport function useRouteVerbose(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): { markets: Array<PublicKey>; kind: RouteKind } | null {\n  const { swapClient } = useDexContext();\n  const { wormholeMap, solletMap } = useTokenListContext();\n  const asyncRoute = useAsync(async () => {\n    const swapMarket = await wormholeSwapMarket(\n      swapClient.program.provider.connection,\n      fromMint,\n      toMint,\n      wormholeMap,\n      solletMap\n    );\n    if (swapMarket !== null) {\n      const [wormholeMarket, kind] = swapMarket;\n      return { markets: [wormholeMarket], kind };\n    }\n    const markets = swapClient.route(\n      fromMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : fromMint,\n      toMint.equals(SOL_MINT) ? WRAPPED_SOL_MINT : toMint\n    );\n    if (markets === null) {\n      return null;\n    }\n    const kind: RouteKind = \"usdx\";\n    return { markets, kind };\n  }, [fromMint, toMint, swapClient]);\n\n  if (asyncRoute.result) {\n    return asyncRoute.result;\n  }\n  return null;\n}\n\ntype Orderbook = {\n  bids: OrderbookSide;\n  asks: OrderbookSide;\n};\n\n// Wormhole utils.\n\ntype RouteKind = \"wormhole-native\" | \"wormhole-sollet\" | \"usdx\";\n\n// Maps fromMint || toMint (in sort order) to swap market public key.\n// All markets for wormhole<->native tokens should be here, e.g.\n// USDC <-> wUSDC.\nconst WORMHOLE_NATIVE_MAP = new Map<string, PublicKey>([\n  [wormKey(WORM_USDC_MINT, USDC_MINT), WORM_USDC_MARKET],\n  [wormKey(WORM_USDT_MINT, USDT_MINT), WORM_USDT_MARKET],\n]);\n\nfunction wormKey(fromMint: PublicKey, toMint: PublicKey): string {\n  const [first, second] =\n    fromMint < toMint ? [fromMint, toMint] : [toMint, fromMint];\n  return first.toString() + second.toString();\n}\n\nasync function wormholeSwapMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<[PublicKey, RouteKind] | null> {\n  let market = wormholeNativeMarket(fromMint, toMint);\n  if (market !== null) {\n    return [market, \"wormhole-native\"];\n  }\n  market = await wormholeSolletMarket(\n    conn,\n    fromMint,\n    toMint,\n    wormholeMap,\n    solletMap\n  );\n  if (market === null) {\n    return null;\n  }\n  return [market, \"wormhole-sollet\"];\n}\n\nfunction wormholeNativeMarket(\n  fromMint: PublicKey,\n  toMint: PublicKey\n): PublicKey | null {\n  return WORMHOLE_NATIVE_MAP.get(wormKey(fromMint, toMint)) ?? null;\n}\n\n// Returns the market address of the 1-1 sollet<->wormhole swap market if it\n// exists. Otherwise, returns null.\nasync function wormholeSolletMarket(\n  conn: Connection,\n  fromMint: PublicKey,\n  toMint: PublicKey,\n  wormholeMap: Map<string, TokenInfo>,\n  solletMap: Map<string, TokenInfo>\n): Promise<PublicKey | null> {\n  const fromWormhole = wormholeMap.get(fromMint.toString());\n  const isFromWormhole = fromWormhole !== undefined;\n\n  const toWormhole = wormholeMap.get(toMint.toString());\n  const isToWormhole = toWormhole !== undefined;\n\n  const fromSollet = solletMap.get(fromMint.toString());\n  const isFromSollet = fromSollet !== undefined;\n\n  const toSollet = solletMap.get(toMint.toString());\n  const isToSollet = toSollet !== undefined;\n\n  if ((isFromWormhole || isToWormhole) && isFromWormhole !== isToWormhole) {\n    if ((isFromSollet || isToSollet) && isFromSollet !== isToSollet) {\n      const base = isFromSollet ? fromMint : toMint;\n      const [quote, wormholeInfo] = isFromWormhole\n        ? [fromMint, fromWormhole]\n        : [toMint, toWormhole];\n\n      const solletInfo = await fetchSolletInfo(base);\n\n      if (solletInfo.erc20Contract !== wormholeInfo!.extensions?.address) {\n        return null;\n      }\n\n      const market = await deriveWormholeMarket(base, quote);\n      if (market === null) {\n        return null;\n      }\n\n      const marketExists = await requestWormholeSwapMarketIfNeeded(\n        conn,\n        base,\n        quote,\n        market,\n        solletInfo\n      );\n      if (!marketExists) {\n        return null;\n      }\n\n      return market;\n    }\n  }\n  return null;\n}\n\n// Calculates the deterministic address for the sollet<->wormhole 1-1 swap\n// market.\nasync function deriveWormholeMarket(\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  version = 0\n): Promise<PublicKey | null> {\n  if (version > 99) {\n    console.log(\"Swap market version cannot be greater than 99\");\n    return null;\n  }\n  if (version < 0) {\n    console.log(\"Version cannot be less than zero\");\n    return null;\n  }\n\n  const padToTwo = (n: number) => (n <= 99 ? `0${n}`.slice(-2) : n);\n  const seed =\n    baseMint.toString().slice(0, 15) +\n    quoteMint.toString().slice(0, 15) +\n    padToTwo(version);\n  return await PublicKey.createWithSeed(WORM_MARKET_BASE, seed, DEX_PID);\n}\n\ntype Bbo = {\n  bestBid?: number;\n  bestOffer?: number;\n  mid?: number;\n};\n\nconst _ORDERBOOK_CACHE = new Map<string, Promise<Orderbook>>();\nconst _MARKET_CACHE = new Map<string, Promise<Market>>();\n"]},"metadata":{},"sourceType":"module"}