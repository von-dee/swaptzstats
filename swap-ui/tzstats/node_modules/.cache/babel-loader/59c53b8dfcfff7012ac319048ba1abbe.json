{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar serum_1 = require(\"@project-serum/serum\");\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar utils_1 = require(\"./utils\"); // Utility class to parse the token list for markets.\n\n\nvar SwapMarkets = /*#__PURE__*/function () {\n  function SwapMarkets(provider, tokenList) {\n    _classCallCheck(this, SwapMarkets);\n\n    this.provider = provider;\n    this.tokenList = tokenList;\n  }\n\n  _createClass(SwapMarkets, [{\n    key: \"tokens\",\n    value: function tokens() {\n      return this.tokenList.getList().filter(function (t) {\n        var _a, _b;\n\n        var isUsdxQuoted = ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt) || ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdc);\n        return isUsdxQuoted;\n      }).map(function (t) {\n        return new web3_js_1.PublicKey(t.address);\n      });\n    }\n  }, {\n    key: \"pairs\",\n    value: function pairs(mint) {\n      var _a, _b;\n\n      var tokenList = this.tokenList.getList();\n      var mintInfo = this.tokenList.getList().filter(function (t) {\n        return t.address === mint.toString();\n      })[0];\n\n      if (mintInfo === undefined) {\n        return [];\n      }\n\n      var pairs = new Set(); // Add all tokens that also have USDC quoted markets.\n\n      if ((_a = mintInfo.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) {\n        pairs.add(utils_1.USDC_PUBKEY.toString());\n        var iter = tokenList.filter(function (t) {\n          var _a;\n\n          return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc);\n        }).map(function (t) {\n          return t.address;\n        });\n        iter.forEach(pairs.add, pairs);\n      } // Add all tokens that also have USDT quoted markets.\n\n\n      if ((_b = mintInfo.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) {\n        pairs.add(utils_1.USDT_PUBKEY.toString());\n        tokenList.filter(function (t) {\n          var _a;\n\n          return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt);\n        }).map(function (t) {\n          return t.address;\n        }).forEach(pairs.add, pairs);\n      }\n\n      return _toConsumableArray(pairs).map(function (t) {\n        return new web3_js_1.PublicKey(t);\n      });\n    } // Returns the `usdxMint` quoted market address *if* no open orders account\n    // already exists.\n\n  }, {\n    key: \"getMarketAddressIfNeeded\",\n    value: function () {\n      var _getMarketAddressIfNeeded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(usdxMint, baseMint) {\n        var marketAddress, accounts;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                marketAddress = this.getMarketAddress(usdxMint, baseMint);\n\n                if (!(marketAddress === null)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('Market not found');\n\n              case 3:\n                _context.next = 5;\n                return serum_1.OpenOrders.findForMarketAndOwner(this.provider.connection, marketAddress, this.provider.wallet.publicKey, utils_1.DEX_PID);\n\n              case 5:\n                accounts = _context.sent;\n\n                if (!(accounts[0] !== undefined)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new Error('Open orders account already exists');\n\n              case 8:\n                return _context.abrupt(\"return\", marketAddress);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getMarketAddressIfNeeded(_x, _x2) {\n        return _getMarketAddressIfNeeded.apply(this, arguments);\n      }\n\n      return getMarketAddressIfNeeded;\n    }() // Returns the `usdxMint` quoted market address.\n\n  }, {\n    key: \"getMarketAddress\",\n    value: function getMarketAddress(usdxMint, baseMint) {\n      var market = this.tokenList.getList().filter(function (t) {\n        var _a, _b;\n\n        if (t.address !== (baseMint === null || baseMint === void 0 ? void 0 : baseMint.toString())) {\n          return false;\n        }\n\n        if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n          return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n        } else if (usdxMint.equals(utils_1.USDT_PUBKEY)) {\n          return ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) !== undefined;\n        } else {\n          return false;\n        }\n      }).map(function (t) {\n        if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n          return new web3_js_1.PublicKey(t.extensions.serumV3Usdc);\n        } else {\n          return new web3_js_1.PublicKey(t.extensions.serumV3Usdt);\n        }\n      })[0];\n\n      if (market === undefined) {\n        return null;\n      }\n\n      return market;\n    } // Returns true if there's a trade across two USDC quoted markets\n    // `fromMint` `toMint`.\n\n  }, {\n    key: \"usdcPathExists\",\n    value: function usdcPathExists(fromMint, toMint) {\n      var fromMarket = this.tokenList.getList().filter(function (t) {\n        return t.address === fromMint.toString();\n      }).filter(function (t) {\n        var _a;\n\n        return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n      })[0];\n      var toMarket = this.tokenList.getList().filter(function (t) {\n        return t.address === toMint.toString();\n      }).filter(function (t) {\n        var _a;\n\n        return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n      })[0];\n      return fromMarket !== undefined && toMarket !== undefined;\n    }\n  }, {\n    key: \"route\",\n    value: function route(fromMint, toMint) {\n      if (fromMint.equals(utils_1.USDC_PUBKEY) || fromMint.equals(utils_1.USDT_PUBKEY)) {\n        var market = this.getMarketAddress(fromMint, toMint);\n\n        if (market === null) {\n          return null;\n        }\n\n        return [market];\n      } else if (toMint.equals(utils_1.USDC_PUBKEY) || toMint.equals(utils_1.USDT_PUBKEY)) {\n        var _market = this.getMarketAddress(toMint, fromMint);\n\n        if (_market === null) {\n          return null;\n        }\n\n        return [_market];\n      } else {\n        var fromMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, fromMint);\n        var toMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, toMint);\n\n        if (fromMarket === null || toMarket === null) {\n          fromMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, fromMint);\n          toMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, toMint);\n\n          if (fromMarket === null || toMarket === null) {\n            return null;\n          }\n        }\n\n        return [fromMarket, toMarket];\n      }\n    }\n  }]);\n\n  return SwapMarkets;\n}();\n\nexports.default = SwapMarkets;","map":{"version":3,"sources":["../src/swap-markets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst serum_1 = require(\"@project-serum/serum\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst utils_1 = require(\"./utils\");\n// Utility class to parse the token list for markets.\nclass SwapMarkets {\n    constructor(provider, tokenList) {\n        this.provider = provider;\n        this.tokenList = tokenList;\n    }\n    tokens() {\n        return this.tokenList\n            .getList()\n            .filter((t) => {\n            var _a, _b;\n            const isUsdxQuoted = ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt) || ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdc);\n            return isUsdxQuoted;\n        })\n            .map((t) => new web3_js_1.PublicKey(t.address));\n    }\n    pairs(mint) {\n        var _a, _b;\n        const tokenList = this.tokenList.getList();\n        const mintInfo = this.tokenList\n            .getList()\n            .filter((t) => t.address === mint.toString())[0];\n        if (mintInfo === undefined) {\n            return [];\n        }\n        const pairs = new Set();\n        // Add all tokens that also have USDC quoted markets.\n        if ((_a = mintInfo.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) {\n            pairs.add(utils_1.USDC_PUBKEY.toString());\n            let iter = tokenList\n                .filter((t) => { var _a; return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc); })\n                .map((t) => t.address);\n            iter.forEach(pairs.add, pairs);\n        }\n        // Add all tokens that also have USDT quoted markets.\n        if ((_b = mintInfo.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) {\n            pairs.add(utils_1.USDT_PUBKEY.toString());\n            tokenList\n                .filter((t) => { var _a; return t.address !== mintInfo.address && ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdt); })\n                .map((t) => t.address)\n                .forEach(pairs.add, pairs);\n        }\n        return [...pairs].map((t) => new web3_js_1.PublicKey(t));\n    }\n    // Returns the `usdxMint` quoted market address *if* no open orders account\n    // already exists.\n    async getMarketAddressIfNeeded(usdxMint, baseMint) {\n        const marketAddress = this.getMarketAddress(usdxMint, baseMint);\n        if (marketAddress === null) {\n            throw new Error('Market not found');\n        }\n        let accounts = await serum_1.OpenOrders.findForMarketAndOwner(this.provider.connection, marketAddress, this.provider.wallet.publicKey, utils_1.DEX_PID);\n        if (accounts[0] !== undefined) {\n            throw new Error('Open orders account already exists');\n        }\n        return marketAddress;\n    }\n    // Returns the `usdxMint` quoted market address.\n    getMarketAddress(usdxMint, baseMint) {\n        const market = this.tokenList\n            .getList()\n            .filter((t) => {\n            var _a, _b;\n            if (t.address !== (baseMint === null || baseMint === void 0 ? void 0 : baseMint.toString())) {\n                return false;\n            }\n            if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n                return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined;\n            }\n            else if (usdxMint.equals(utils_1.USDT_PUBKEY)) {\n                return ((_b = t.extensions) === null || _b === void 0 ? void 0 : _b.serumV3Usdt) !== undefined;\n            }\n            else {\n                return false;\n            }\n        })\n            .map((t) => {\n            if (usdxMint.equals(utils_1.USDC_PUBKEY)) {\n                return new web3_js_1.PublicKey(t.extensions.serumV3Usdc);\n            }\n            else {\n                return new web3_js_1.PublicKey(t.extensions.serumV3Usdt);\n            }\n        })[0];\n        if (market === undefined) {\n            return null;\n        }\n        return market;\n    }\n    // Returns true if there's a trade across two USDC quoted markets\n    // `fromMint` `toMint`.\n    usdcPathExists(fromMint, toMint) {\n        const fromMarket = this.tokenList\n            .getList()\n            .filter((t) => t.address === fromMint.toString())\n            .filter((t) => { var _a; return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined; })[0];\n        const toMarket = this.tokenList\n            .getList()\n            .filter((t) => t.address === toMint.toString())\n            .filter((t) => { var _a; return ((_a = t.extensions) === null || _a === void 0 ? void 0 : _a.serumV3Usdc) !== undefined; })[0];\n        return fromMarket !== undefined && toMarket !== undefined;\n    }\n    route(fromMint, toMint) {\n        if (fromMint.equals(utils_1.USDC_PUBKEY) || fromMint.equals(utils_1.USDT_PUBKEY)) {\n            const market = this.getMarketAddress(fromMint, toMint);\n            if (market === null) {\n                return null;\n            }\n            return [market];\n        }\n        else if (toMint.equals(utils_1.USDC_PUBKEY) || toMint.equals(utils_1.USDT_PUBKEY)) {\n            const market = this.getMarketAddress(toMint, fromMint);\n            if (market === null) {\n                return null;\n            }\n            return [market];\n        }\n        else {\n            let fromMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, fromMint);\n            let toMarket = this.getMarketAddress(utils_1.USDC_PUBKEY, toMint);\n            if (fromMarket === null || toMarket === null) {\n                fromMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, fromMint);\n                toMarket = this.getMarketAddress(utils_1.USDT_PUBKEY, toMint);\n                if (fromMarket === null || toMarket === null) {\n                    return null;\n                }\n            }\n            return [fromMarket, toMarket];\n        }\n    }\n}\nexports.default = SwapMarkets;\n//# sourceMappingURL=swap-markets.js.map"]},"metadata":{},"sourceType":"script"}