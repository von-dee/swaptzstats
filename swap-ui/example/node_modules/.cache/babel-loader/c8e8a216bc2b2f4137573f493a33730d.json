{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/TokenList.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport React, { useContext, useMemo } from \"react\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst _TokenListContext = /*#__PURE__*/React.createContext(null); // Tag in the spl-token-registry for sollet wrapped tokens.\n\n\nexport const SPL_REGISTRY_SOLLET_TAG = \"wrapped-sollet\"; // Tag in the spl-token-registry for wormhole wrapped tokens.\n\nexport const SPL_REGISTRY_WORM_TAG = \"wormhole\";\nconst SOL_TOKEN_INFO = {\n  chainId: 101,\n  address: SOL_MINT.toString(),\n  name: \"Native SOL\",\n  decimals: \"9\",\n  symbol: \"SOL\",\n  logoURI: \"https://cdn.jsdelivr.net/gh/trustwallet/assets@master/blockchains/solana/info/logo.png\",\n  tags: [],\n  extensions: {\n    website: \"https://solana.com/\",\n    serumV3Usdc: \"9wFFyRfZBsuAha4YcuxcXLKwMxJR43S7fPfQLusDBzvT\",\n    serumV3Usdt: \"HWHvQhFmJB3NUcu1aihKmrKegfVxBEHzwVX6yZCKEsi1\",\n    coingeckoId: \"solana\",\n    waterfallbot: \"https://t.me/SOLwaterfall\"\n  }\n};\nexport function TokenListContextProvider(props) {\n  _s();\n\n  const tokenList = useMemo(() => {\n    const list = props.tokenList.filterByClusterSlug(\"mainnet-beta\").getList(); // Manually add a fake SOL mint for the native token. The component is\n    // opinionated in that it distinguishes between wrapped SOL and SOL.\n\n    list.push(SOL_TOKEN_INFO);\n    return list;\n  }, [props.tokenList]); // Token map for quick lookup.\n\n  const tokenMap = useMemo(() => {\n    const tokenMap = new Map();\n    tokenList.forEach(t => {\n      tokenMap.set(t.address, t);\n    });\n    return tokenMap;\n  }, [tokenList]); // Tokens with USD(x) quoted markets.\n\n  const swappableTokens = useMemo(() => {\n    const tokens = tokenList.filter(t => {\n      var _t$extensions, _t$extensions2;\n\n      const isUsdxQuoted = ((_t$extensions = t.extensions) === null || _t$extensions === void 0 ? void 0 : _t$extensions.serumV3Usdt) || ((_t$extensions2 = t.extensions) === null || _t$extensions2 === void 0 ? void 0 : _t$extensions2.serumV3Usdc);\n      return isUsdxQuoted;\n    });\n    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);\n    return tokens;\n  }, [tokenList, tokenMap]); // Sollet wrapped tokens.\n\n  const [swappableTokensSollet, solletMap] = useMemo(() => {\n    const tokens = tokenList.filter(t => {\n      var _t$tags;\n\n      const isSollet = (_t$tags = t.tags) === null || _t$tags === void 0 ? void 0 : _t$tags.includes(SPL_REGISTRY_SOLLET_TAG);\n      return isSollet;\n    });\n    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);\n    return [tokens, new Map(tokens.map(t => [t.address, t]))];\n  }, [tokenList]); // Wormhole wrapped tokens.\n\n  const [swappableTokensWormhole, wormholeMap] = useMemo(() => {\n    const tokens = tokenList.filter(t => {\n      var _t$tags2;\n\n      const isSollet = (_t$tags2 = t.tags) === null || _t$tags2 === void 0 ? void 0 : _t$tags2.includes(SPL_REGISTRY_WORM_TAG);\n      return isSollet;\n    });\n    tokens.sort((a, b) => a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0);\n    return [tokens, new Map(tokens.map(t => [t.address, t]))];\n  }, [tokenList]);\n  return /*#__PURE__*/_jsxDEV(_TokenListContext.Provider, {\n    value: {\n      tokenMap,\n      wormholeMap,\n      solletMap,\n      swappableTokens,\n      swappableTokensWormhole,\n      swappableTokensSollet\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 5\n  }, this);\n}\n\n_s(TokenListContextProvider, \"0dwmnYlkjDqj/GRGkD3TuDGFxvk=\");\n\n_c = TokenListContextProvider;\nexport function useTokenListContext() {\n  _s2();\n\n  const ctx = useContext(_TokenListContext);\n\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n\n  return ctx;\n}\n\n_s2(useTokenListContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\n\nexport function useTokenMap() {\n  _s3();\n\n  const {\n    tokenMap\n  } = useTokenListContext();\n  return tokenMap;\n}\n\n_s3(useTokenMap, \"zvtcasNXbre+hO8Z+teJRZ+q38k=\", false, function () {\n  return [useTokenListContext];\n});\n\nexport function useSwappableTokens() {\n  _s4();\n\n  const {\n    swappableTokens,\n    swappableTokensWormhole,\n    swappableTokensSollet\n  } = useTokenListContext();\n  return {\n    swappableTokens,\n    swappableTokensWormhole,\n    swappableTokensSollet\n  };\n}\n\n_s4(useSwappableTokens, \"5A/Jm+O01c1Wwl4aJTx26kbSmew=\", false, function () {\n  return [useTokenListContext];\n});\n\nvar _c;\n\n$RefreshReg$(_c, \"TokenListContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/TokenList.tsx"],"names":["React","useContext","useMemo","SOL_MINT","_TokenListContext","createContext","SPL_REGISTRY_SOLLET_TAG","SPL_REGISTRY_WORM_TAG","SOL_TOKEN_INFO","chainId","address","toString","name","decimals","symbol","logoURI","tags","extensions","website","serumV3Usdc","serumV3Usdt","coingeckoId","waterfallbot","TokenListContextProvider","props","tokenList","list","filterByClusterSlug","getList","push","tokenMap","Map","forEach","t","set","swappableTokens","tokens","filter","isUsdxQuoted","sort","a","b","swappableTokensSollet","solletMap","isSollet","includes","map","swappableTokensWormhole","wormholeMap","children","useTokenListContext","ctx","Error","useTokenMap","useSwappableTokens"],"mappings":"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","sourcesContent":["import React, { useContext, useMemo } from \"react\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\n\ntype TokenListContext = {\n  tokenMap: Map<string, TokenInfo>;\n  wormholeMap: Map<string, TokenInfo>;\n  solletMap: Map<string, TokenInfo>;\n  swappableTokens: TokenInfo[];\n  swappableTokensSollet: TokenInfo[];\n  swappableTokensWormhole: TokenInfo[];\n};\nconst _TokenListContext = React.createContext<null | TokenListContext>(null);\n\n// Tag in the spl-token-registry for sollet wrapped tokens.\nexport const SPL_REGISTRY_SOLLET_TAG = \"wrapped-sollet\";\n\n// Tag in the spl-token-registry for wormhole wrapped tokens.\nexport const SPL_REGISTRY_WORM_TAG = \"wormhole\";\n\nconst SOL_TOKEN_INFO = {\n  chainId: 101,\n  address: SOL_MINT.toString(),\n  name: \"Native SOL\",\n  decimals: \"9\",\n  symbol: \"SOL\",\n  logoURI:\n    \"https://cdn.jsdelivr.net/gh/trustwallet/assets@master/blockchains/solana/info/logo.png\",\n  tags: [],\n  extensions: {\n    website: \"https://solana.com/\",\n    serumV3Usdc: \"9wFFyRfZBsuAha4YcuxcXLKwMxJR43S7fPfQLusDBzvT\",\n    serumV3Usdt: \"HWHvQhFmJB3NUcu1aihKmrKegfVxBEHzwVX6yZCKEsi1\",\n    coingeckoId: \"solana\",\n    waterfallbot: \"https://t.me/SOLwaterfall\",\n  },\n};\n\nexport function TokenListContextProvider(props: any) {\n  const tokenList = useMemo(() => {\n    const list = props.tokenList.filterByClusterSlug(\"mainnet-beta\").getList();\n    // Manually add a fake SOL mint for the native token. The component is\n    // opinionated in that it distinguishes between wrapped SOL and SOL.\n    list.push(SOL_TOKEN_INFO);\n    return list;\n  }, [props.tokenList]);\n\n  // Token map for quick lookup.\n  const tokenMap = useMemo(() => {\n    const tokenMap = new Map();\n    tokenList.forEach((t: TokenInfo) => {\n      tokenMap.set(t.address, t);\n    });\n    return tokenMap;\n  }, [tokenList]);\n\n  // Tokens with USD(x) quoted markets.\n  const swappableTokens = useMemo(() => {\n    const tokens = tokenList.filter((t: TokenInfo) => {\n      const isUsdxQuoted =\n        t.extensions?.serumV3Usdt || t.extensions?.serumV3Usdc;\n      return isUsdxQuoted;\n    });\n    tokens.sort((a: TokenInfo, b: TokenInfo) =>\n      a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0\n    );\n    return tokens;\n  }, [tokenList, tokenMap]);\n\n  // Sollet wrapped tokens.\n  const [swappableTokensSollet, solletMap] = useMemo(() => {\n    const tokens = tokenList.filter((t: TokenInfo) => {\n      const isSollet = t.tags?.includes(SPL_REGISTRY_SOLLET_TAG);\n      return isSollet;\n    });\n    tokens.sort((a: TokenInfo, b: TokenInfo) =>\n      a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0\n    );\n    return [\n      tokens,\n      new Map<string, TokenInfo>(tokens.map((t: TokenInfo) => [t.address, t])),\n    ];\n  }, [tokenList]);\n\n  // Wormhole wrapped tokens.\n  const [swappableTokensWormhole, wormholeMap] = useMemo(() => {\n    const tokens = tokenList.filter((t: TokenInfo) => {\n      const isSollet = t.tags?.includes(SPL_REGISTRY_WORM_TAG);\n      return isSollet;\n    });\n    tokens.sort((a: TokenInfo, b: TokenInfo) =>\n      a.symbol < b.symbol ? -1 : a.symbol > b.symbol ? 1 : 0\n    );\n    return [\n      tokens,\n      new Map<string, TokenInfo>(tokens.map((t: TokenInfo) => [t.address, t])),\n    ];\n  }, [tokenList]);\n\n  return (\n    <_TokenListContext.Provider\n      value={{\n        tokenMap,\n        wormholeMap,\n        solletMap,\n        swappableTokens,\n        swappableTokensWormhole,\n        swappableTokensSollet,\n      }}\n    >\n      {props.children}\n    </_TokenListContext.Provider>\n  );\n}\n\nexport function useTokenListContext(): TokenListContext {\n  const ctx = useContext(_TokenListContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\nexport function useTokenMap(): Map<string, TokenInfo> {\n  const { tokenMap } = useTokenListContext();\n  return tokenMap;\n}\n\nexport function useSwappableTokens() {\n  const { swappableTokens, swappableTokensWormhole, swappableTokensSollet } =\n    useTokenListContext();\n  return { swappableTokens, swappableTokensWormhole, swappableTokensSollet };\n}\n"]},"metadata":{},"sourceType":"module"}