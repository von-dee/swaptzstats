{"ast":null,"code":"var _jsxFileName = \"/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Token.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { BN } from \"@project-serum/anchor\";\nimport { Account } from \"@solana/web3.js\";\nimport { Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { getOwnedAssociatedTokenAccounts, parseTokenAccountData } from \"../utils/tokens\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst _TokenContext = /*#__PURE__*/React.createContext(null);\n\nexport function TokenContextProvider(props) {\n  _s();\n\n  const provider = props.provider;\n  const [, setRefresh] = useState(0); // Fetch all the owned token accounts for the wallet.\n\n  useEffect(() => {\n    if (!provider.wallet.publicKey) {\n      _OWNED_TOKEN_ACCOUNTS_CACHE.length = 0;\n      setRefresh(r => r + 1);\n      return;\n    } // Fetch SPL tokens.\n\n\n    getOwnedAssociatedTokenAccounts(provider.connection, provider.wallet.publicKey).then(accs => {\n      if (accs) {\n        // @ts-ignore\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push(...accs);\n\n        setRefresh(r => r + 1);\n      }\n    }); // Fetch SOL balance.\n\n    provider.connection.getAccountInfo(provider.wallet.publicKey).then(acc => {\n      if (acc) {\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push({\n          publicKey: provider.wallet.publicKey,\n          // @ts-ignore\n          account: {\n            amount: new BN(acc.lamports),\n            mint: SOL_MINT\n          }\n        });\n\n        setRefresh(r => r + 1);\n      }\n    });\n  }, [provider.wallet.publicKey, provider.connection]);\n  return /*#__PURE__*/_jsxDEV(_TokenContext.Provider, {\n    value: {\n      provider\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 64,\n    columnNumber: 5\n  }, this);\n}\n\n_s(TokenContextProvider, \"SENTX22wnP5IY7t1CWMHdefwhAs=\");\n\n_c = TokenContextProvider;\n\nfunction useTokenContext() {\n  _s2();\n\n  const ctx = useContext(_TokenContext);\n\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n\n  return ctx;\n} // Null => none exists.\n// Undefined => loading.\n\n\n_s2(useTokenContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\n\nexport function useOwnedTokenAccount(mint) {\n  _s3();\n\n  const {\n    provider\n  } = useTokenContext();\n  const [, setRefresh] = useState(0);\n\n  const tokenAccounts = _OWNED_TOKEN_ACCOUNTS_CACHE.filter(account => mint && account.account.mint.equals(mint)); // Take the account with the most tokens in it.\n\n\n  tokenAccounts.sort((a, b) => a.account.amount > b.account.amount ? -1 : a.account.amount < b.account.amount ? 1 : 0);\n  let tokenAccount = tokenAccounts[0];\n  const isSol = mint === null || mint === void 0 ? void 0 : mint.equals(SOL_MINT); // Stream updates when the balance changes.\n\n  useEffect(() => {\n    let listener; // SOL is special cased since it's not an SPL token.\n\n    if (tokenAccount && isSol) {\n      listener = provider.connection.onAccountChange(provider.wallet.publicKey, info => {\n        const token = {\n          amount: new BN(info.lamports),\n          mint: SOL_MINT\n        };\n\n        if (token.amount !== tokenAccount.account.amount) {\n          const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n\n          assert.ok(index >= 0);\n          _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n          setRefresh(r => r + 1);\n        }\n      });\n    } // SPL tokens.\n    else if (tokenAccount) {\n      listener = provider.connection.onAccountChange(tokenAccount.publicKey, info => {\n        if (info.data.length !== 0) {\n          try {\n            const token = parseTokenAccountData(info.data);\n\n            if (token.amount !== tokenAccount.account.amount) {\n              const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n\n              assert.ok(index >= 0);\n              _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n              setRefresh(r => r + 1);\n            }\n          } catch (error) {\n            console.log(\"Failed to decode token AccountInfo\");\n          }\n        }\n      });\n    }\n\n    return () => {\n      if (listener) {\n        provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [provider.connection, tokenAccount]);\n\n  if (mint === undefined) {\n    return undefined;\n  }\n\n  if (!isSol && tokenAccounts.length === 0) {\n    return null;\n  }\n\n  return tokenAccount;\n}\n\n_s3(useOwnedTokenAccount, \"ZMnuU7c9gUbGAKZxF9nwwLp2yt8=\", false, function () {\n  return [useTokenContext];\n});\n\nexport function useMint(mint) {\n  _s4();\n\n  const {\n    provider\n  } = useTokenContext(); // Lazy load the mint account if needeed.\n\n  const asyncMintInfo = useAsync(async () => {\n    if (!mint) {\n      return undefined;\n    }\n\n    if (_MINT_CACHE.get(mint.toString())) {\n      return _MINT_CACHE.get(mint.toString());\n    }\n\n    const mintClient = new Token(provider.connection, mint, TOKEN_PROGRAM_ID, new Account());\n    const mintInfo = mintClient.getMintInfo();\n\n    _MINT_CACHE.set(mint.toString(), mintInfo);\n\n    return mintInfo;\n  }, [provider.connection, mint]);\n\n  if (asyncMintInfo.result) {\n    return asyncMintInfo.result;\n  }\n\n  return undefined;\n}\n\n_s4(useMint, \"OSdrVDdTWKYVyALr/mwbxA0/pNE=\", false, function () {\n  return [useTokenContext, useAsync];\n});\n\nexport function setMintCache(pk, account) {\n  _MINT_CACHE.set(pk.toString(), new Promise(resolve => resolve(account)));\n} // Cache storing all token accounts for the connected wallet provider.\n\nconst _OWNED_TOKEN_ACCOUNTS_CACHE = []; // Cache storing all previously fetched mint infos.\n// @ts-ignore\n\nconst _MINT_CACHE = new Map([[SOL_MINT.toString(), {\n  decimals: 9\n}]]);\n\nvar _c;\n\n$RefreshReg$(_c, \"TokenContextProvider\");","map":{"version":3,"sources":["/Users/selasie/Documents/GitHub/dex_ui/swap-ui/src/context/Token.tsx"],"names":["React","useContext","useState","useEffect","assert","useAsync","BN","Account","Token","TOKEN_PROGRAM_ID","getOwnedAssociatedTokenAccounts","parseTokenAccountData","SOL_MINT","_TokenContext","createContext","TokenContextProvider","props","provider","setRefresh","wallet","publicKey","_OWNED_TOKEN_ACCOUNTS_CACHE","length","r","connection","then","accs","push","getAccountInfo","acc","account","amount","lamports","mint","children","useTokenContext","ctx","Error","useOwnedTokenAccount","tokenAccounts","filter","equals","sort","a","b","tokenAccount","isSol","listener","onAccountChange","info","token","index","indexOf","ok","data","error","console","log","removeAccountChangeListener","undefined","useMint","asyncMintInfo","_MINT_CACHE","get","toString","mintClient","mintInfo","getMintInfo","set","result","setMintCache","pk","Promise","resolve","Map","decimals"],"mappings":"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","sourcesContent":["import React, { useContext, useState, useEffect } from \"react\";\nimport * as assert from \"assert\";\nimport { useAsync } from \"react-async-hook\";\nimport { Provider, BN } from \"@project-serum/anchor\";\nimport { PublicKey, Account } from \"@solana/web3.js\";\nimport {\n  MintInfo,\n  AccountInfo as TokenAccount,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport {\n  getOwnedAssociatedTokenAccounts,\n  parseTokenAccountData,\n} from \"../utils/tokens\";\nimport { SOL_MINT } from \"../utils/pubkeys\";\n\nexport type TokenContext = {\n  provider: Provider;\n};\nconst _TokenContext = React.createContext<TokenContext | null>(null);\n\nexport function TokenContextProvider(props: any) {\n  const provider = props.provider;\n  const [, setRefresh] = useState(0);\n\n  // Fetch all the owned token accounts for the wallet.\n  useEffect(() => {\n    if (!provider.wallet.publicKey) {\n      _OWNED_TOKEN_ACCOUNTS_CACHE.length = 0;\n      setRefresh((r) => r + 1);\n      return;\n    }\n    // Fetch SPL tokens.\n    getOwnedAssociatedTokenAccounts(\n      provider.connection,\n      provider.wallet.publicKey\n    ).then((accs) => {\n      if (accs) {\n        // @ts-ignore\n        _OWNED_TOKEN_ACCOUNTS_CACHE.push(...accs);\n        setRefresh((r) => r + 1);\n      }\n    });\n    // Fetch SOL balance.\n    provider.connection\n      .getAccountInfo(provider.wallet.publicKey)\n      .then((acc: { lamports: number }) => {\n        if (acc) {\n          _OWNED_TOKEN_ACCOUNTS_CACHE.push({\n            publicKey: provider.wallet.publicKey,\n            // @ts-ignore\n            account: {\n              amount: new BN(acc.lamports),\n              mint: SOL_MINT,\n            },\n          });\n          setRefresh((r) => r + 1);\n        }\n      });\n  }, [provider.wallet.publicKey, provider.connection]);\n\n  return (\n    <_TokenContext.Provider\n      value={{\n        provider,\n      }}\n    >\n      {props.children}\n    </_TokenContext.Provider>\n  );\n}\n\nfunction useTokenContext() {\n  const ctx = useContext(_TokenContext);\n  if (ctx === null) {\n    throw new Error(\"Context not available\");\n  }\n  return ctx;\n}\n\n// Null => none exists.\n// Undefined => loading.\nexport function useOwnedTokenAccount(\n  mint?: PublicKey\n): { publicKey: PublicKey; account: TokenAccount } | null | undefined {\n  const { provider } = useTokenContext();\n  const [, setRefresh] = useState(0);\n  const tokenAccounts = _OWNED_TOKEN_ACCOUNTS_CACHE.filter(\n    (account) => mint && account.account.mint.equals(mint)\n  );\n\n  // Take the account with the most tokens in it.\n  tokenAccounts.sort((a, b) =>\n    a.account.amount > b.account.amount\n      ? -1\n      : a.account.amount < b.account.amount\n      ? 1\n      : 0\n  );\n\n  let tokenAccount = tokenAccounts[0];\n  const isSol = mint?.equals(SOL_MINT);\n\n  // Stream updates when the balance changes.\n  useEffect(() => {\n    let listener: number;\n    // SOL is special cased since it's not an SPL token.\n    if (tokenAccount && isSol) {\n      listener = provider.connection.onAccountChange(\n        provider.wallet.publicKey,\n        (info: { lamports: number }) => {\n          const token = {\n            amount: new BN(info.lamports),\n            mint: SOL_MINT,\n          } as TokenAccount;\n          if (token.amount !== tokenAccount.account.amount) {\n            const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n            assert.ok(index >= 0);\n            _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n            setRefresh((r) => r + 1);\n          }\n        }\n      );\n    }\n    // SPL tokens.\n    else if (tokenAccount) {\n      listener = provider.connection.onAccountChange(\n        tokenAccount.publicKey,\n        (info) => {\n          if (info.data.length !== 0) {\n            try {\n              const token = parseTokenAccountData(info.data);\n              if (token.amount !== tokenAccount.account.amount) {\n                const index = _OWNED_TOKEN_ACCOUNTS_CACHE.indexOf(tokenAccount);\n                assert.ok(index >= 0);\n                _OWNED_TOKEN_ACCOUNTS_CACHE[index].account = token;\n                setRefresh((r) => r + 1);\n              }\n            } catch (error) {\n              console.log(\"Failed to decode token AccountInfo\");\n            }\n          }\n        }\n      );\n    }\n    return () => {\n      if (listener) {\n        provider.connection.removeAccountChangeListener(listener);\n      }\n    };\n  }, [provider.connection, tokenAccount]);\n\n  if (mint === undefined) {\n    return undefined;\n  }\n\n  if (!isSol && tokenAccounts.length === 0) {\n    return null;\n  }\n\n  return tokenAccount;\n}\n\nexport function useMint(mint?: PublicKey): MintInfo | undefined | null {\n  const { provider } = useTokenContext();\n  // Lazy load the mint account if needeed.\n  const asyncMintInfo = useAsync(async () => {\n    if (!mint) {\n      return undefined;\n    }\n    if (_MINT_CACHE.get(mint.toString())) {\n      return _MINT_CACHE.get(mint.toString());\n    }\n\n    const mintClient = new Token(\n      provider.connection,\n      mint,\n      TOKEN_PROGRAM_ID,\n      new Account()\n    );\n    const mintInfo = mintClient.getMintInfo();\n    _MINT_CACHE.set(mint.toString(), mintInfo);\n    return mintInfo;\n  }, [provider.connection, mint]);\n\n  if (asyncMintInfo.result) {\n    return asyncMintInfo.result;\n  }\n  return undefined;\n}\n\nexport function setMintCache(pk: PublicKey, account: MintInfo) {\n  _MINT_CACHE.set(pk.toString(), new Promise((resolve) => resolve(account)));\n}\n\n// Cache storing all token accounts for the connected wallet provider.\nconst _OWNED_TOKEN_ACCOUNTS_CACHE: Array<{\n  publicKey: PublicKey;\n  account: TokenAccount;\n}> = [];\n\n// Cache storing all previously fetched mint infos.\n// @ts-ignore\nconst _MINT_CACHE = new Map<string, Promise<MintInfo>>([\n  [SOL_MINT.toString(), { decimals: 9 }],\n]);\n"]},"metadata":{},"sourceType":"module"}